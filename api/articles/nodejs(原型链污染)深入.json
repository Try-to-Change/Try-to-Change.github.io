{"title":"nodejs(原型链污染)深入","uid":"e43b6f3b7810dafca0563d222be1226a","slug":"nodejs(原型链污染)深入","date":"2023-09-01T05:53:59.950Z","updated":"2023-09-06T12:29:36.403Z","comments":true,"path":"api/articles/nodejs(原型链污染)深入.json","keywords":null,"cover":"/img/54.jpg","content":"<p><code>本来想将p神的JavaScript污染链文章并在我写的基础浅入里，但是感觉还是得分开学习记录，p神干货还得和我水的文章分开，浅入就讲概念理解学习吧，深入就涉及深入认识污染了</code></p>\n<span id=\"more\"></span>\n\n<h1 id=\"prototype和-proto-分别是什么\"><a href=\"#prototype和-proto-分别是什么\" class=\"headerlink\" title=\"prototype和__proto__分别是什么\"></a><code>prototype</code>和<code>__proto__</code>分别是什么</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里引用p神的文章，加上部分自己的理解</p>\n<p><a href=\"https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x02-javascript\">https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x02-javascript</a></p></blockquote>\n<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>在JavaScript中，我们如果要定义一个类，需要以<u>定义<code>“构造函数”</code>的方式定义</u>:</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901135415750.png\" alt=\"image-20230901135415750\"></p>\n<p>其中<code>Foo函数</code>就是<code>Foo类</code>的构造函数，其中的<code>this.bar</code>是<code>Foo类</code>中的一个属性。</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901154849363.png\" alt=\"image-20230901154849363\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>也就是说<code>利用function定义类</code>的同时，构造函数也被定义好了</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在ES6中引入了<code>class</code>的概念，两者是有区别，但是不是很大</p>\n<p><code>class</code>本质还是基于原型<code>prototype</code>的实现方式进一步的封装，<code>class</code>本质还是函数<code>function</code></p>\n<p>但是使用<code>class</code>定义类比<code>function</code>使得代码<code>更加直观，也更加灵活</code>，因为class定义类时，可以直接使用<code>constructor()</code>方法来定义<code>构造函数</code>，并且可以使用关键字<code>extends</code>来继承父类</p></blockquote>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901155300768.png\" alt=\"image-20230901155300768\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以看到用class定义类的时候，构造函数也是被定义好了</p></blockquote>\n<p>并且function和class两者的构造函数的名字也是一样的</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901160722382.png\" alt=\"image-20230901160722382\"></p>\n<hr>\n<p>在一个类必然有一些方法，类似属性<code>this.bar</code>，我们也可以将方法定义在构造函数的内部</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>show <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>代码中我们可以看到，<code>show</code>的定义利用了<code>function</code>，但是并没有被定义为<code>show类</code>，也就是说这个show方法并不是和上面一样是所谓<code>show类</code>的构造函数，而是<code>Foo类</code>中<code>Foo</code>这个构造函数的一个方法</p>\n<p>如下图结果可以理解，在新建实例化Foo对象，执行构造函数时，<code>show</code>方法也会被执行可知，<code>show</code>只是构造函数中的一个方法，是绑定在对象中的吗，而不是绑定在类</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901150808861.png\" alt=\"image-20230901150808861\"></p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901170534691.png\" alt=\"image-20230901170534691\"></p>\n<p>但由此出现了一个新问题，那如果每次<code>新建一个实例化对象就执行一次show方法</code>，有时在实际生产中并不需要，可能大多数时候<code>只想在创建类后执行一次</code>即可</p>\n<p>那肯定就不能把<code>show</code>方法再写到<code>function Foo&#123;&#125;</code>中去了，</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里就需要使用原型<code>prototype</code></p></blockquote>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nFoo<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>show <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> foo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nfoo<span class=\"token punctuation\">.</span><span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>这段代码其实也好理解，我们将<code>show</code>方法单独提出来当作一个函数，并加到<code>Foo</code>的原型当作一个单独的函数，<code>prototype</code>可以当作<code>Foo</code>类自带的一个属性，所有的创建的<code>Foo</code>对象都将拥有<code>Foo</code>类中所有内容，包括变量和方法。</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901170427183.png\" alt=\"image-20230901170427183\"></p>\n<p>可以看到和在构造函数中定义<code>show</code>不同的是，<code>show</code>作为和构造函数一样的显示在原型内容中，属于是新创建的<code>Foo</code>类对象可以利用的一部分。</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901171115585.png\" alt=\"image-20230901171115585\"></p>\n<p>这里将<code>Foo</code>类实例化后给<code>foo</code>，<code>foo</code>也完全可以直接调用<code>show</code>函数的内容，<code>foo</code>自身创建开始就具有<code>Foo</code>中的所有变量方法可以调用。</p>\n<hr>\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><p>我们可以通过<code>Foo.prototype</code>来访问<code>Foo</code>类的原型，但是<code>Foo</code>类实例化出来的对象，如上的<code>foo</code>，是不能直接调用<code>prototype</code>进行访问原型的</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901172350796.png\" alt=\"image-20230901172350796\"></p>\n<p>所以这里就需要提到<code>__proto__</code>，类实例化后的对象可以通过<code>__proto__</code>来直接访问类的原型。</p>\n<p>也就是</p>\n<pre class=\" language-js\"><code class=\"language-js\">foo<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">==</span> Foo<span class=\"token punctuation\">.</span>prototype\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901172719167.png\" alt=\"image-20230901172719167\"></p>\n<p>进一步思考，也就是实例化后的对象【[比如<code>foo</code>]可以像上面例子一样，通过<code>__proto__</code>访问原型定义一个新的函数，如下例子，利用<code>foo.__proto__</code>定义了一个新函数<code>hacker</code></p>\n<p>并且能成功调用执行，打印’<code>i get shell</code>‘</p>\n<pre class=\" language-js\"><code class=\"language-js\">foo<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>hacker <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">hacker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"i get shell\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901182724283.png\" alt=\"image-20230901182724283\"></p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230901182756972.png\" alt=\"image-20230901182756972\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li><code>prototype</code>是一个<code>类的属性</code>，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li>\n<li>一个对象的<code>__proto__</code>属性，指向这个对象所在的类的<code>prototype</code>属性</li>\n</ol></blockquote>\n<h1 id=\"JavaScript原型链继承\"><a href=\"#JavaScript原型链继承\" class=\"headerlink\" title=\"JavaScript原型链继承\"></a>JavaScript原型链继承</h1><p>继承在java中很常见，在JavaScript中作用也差不多，只不过概念被替换成原型了</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法，这个特性被用来实现JavaScript中的继承机制。</p></blockquote>\n<p>比如，</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Father</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>first_name <span class=\"token operator\">=</span> <span class=\"token string\">'Donald'</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>last_name <span class=\"token operator\">=</span> <span class=\"token string\">'Trump'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>first_name <span class=\"token operator\">=</span> <span class=\"token string\">'Melania'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nSon<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Father</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">let</span> son <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Name: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token punctuation\">;</span>son<span class=\"token punctuation\">.</span>first_name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">; </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token punctuation\">;</span>son<span class=\"token punctuation\">.</span>last_name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">;`</span></span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>这里的，</p>\n<pre class=\" language-js\"><code class=\"language-js\">Son<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Father</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>可以理解为Son的原型为实例化的Father类，Son类就会继承Father类得得<code>last_name</code>属性，但是继承不会覆盖自己原有的属性，所以<code>first_name</code>还是Son类自己的</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905094854794.png\" alt=\"image-20230905094854794\"></p>\n<p>然后再将<code>Son</code>实例化给<code>son</code>，那么<code>son</code>就具有<code>Son类</code>和<code>Father类</code>的所有属性</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> son <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905095519407.png\" alt=\"image-20230905095519407\"></p>\n<p>可以在这里的层次就可以看出，<code>son</code>的<code>first_name</code>是<code>以Son类为主</code>的，而由于自身没有<code>last_name</code>，就会从自己<code>原型Father类</code>继承<code>last_name</code>然后获取值</p>\n<p>于是当打印时，最后输出的是<code>Name: Melania Trump</code>。</p>\n<pre class=\" language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Name: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token punctuation\">;</span>son<span class=\"token punctuation\">.</span>first_name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">; </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token punctuation\">;</span>son<span class=\"token punctuation\">.</span>last_name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">;`</span></span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905095812582.png\" alt=\"image-20230905095812582\"></p>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上述的Son类和Father类为例，我们可以看到son的层次中，是有两个<code>Prototype</code>，这就是原型链的最简单的格式。最后一个<code>Object</code>就是<code>null</code>，他在原型Father类的后面，这也是原型链默认的最后一个原型。</p>\n<p>我们可以考虑一个问题，当我在打印<code>$&#123;son.last_name&#125;</code>，如果在<code>Father类</code>中也没有这个属性会怎么样呢，那son就会不断的顺着原型链一直找下去，直到<code>null</code></p>\n<p>就会执行，</p>\n<pre class=\" language-js\"><code class=\"language-js\">son<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905100719829.png\" alt=\"image-20230905100719829\"></p>\n<p><code>JavaScript</code>这种查找机制，被用在面向对象的继承中，被称作<code>prototype</code>继承链。</p>\n<p>以上是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记下面几点即可：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>每个构造函数都有一个原型对象</li>\n<li>对象的<code>__proto__</code>属性，指向类的原型对象<code>prototype</code></li>\n<li>JavaScript使用prototype链实现继承</li>\n</ol></blockquote>\n<h1 id=\"原型链污染是什么\"><a href=\"#原型链污染是什么\" class=\"headerlink\" title=\"原型链污染是什么\"></a>原型链污染是什么</h1><p>在最开始写过<code>foo.__proto__</code>指向Foo类的<code>prototype</code>，我们也试过通过<code>foo.__proto__</code>新增一个新函数，也可以加到原型中去，并且可以成功调用与构造函数同一层次，那么如果修改<code>foo.__proto__</code>中的一些值，同理也可以修改Foo类中的一些东西</p>\n<p>我们简单试一下，</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// foo是一个简单的JavaScript对象</span>\n<span class=\"token keyword\">let</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>bar<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// foo.bar 此时为1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 修改foo的原型（即Object）</span>\nfoo<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>bar <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 由于查找顺序的原因，foo.bar仍然是1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 此时再用Object创建一个空的zoo对象</span>\n<span class=\"token keyword\">let</span> zoo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 查看zoo.bar</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>zoo<span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>首先我们先构造一个简单对象foo，</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>bar<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>由于foo并不是某个具体类的实例，但是所有对象都有一个实例存在，那就<code>Object</code>类</p>\n<p>然后我们先看看，</p>\n<pre class=\" language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905101905435.png\" alt=\"image-20230905101905435\"></p>\n<p>同样可以看到<code>foo</code>确实存在一个原型，并且为<code>Object</code>。</p>\n<p>那么如果我们通过<code>foo.__proto__</code>修改原型中的某些值呢？</p>\n<pre class=\" language-js\"><code class=\"language-js\">foo<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>bar <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n</code></pre>\n<p>这里我们通过<code>foo.__proto__</code>将<code>bar</code>值修改为2，</p>\n<p>然后打印看看，</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905102214488.png\" alt=\"image-20230905102214488\"></p>\n<p>突然发现，打印的结果是1，而不是我们刚才修改的结果2</p>\n<p>这是为什么呢？</p>\n<p>我们再次看看foo就知道了</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905102456014.png\" alt=\"image-20230905102456014\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们可以看到，<code>bar: 1</code>是foo自身的属性，而原型Object中的<code>bar: 2</code>，层次要低于foo自身的属性，所以相同的属性，还是以自身优先，不存在或者不完善，才从原型中继承，这和上面讲的Son类和Father类是一样的。</p></blockquote>\n<p>所以这里打印结果还是1，就是这个原因。</p>\n<p>但是，如果我们再新建一个对象，让它和foo一样，原型也是只有<code>Object</code>，但是没有bar属性，再次打印会怎么样呢</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> zoo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>zoo<span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905102953845.png\" alt=\"image-20230905102953845\"></p>\n<p>可以看到打印结果为2，因为这里zoo对象没有bar属性，所以这里zoo就直接继承Object中bar属性，而Object本身并没有bar属性，是foo通过<code>foo.__proto__</code>来新增的一个属性，却能达到影响zoo对象的作用。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>那么，这种在一个应用中，攻击者控制并修改了一个对象的原型，那么将可能影响所有和这个对象来自同一个类。父祖类的对象。这种攻击方式就是原型链攻击</p></blockquote>\n<h1 id=\"哪些情况下原型链会被污染呢？\"><a href=\"#哪些情况下原型链会被污染呢？\" class=\"headerlink\" title=\"哪些情况下原型链会被污染呢？\"></a>哪些情况下原型链会被污染呢？</h1><p>根据上述内容，我们发现关键在于能够顺利调用<code>__proto__</code>并设置其值即可，那么如何成功呢？</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>关键在于找到能够控制数字【对象】的“键名”的操作即可：</p>\n<ul>\n<li>对象<code>merge</code></li>\n<li>对象<code>clone</code>（其实内核就是将待操作的对象merge到一个空对象中）</li>\n</ul></blockquote>\n<p>以对象merge为例，我们想象一个简单的merge函数：</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> source<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token keyword\">in</span> source <span class=\"token operator\">&amp;&amp;</span> key <span class=\"token keyword\">in</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>\n            target<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> source<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这个函数是一个递归函数，它的目的是将 <code>source</code> 对象中的属性合并到 <code>target</code> 对象中。它通过遍历 <code>source</code> 对象中的每一个键值对，如果 <code>target</code> 对象中也存在这个键，那么就递归调用 <code>merge</code> 函数将两个对象中对应键的值进行合并；否则，就直接将 <code>source</code> 对象中的键值对复制到 <code>target</code> 对象中。最终，<code>target</code> 对象将包含原来的属性以及 <code>source</code> 对象中的所有属性。这个函数通常用于合并两个或多个对象，以便于在一个对象中访问所有属性。</p></blockquote>\n<p>我们看到，在合并时存在复制操作<code>target[key] = source[key]</code>，那么如果这个key是<code>__proto__</code>，是否就可以成功造成污染呢？</p>\n<p>试一下，</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> o1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> o2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"__proto__\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span>b<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>o1<span class=\"token punctuation\">,</span> o2<span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o1<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span> o1<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span>\n\no3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o3<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>这里可以看到o1和o2确实是合并成功了</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905110223841.png\" alt=\"image-20230905110223841\"></p>\n<p>但是我们的<code>__proto__</code>不见了，取而代之发现多了个<code>Object</code>原型，也就是说我们的<code>__proto__</code>被当作o2的原型，也就是其自身的<code>Object</code>，但是并没有影响最后一个每个对象共有<code>Object</code>，所以污染是无效的</p>\n<p>此时遍历o2的所有键名，拿到的只要[a,b]，<code>__proto__</code>并不是一个key，自然也不无法修改Object的原型。</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905110442713.png\" alt=\"image-20230905110442713\"></p>\n<p>所有当我们想用<code>o3</code>测试是否污染时，发现是没有的</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905111044306.png\" alt=\"image-20230905111044306\"></p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905111219362.png\" alt=\"image-20230905111219362\"></p>\n<p>那么如何将<code>__proto__</code>被当作是一个键名呢，只要加一个解析就行</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> o1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> o2 <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token string\">'{;\"a\": 1, \"__proto__\": {;\"b\": 2};};'</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>o1<span class=\"token punctuation\">,</span> o2<span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o1<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span> o1<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span>\n\no3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o3<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>再看看o2的数据，</p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905111651534.png\" alt=\"image-20230905111651534\"></p>\n<p>发现这次<code>__proto__</code>，没有被当作o2的原型了，而是一个键值</p>\n<p>此时再次打印o3，发现成功污染<code>Object</code></p>\n<p><img src=\"/post/nodejs(%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)%E6%B7%B1%E5%85%A5/image-20230905111841511.png\" alt=\"image-20230905111841511\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p></blockquote>\n<p>可以是为什么能实现将属性b以及其值污染到Object中呢？</p>\n<p>其实很简单，</p>\n<p>我们实际修改原型时用的语法是</p>\n<pre class=\" language-js\"><code class=\"language-js\">o2<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n</code></pre>\n<p>而读取数组中键值也是如此语法，所以当键值为<code>__proto__</code>时，调用<code>__proto__</code>其后的数据因为语法，会被当作修改原型的值，从而实现原型链污染的作用</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>ps. <code>merge</code>操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。</p></blockquote>\n<hr>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>最后可以做一下p神的</p>\n<p>Code-Breaking 2018 Thejs</p>\n<p><a href=\"https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js\">https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js</a></p></blockquote>\n","text":"本来想将p神的JavaScript污染链文章并在我写的基础浅入里，但是感觉还是得分开学习记录，p神干货还得和我水的文章分开，浅入就讲概念理解学习吧，深入就涉及深...","permalink":"/post/nodejs(原型链污染)深入","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"网络安全学习","slug":"网络安全学习","count":26,"path":"api/categories/网络安全学习.json"}],"tags":[{"name":"js","slug":"js","count":3,"path":"api/tags/js.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#prototype%E5%92%8C-proto-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">prototype和__proto__分别是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9\"><span class=\"toc-text\">关键点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">JavaScript原型链继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">原型链污染是什么</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%BC%9A%E8%A2%AB%E6%B1%A1%E6%9F%93%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">哪些情况下原型链会被污染呢？</span></a></li></ol>","author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java安全[反射(3)]","uid":"8c22bcc128dc13c7c13ac9d40b733df9","slug":"Java安全[反射(3)]","date":"2023-09-09T04:23:45.002Z","updated":"2023-10-19T14:51:54.918Z","comments":true,"path":"api/articles/Java安全[反射(3)].json","keywords":null,"cover":"/img/57.jpg","text":" Java执行命令的方法ProcessBuilder 反射中使用getConstructor获取构造有参构造函数 可变长参数（varargs）在反射中的意义与使...","permalink":"/post/Java安全[反射(3)]","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"Java漫谈学习","slug":"Java漫谈学习","count":7,"path":"api/categories/Java漫谈学习.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"}],"author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"nodejs(原型链污染)浅入","uid":"e19214c909dc9beefabf464664f17048","slug":"nodejs(原型链污染)浅入","date":"2023-08-25T02:16:13.700Z","updated":"2023-09-06T12:29:34.181Z","comments":true,"path":"api/articles/nodejs(原型链污染)浅入.json","keywords":null,"cover":"/img/53.jpg","text":"狠狠污染链，狠狠的继承类 原型与原型链 想要原型链污染，先要了解什么是原型与原型链 Javascript中一切皆是对象，其中对象之间是存在共同和差异的，比如对象...","permalink":"/post/nodejs(原型链污染)浅入","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"网络安全学习","slug":"网络安全学习","count":26,"path":"api/categories/网络安全学习.json"}],"tags":[{"name":"js","slug":"js","count":3,"path":"api/tags/js.json"}],"author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}