{"title":"Java安全[RMI(3)]","uid":"424a81b28b15c5b3a4612243a8ecf368","slug":"Java安全[RMI(3)]","date":"2023-10-17T14:36:06.745Z","updated":"2023-10-25T05:31:04.142Z","comments":true,"path":"api/articles/Java安全[RMI(3)].json","keywords":null,"cover":"/img/60.jpg","content":"<p><code>RMI2</code>中成功实现了codebase进行加载恶意类，但是在实际环境确实难实现符合环境，所以只作为一个了解和认识。</p>\n<p>这篇文章主要分析codebase是如何在RMI中进行传递的，以及对分析Java序列化数据的工具<code>SerializationDumper</code>的使用介绍</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Java安全-RMI-3\"><a href=\"#Java安全-RMI-3\" class=\"headerlink\" title=\"Java安全[RMI(3)]\"></a>Java安全[RMI(3)]</h1><h2 id=\"数据包解析以及SerializationDumper工具\"><a href=\"#数据包解析以及SerializationDumper工具\" class=\"headerlink\" title=\"数据包解析以及SerializationDumper工具\"></a>数据包解析以及SerializationDumper工具</h2><p>这里选择的是<code>JRMI,Call</code>的数据包，打开右键<code>Java Serialization</code>数据段，复制<code>Hex Stream</code>，看到<code>ac ed</code>就知道后面是java序列化数据</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们可以用 </p>\n<p><code>tcp.stream eq 0</code> 来筛选出本机与RMI Registry的数据流</p>\n<p><code>tcp.stream eq 1</code> 来筛选出本机与RMI Server的数据流</p></blockquote>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(3)]/image-20231025005115061.png\" alt=\"image-20231025005115061\"></p>\n<p>将复制的<code>Hex Stream</code>用工具解析</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(3)]/image-20231025005053560.png\" alt=\"image-20231025005053560\"></p>\n<p>但是有很多参数看不懂，可以看看Java序列化的协议文档：<code>https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html</code></p>\n<p>这篇文档里用了一种类似BNF（巴科斯范式）的形式描述了序列化数据的语法，比如我们这里的这段简 单的数据，其涉及到如下语法规则： </p>\n<pre><code>stream:\nmagic version contents\ncontents:\ncontent\ncontents content\ncontent:\nobject\nblockdata\nobject:\nnewObject\nnewClass\nnewArray\nnewString\nnewEnum\nnewClassDesc\nprevObject\nnullReference\nexception\nTC_RESET\nblockdata:\nblockdatashort\nblockdatalong\nblockdatashort:\nTC_BLOCKDATA (unsigned byte)&lt;size&gt; (byte)[size]\nnewString:\nTC_STRING newHandle (utf)\nTC_LONGSTRING newHandle (long-utf)\n</code></pre>\n<p>其中 <code>TC_BLOCKDATA</code> 这部分对应的是 <code>contents -&gt; content -&gt; blockdata -&gt; blockdatashort</code> ， <code>TC_STRING</code> 这部分对应的是 <code>contents -&gt; content -&gt; object-&gt; newString</code> 。都可以在文档里找到完 整的语法定义。 这一整个序列化对象，其实描述的就是一个字符串，其值是 <code>refObj</code> 。意思是获取远程的 <code>refObj</code> 对 象。</p>\n<p><code>JRMI,ReturnData</code>数据包大一些，下面用它来展示</p>\n<pre><code>STREAM_MAGIC - 0xac ed\nSTREAM_VERSION - 0x00 05\nContents\n  TC_BLOCKDATA - 0x77\n    Length - 15 - 0x0f\n    Contents - 0x0120dea1410000018b3e3ad3308005\n  TC_OBJECT - 0x73\n    TC_PROXYCLASSDESC - 0x7d\n      newHandle 0x00 7e 00 00\n      Interface count - 2 - 0x00 00 00 02\n      proxyInterfaceNames\n        0:\n          Length - 15 - 0x00 0f\n          Value - java.rmi.Remote - 0x6a6176612e726d692e52656d6f7465\n        1:\n          Length - 11 - 0x00 0b\n          Value - RMI_2.ICalc - 0x524d495f322e4943616c63\n      classAnnotations\n        TC_NULL - 0x70\n        TC_ENDBLOCKDATA - 0x78\n      superClassDesc\n        TC_CLASSDESC - 0x72\n          className\n            Length - 23 - 0x00 17\n            Value - java.lang.reflect.Proxy - 0x6a6176612e6c616e672e7265666c6563742e50726f7879\n          serialVersionUID - 0xe1 27 da 20 cc 10 43 cb\n          newHandle 0x00 7e 00 01\n          classDescFlags - 0x02 - SC_SERIALIZABLE\n          fieldCount - 1 - 0x00 01\n          Fields\n            0:\n              Object - L - 0x4c\n              fieldName\n                Length - 1 - 0x00 01\n                Value - h - 0x68\n              className1\n                TC_STRING - 0x74\n                  newHandle 0x00 7e 00 02\n                  Length - 37 - 0x00 25\n                  Value - Ljava/lang/reflect/InvocationHandler; - 0x4c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b\n          classAnnotations\n            TC_NULL - 0x70\n            TC_ENDBLOCKDATA - 0x78\n          superClassDesc\n            TC_NULL - 0x70\n    newHandle 0x00 7e 00 03\n    classdata\n      java.lang.reflect.Proxy\n        values\n          h\n            (object)\n              TC_OBJECT - 0x73\n                TC_CLASSDESC - 0x72\n                  className\n                    Length - 45 - 0x00 2d\n                    Value - java.rmi.server.RemoteObjectInvocationHandler - 0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c6572\n                  serialVersionUID - 0x00 00 00 00 00 00 00 02\n                  newHandle 0x00 7e 00 04\n                  classDescFlags - 0x02 - SC_SERIALIZABLE\n                  fieldCount - 0 - 0x00 00\n                  classAnnotations\n                    TC_NULL - 0x70\n                    TC_ENDBLOCKDATA - 0x78\n                  superClassDesc\n                    TC_CLASSDESC - 0x72\n                      className\n                        Length - 28 - 0x00 1c\n                        Value - java.rmi.server.RemoteObject - 0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374\n                      serialVersionUID - 0xd3 61 b4 91 0c 61 33 1e\n                      newHandle 0x00 7e 00 05\n                      classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE\n                      fieldCount - 0 - 0x00 00\n                      classAnnotations\n                        TC_NULL - 0x70\n                        TC_ENDBLOCKDATA - 0x78\n                      superClassDesc\n                        TC_NULL - 0x70\n                newHandle 0x00 7e 00 06\n                classdata\n                  java.rmi.server.RemoteObject\n                    values\n                    objectAnnotation\n                      TC_BLOCKDATA - 0x77\n                        Length - 56 - 0x38\n                        Contents - 0x000a556e6963617374526566000f3139322e3136382e3136392e3134360000c5b2e3476369ea6a56e120dea1410000018b3e3ad330800101\n                      TC_ENDBLOCKDATA - 0x78\n                  java.rmi.server.RemoteObjectInvocationHandler\n                    values\n      &lt;Dynamic Proxy Class&gt;\n</code></pre>\n<p>这是个<code>java.lang.reflect.Proxy</code>对象，其中有段数据存储在<code>objectAnnotation</code>中:<code>0x000a556e6963617374526566000f3139322e3136382e3136392e3134360000c5b2e3476369ea6a56e120dea1410000018b3e3ad330800101</code></p>\n<p>这段数据记录了RMI Server的地址和端口。</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(3)]/image-20231025010959831.png\" alt=\"image-20231025010959831\"></p>\n<p>然后再看看，本机与RMI Server的交互，虽然wireshark没有识别出RMI，但是从数据包中可以看到<code>50 ac ed</code>，所以是存在序列化数据，一样用工具解析试试，只保留<code>ac ed</code>开头。</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(3)]/image-20231025011457922.png\" alt=\"image-20231025011457922\"></p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(3)]/image-20231025012001967.png\" alt=\"image-20231025012001967\"></p>\n<p>可以看到<code>codebase</code>是通过过 <code>java.rmi.server.Obj</code>;的 <code>classAnnotations</code> 传递的。</p>\n<p>&#x3D; &gt;即使我们没有RMI的客户端，只需要修改 <code>classAnnotations</code> 的值，就能控制<code>codebase</code>，使其 指向攻击者的恶意网站。</p>\n<h2 id=\"classAnnotations是什么？\"><a href=\"#classAnnotations是什么？\" class=\"headerlink\" title=\"classAnnotations是什么？\"></a>classAnnotations是什么？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在序列化Java类的时候用到了一个类，叫 <code>ObjectOutputStream</code> 。这个类内部有一个方法 <code>annotateClass</code> ， <code>ObjectOutputStream</code> 的子类有需要向序列化后的数据里放任何内容，都可以重写 这个方法，写入你自己想要写入的数据。然后反序列化时，就可以读取到这个信息并使用。</p>\n<p>比如，我们RMI的类 MarshalOutputStream 就将当前的 codebase 写入： </p>\n<ul>\n<li><code>https://github.com/JetBrains/jdk8u_jdk/blob/8db9d62a1cfe07fd4260b83ae86e39f80c0a9ff2/src/share/classes/java/rmi/server/RMIClassLoader.java#L657</code> </li>\n<li><code>https://github.com/JetBrains/jdk8u_jdk/blob/8db9d62a1c/src/share/classes/sun/rmi/server/LoaderHandler.java#L282</code></li>\n</ul>\n<p>所以，我们在分析序列化数据时看到的 classAnnotations ，实际上就是 annotateClass 方法写入的 内容。</p></blockquote>\n","feature":true,"text":"RMI2中成功实现了codebase进行加载恶意类，但是在实际环境确实难实现符合环境，所以只作为一个了解和认识。 这篇文章主要分析codebase是如何在RMI...","permalink":"/post/Java安全[RMI(3)]","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"Java漫谈学习","slug":"Java漫谈学习","count":7,"path":"api/categories/Java漫谈学习.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%AE%89%E5%85%A8-RMI-3\"><span class=\"toc-text\">Java安全[RMI(3)]</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8ASerializationDumper%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">数据包解析以及SerializationDumper工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#classAnnotations%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">classAnnotations是什么？</span></a></li></ol></li></ol>","author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java安全[反序列化(1)]","uid":"547938b70509e121d376f42da491592d","slug":"Java安全[反序列化(1)]","date":"2023-10-25T05:28:10.329Z","updated":"2023-10-25T05:43:09.261Z","comments":true,"path":"api/articles/Java安全[反序列化(1)].json","keywords":null,"cover":"/img/61.jpg","text":"终于开始反序列化开篇，之前再RMI的攻击和流程中发现，大多数的数据发送和接收都是反序列化数据。 那么，为什么反序列化常常会带来安全隐患？ 一门成熟的语言，如果需...","permalink":"/post/Java安全[反序列化(1)]","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"Java漫谈学习","slug":"Java漫谈学习","count":7,"path":"api/categories/Java漫谈学习.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"}],"author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java安全[RMI(2)]","uid":"bf4e441f0b57ac113941eef982a20893","slug":"Java安全[RMI(2)]","date":"2023-09-17T03:11:46.797Z","updated":"2023-10-19T14:50:16.272Z","comments":true,"path":"api/articles/Java安全[RMI(2)].json","keywords":null,"cover":"/img/59.jpg","text":"从RMI第一篇描述了RMI的通信过程和组成成分，总结一下，一个RMI过程有以下三个参与者： RMI Registry RMI Server RMI Client...","permalink":"/post/Java安全[RMI(2)]","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"Java漫谈学习","slug":"Java漫谈学习","count":7,"path":"api/categories/Java漫谈学习.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"}],"author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}