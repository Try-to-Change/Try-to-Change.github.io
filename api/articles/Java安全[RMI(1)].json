{"title":"Java安全[RMI(1)]","uid":"08342c15e5fd5518f82b3bdc69d78190","slug":"Java安全[RMI(1)]","date":"2023-09-10T14:13:37.943Z","updated":"2023-09-25T14:46:12.920Z","comments":true,"path":"api/articles/Java安全[RMI(1)].json","keywords":null,"cover":"/img/58.jpg","content":"<p><code>Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入</code></p>\n<p><code>主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt;</code></p>\n<span id=\"more\"></span>\n\n<p>熟悉的名字，在CVE学习中，其中<code>Apache solr</code> 的<code>log4j</code>漏洞和<code>weblogic</code>远程代码执行都提到了<code>RMI</code>，作用如名， <code>RMI（remote method invocation）</code>即<code>远程方法调用</code>。</p>\n<hr>\n<h1 id=\"Java安全-RMI-1\"><a href=\"#Java安全-RMI-1\" class=\"headerlink\" title=\"Java安全[RMI(1)]\"></a>Java安全[RMI(1)]</h1><p><code>RMI</code>的目标其实和<code>RPC</code>类似，是让某个<code>Java</code>虚拟机上的对象调用另一个<code>Java</code>虚拟机上的方法，只不过<code>RMI</code>是<code>Java</code>中独有的一种机制。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>RPC（Remote Procedure Call）</code>是<code>远程过程调用协议</code>，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>\n<p>在分布式计算中，RPC允许运行于一台计算机的程序调用另一个地址空间的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程。RPC是一种<code>CS</code>模式，经典实现是一个通过<code>发送请求-接受回应</code>进行信息交互的系统。</p></blockquote>\n<p>既然是远程调用，那么肯定是存在谁调用谁的关系，这就构成了<code>RMI Server</code>和<code>RMI Client</code>，在<code>Server</code>中实现远程调用的函数和接口，而<code>Client</code>需要知道想要调用方法的接口，然后访问执行即可。</p>\n<h2 id=\"RMIServer\"><a href=\"#RMIServer\" class=\"headerlink\" title=\"RMIServer\"></a>RMIServer</h2><p>⼀个<code>RMI Server</code>分为三部分：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>⼀个继承了 <code>java.rmi.Remote</code> 的接⼝，其中定义我们要远程调⽤的函数，⽐如这⾥的 <code>hello()</code> </li>\n<li>⼀个实现了此接⼝的类</li>\n<li>⼀个主类，⽤来创建<code>Registry</code>，并将上⾯的类实例化后绑定到⼀个地址。这就是我们所谓的<code>Server</code> 了。</li>\n</ol></blockquote>\n<p>先编写一个<code>RMI Server</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> RMI_1;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.Naming;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.Remote;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.RemoteException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.registry.LocateRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RMIServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IRemoteHelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Remote</span> &#123;</span><br><span class=\"line\">        String <span class=\"title function_\">hello</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> RemoteException;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RemoteHelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">UnicastRemoteObject</span> <span class=\"keyword\">implements</span></span><br><span class=\"line\">            <span class=\"title class_\">IRemoteHelloWorld</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"title function_\">RemoteHelloWorld</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> RemoteException &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;call from&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello&quot;</span>+s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">RemoteHelloWorld</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RemoteHelloWorld</span>();</span><br><span class=\"line\">        LocateRegistry.createRegistry(<span class=\"number\">1099</span>);</span><br><span class=\"line\">        Naming.rebind(<span class=\"string\">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">RMIServer</span>().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分析一下代码，</p>\n<ol>\n<li>接口定义</li>\n</ol>\n<p>先定义一个名为<code>IRemoteHelloWorld</code>的接口，它扩展了<code>Remote</code>接口，这是<code>RMI</code>中的一个标记接口。接口声明了一个<code>hello()</code>方法，该方法可以抛出<code>RemoteException</code>异常，这个接口定义了一个远程方法，客户端可以通过<code>RMI</code>调用它。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IRemoteHelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Remote</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> RemoteException;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>远程对象的实现</li>\n</ol>\n<p>这里定义了一个名为<code>RemoteHelloWorld</code>类，实现了<code>IRemoteHelloWorld</code>接口并继承<code>UnicastRemoteObject</code>类。这个类的构造函数调用父类，也就是<code>UnicastRemoteObject</code>类的构造函数，用于创建一个远程对象。<code>RemoteHelloWorld</code>还实现了<code>hello()</code>方法，该方法奖打印一条消息<code>call from</code>，并返回<code>Hello World</code>给调用该方法的对象(如，客户端服务器)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RemoteHelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">UnicastRemoteObject</span> <span class=\"keyword\">implements</span></span><br><span class=\"line\">        <span class=\"title class_\">IRemoteHelloWorld</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">RemoteHelloWorld</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> RemoteException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;call from&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello&quot;</span>+s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动RMI服务器方法定义和执行</li>\n</ol>\n<p><code>start()</code> 方法用于启动<code>RMI</code>服务器。</p>\n<ul>\n<li>创建一个 <code>RemoteHelloWorld</code> 实例 <code>h</code>，这个实例将充当远程对象。</li>\n<li>通过 <code>LocateRegistry.createRegistry(1099)</code> 创建了一个<code>RMI</code>注册表，并指定它监听在<code>1099</code>端口上。</li>\n<li>使用 <code>Naming.rebind()</code> 将远程对象 <code>h</code> 绑定到了 <code>rmi://127.0.0.1:1099/Hello</code> 这个名称下。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RMIServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">RemoteHelloWorld</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RemoteHelloWorld</span>();</span><br><span class=\"line\">        LocateRegistry.createRegistry(<span class=\"number\">1099</span>);</span><br><span class=\"line\">        Naming.rebind(<span class=\"string\">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">RMIServer</span>().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>main方法</li>\n</ol>\n<p>创建<code>RMIServer</code>的实例，并调用<code>start()</code>方法启动<code>RMIServer</code>。</p>\n<h2 id=\"RMIClient\"><a href=\"#RMIClient\" class=\"headerlink\" title=\"RMIClient\"></a>RMIClient</h2><p>RMI客户端相比于RMI服务端的代码就简单一点，只需要访问调用服务端的远程方法即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> RMI_1;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.Naming;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TrainMain</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        RMIServer.<span class=\"type\">IRemoteHelloWorld</span> <span class=\"variable\">hello</span> <span class=\"operator\">=</span> (RMIServer.IRemoteHelloWorld)</span><br><span class=\"line\">                Naming.lookup(<span class=\"string\">&quot;rmi://10.19.16.44:1099/Hello&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> hello.hello(<span class=\"string\">&quot;Ttoc&quot;</span>);</span><br><span class=\"line\">        System.out.println(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里展示的只是本地进行调用<code>RMIServer</code>，要实现真正的<code>RMI</code>，客户端需要服务端提供接口实现方式，如上面代码所示的<code>IRemoteHelloWorld</code>，一般不会把接口和实现都包含在一个类中，而是分开多个文件，这里是为了方便。</p>\n<p>客户端只需要接口打包成<code>jar</code>，这样就能知道<code>RMI</code>可以调用的方法有哪些，并知道服务端的<code>ip</code>和端口即可，然后使⽤ <code>Naming.lookup</code> 在<code>Registry</code>中寻找到名字是<code>Hello</code>的对象，后⾯的使⽤就和在本地使⽤⼀样了。</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230913101103425.png\" alt=\"image-20230913101103425\"></p>\n<p><code>jar</code>打包命令，这就实现了把接口打包的结果</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230913103004923.png\" alt=\"image-20230913103004923\"></p>\n<p>最后在IDEA中将包加到项目结构里即可。</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230917111005900.png\" alt=\"image-20230917111005900\"></p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230917110908280.png\" alt=\"image-20230917110908280\"></p>\n<h2 id=\"RMI流量分析\"><a href=\"#RMI流量分析\" class=\"headerlink\" title=\"RMI流量分析\"></a>RMI流量分析</h2><p>用<code>wireshark</code>抓包看看RMI的通讯数据原理</p>\n<p>为了方便直观看出服务端和客户端，于是用虚拟机跑服务端，主机跑客户端，这里就不会两个ip都是一样的了</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>服务端ip：<code>192.168.169.131</code></p>\n<p>客户端ip：<code>192.168.126.1</code>(实际ip为<code> 10.19.16.44</code>，但是由于主机是通过虚拟机网卡访问的所以，抓虚拟机网卡的流量包时，网卡ip就是主机的)</p></blockquote>\n<p>这里将<code>IRemoteHelloWorld</code>独立为一个文件，所以客户端代码有点不一样，服务端删不删<code>IRemoteHelloWorld</code>都一样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> RMI_1;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.Naming;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RMI_Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">IRemoteHelloWorld</span> <span class=\"variable\">hello</span> <span class=\"operator\">=</span> (IRemoteHelloWorld)</span><br><span class=\"line\">                  Naming.lookup(<span class=\"string\">&quot;rmi://192.168.169.131:1099/Hello&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> hello.hello(<span class=\"string\">&quot;Ttoc&quot;</span>);</span><br><span class=\"line\">        System.out.println(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230913132813979.png\" alt=\"image-20230913132813979\"></p>\n<p>抓个流量包看看，</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230914162413296.png\" alt=\"image-20230914162413296\"></p>\n<p>可以看到整体的过程中发生了两次tcp握手[灰色部分]，也就是在实际情况下构成了两次tcp连接。</p>\n<p>第一次是从客户端的<code>19581</code>端口访问服务器的<code>1099</code>端口，第二次是客户端的<code>19584</code>端口访问<code>55947</code>端口</p>\n<p>其实第一次握手很容易理解，因为我们的客户端设置的就是访问服务端的1099端口，但是为什么后面会莫名其妙访问服务端的55947端口呢</p>\n<p>在流量包的<code>JRMI Return Data</code>中，也就是服务端向客户端发送的流量中可以看到，在最后的服务端ip后面的一个字节<code>\\x00\\x00\\xda\\x8b</code></p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230914163214005.png\" alt=\"image-20230914163214005\"></p>\n<p>通过进制转化可以看到，这个字节正好是<code>55947</code>的对应的网络序列，这也就是为什么客户端会向服务器端的<code>55947</code>端口进行tcp握手。</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230914163037413.png\" alt=\"image-20230914163037413\"></p>\n<p>但其实这段数据中，从<code>\\xAC\\xED</code>开始后，后面的所有数据都属于Java序列化的内容，其中的ip和端口只是这个对象的一部分。</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230914164341663.png\" alt=\"image-20230914164341663\"></p>\n<p>其实可以简单总结一下RMI的流程，</p>\n<p>首先客户端访问连接<code>Registry</code>，并在其中寻找Name名为Hello的对象，这个过程对应数据包中的<code>JRMI,Call</code>。</p>\n<p>而后<code>Registry</code>向客户端发送一串反序列化字符串，代表找到了<code>Name=Hello</code>的对象，这个过程对应数据包中的<code>JRMI,ReturnData</code>。</p>\n<p>客户端反序列化<code>JRMI,ReturnData</code>，发现该对象是一个远程对象，地址是<code>192.168.169.131:55947</code>，于是再与这个地址建立TCP连接，在这个新的连接中，才可以执行真正远程方法调用，也就是<code>hello()</code>。</p>\n<p>可以从下图直观的认识到<code>RMI</code>中各个元素的关系。</p>\n<p><img src=\"/post/Java%E5%AE%89%E5%85%A8[RMI(1)/image-20230917102629249.png\" alt=\"image-20230917102629249\"></p>\n<p>（底下是<code>RMI</code>，单词写错了应该是<code>invocation</code>)</p>\n<p>可以从先从<code>RMI Server</code>开始看，服务端先到<code>RMI Registry</code>上注册了一个Name的对象绑定关系；【如下代码，将<code>RemoteHelloWorld</code>类实例化，然后将其绑定到Hello这个Name上，这就是绑定，然后告诉<code>Registry</code>，这个对象能通过访问给定的名称进行访问】</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RemoteHelloWorld</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RemoteHelloWorld</span>();</span><br><span class=\"line\">LocateRegistry.createRegistry(<span class=\"number\">1099</span>);</span><br><span class=\"line\">Naming.rebind(<span class=\"string\">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, h);</span><br></pre></td></tr></table></figure>\n\n<p><code>RMI Registry</code>相当于一个网关，它本身虽然绑定了远程需要调用的对象，但是它自己是不会执行远程方法的。</p>\n<p>而后是<code>RMI Client</code>，当它知道<code>Name</code>后，会向<code>RMI Registry</code>发送查询请求【如下代码，客户端这里用服务器给的对应的调用的接口<code>IRemoteHelloWorld</code>，创建对象<code>hello</code>，然后向<code>RMI Registry</code>发送想要调用的注册名字，<code>RMI Registry</code>使用这个信息来查找并返回相应的远程对象引用】</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">IRemoteHelloWorld</span> <span class=\"variable\">hello</span> <span class=\"operator\">=</span> (IRemoteHelloWorld) Naming.lookup(<span class=\"string\">&quot;rmi://192.168.169.131:1099/Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>得到远程方法的绑定关系，然后通过这个绑定关系再次连接RMI Server；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> hello.hello(<span class=\"string\">&quot;Ttoc&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这里<code>hello</code>就是获得了<code>RemoteHelloWorld</code>类的远程对象引用，然后用<code>hello.hello(&quot;Ttoc&quot;)</code>进行调用这个类中的<code>hello</code>方法。而这个方法的调用会通过网络发送到服务器端，服务器端会执行对应方法，并将结果返回客户端。这个过程中RMI框架起到的作用就是<code>处理网络通信，序列化，反序列化</code>等细节，使得客户端和服务器之间的通信就像是在本地方法执行一样，但是本质还是在服务器端进行的执行。</p>\n","feature":true,"text":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入 主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt; 熟悉的名字，在CVE学习中...","permalink":"/post/Java安全[RMI(1)]","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"Java漫谈学习","slug":"Java漫谈学习","count":6,"path":"api/categories/Java漫谈学习.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%AE%89%E5%85%A8-RMI-1\"><span class=\"toc-text\">Java安全[RMI(1)]</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RMIServer\"><span class=\"toc-text\">RMIServer</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RMIClient\"><span class=\"toc-text\">RMIClient</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RMI%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90\"><span class=\"toc-text\">RMI流量分析</span></a></li></ol></li></ol>","author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java安全[RMI(2)]","uid":"bf4e441f0b57ac113941eef982a20893","slug":"Java安全[RMI(2)]","date":"2023-09-17T03:11:46.797Z","updated":"2023-10-18T15:38:26.387Z","comments":true,"path":"api/articles/Java安全[RMI(2)].json","keywords":null,"cover":"/img/59.jpg","text":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入 主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt; 从RMI第一篇描述了RMI...","permalink":"/post/Java安全[RMI(2)]","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Java漫谈学习","slug":"Java漫谈学习","count":6,"path":"api/categories/Java漫谈学习.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"}],"author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java安全[反射(3)]","uid":"8c22bcc128dc13c7c13ac9d40b733df9","slug":"Java安全[反射(3)]","date":"2023-09-09T04:23:45.002Z","updated":"2023-09-10T14:11:29.061Z","comments":true,"path":"api/articles/Java安全[反射(3)].json","keywords":null,"cover":"/img/57.jpg","text":"Java学好的主要性太大了，之前我一直没总体归纳，这次彻底狠狠的深入 主要阅读p牛的&lt;&lt;Java安全漫谈&gt;&gt; Java安全[反射(3)]...","permalink":"/post/Java安全[反射(3)]","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"Java漫谈学习","slug":"Java漫谈学习","count":6,"path":"api/categories/Java漫谈学习.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"}],"author":{"name":"Ttoc","slug":"blog-author","avatar":"/static/img/logo.png","link":"/","description":"必须从过去的错误学习教训，而非依赖过去的成功","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}